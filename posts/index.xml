<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>所有文章 - 麋鹿博客 (Elk blog) | 一个分享知识和乐趣的地方</title><link>https://xinyu-yang.github.io/blog/posts/</link><description>所有文章 | 麋鹿博客 (Elk blog) | 一个分享知识和乐趣的地方</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>yangxinyu75@qq.com (Xinyu Yang)</managingEditor><webMaster>yangxinyu75@qq.com (Xinyu Yang)</webMaster><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Fri, 30 Dec 2022 08:54:57 +0000</lastBuildDate><atom:link href="https://xinyu-yang.github.io/blog/posts/" rel="self" type="application/rss+xml"/><item><title>2022 年度总结</title><link>https://xinyu-yang.github.io/blog/2022/22-12-30_22-annual-summary/</link><pubDate>Fri, 30 Dec 2022 08:54:57 +0000</pubDate><author>作者</author><guid>https://xinyu-yang.github.io/blog/2022/22-12-30_22-annual-summary/</guid><description><![CDATA[<p>转眼 2022 年就要结束了。随着年龄增大，越来越感觉光阴似箭。</p>
<p>回想起这一年，感觉可以用一句诗来形容 <strong>“山重水复疑无路，柳暗花明又一村”</strong> 。因为上学的事情，前面大半年都活在焦虑中。</p>
<p>首先是申请签证被 check，中间等了半年，每天去签证网站查看若干次，并且每周发多封邮件询问。随着日子一天天过去，心里焦虑更甚，同时也在默默准备着最坏的打算。</p>
<p>这一切都在半年之后的某一天收到拒签邮件那一刻戛然而止。最终，最担心的事情还是发生了。其实早就想过这方面的可能，但是当事情真正发生，还是觉得突如其来，又感觉如梦方醒。</p>
<p>在 check 期间，就一直发邮件询问学校，如果发生了最坏的情况，学业还能不能继续。我得到了所有来自  Graduate School, Department 和 International Center 的肯定答复。为了再三确认这件事，被拒签之后我又询问了一遍，答复还是类似的：<em>即使来不了学校，还是可以正常毕业。</em></p>
<p>虽然心有遗憾，但还是觉得如果能继续读书，就可以将就。于是，整顿情绪后，开始把重心放在学习和科研上。但是没想到在第二学期即将开始的某一天，发生了一件意想不到的事情：学校通知我 <strong>没办法继续</strong> 学业了！</p>
<p>现在回想起当时的感觉，应该有震惊和难过。震惊的是 Graduate School 对这件事做出了新的解释，即使我之前跟他们的工作人员确认过至少两次（学院和导师可能也确认过）。难过的自然是一年多以来的努力和时间白白浪费了。</p>
<p>不过事到如今，已经是最差的结果了，也没什么可以失去的了。自此人生彻底陷入了低谷，走投无路。那个时候的我正是 “山重水复疑无路” 的感觉。</p>
<p><strong>那就从头再来！</strong></p>
<p>开始找导师、发邮件、等待回复、面试。不得不感慨，欠的东西总有一天要还回来（上次是通过实验室同学介绍，所以没有找导师的过程）。</p>
<p>经过小半年的挣扎（此处略去一万字），总算是拿到了一个还算满意的 offer。自此，焦虑挣扎的日子算是告一段落。但愿 “这一村” 真的能 “柳暗花明”。</p>
<p>以上就是这一年的主脉络，经历百转千回、跌宕起伏。也许若干年后再看这段经历，不过是平淡生活中的小小涟漪。但当时身处其中，尝遍了酸甜苦辣。</p>
<p>另外，前几天也算是赶上了潮流。乘着完全放开后疫情的东风，“阳了” 一把。事情开始于一个周五晚上，准确的说应该是周六凌晨。因为周五晚上我还难掩周末的开心，精神抖擞。但事情到了后半夜就发生了变化。</p>
<p>首先是睡到后半夜的时候被冻醒了。此时我还没觉得有什么大问题，因为那两天恰好是天气最冷的两天，自己只盖了一个薄被子，再加上屋里空调没法制热。</p>
<p>本以为捂紧被子暖和一会就好，但是身体感觉越来越冷，浑身起鸡皮疙瘩。此时也已经睡不着了，只剩裹紧被子瑟瑟发抖。就这样不知躺了多久，在我看到窗外天蒙蒙亮的时候，我知道自己已经开始发烧了。</p>
<p>然后痛苦的熬过一个早上，浑身发热，晕晕乎乎。手上没有任何测温设备或者退烧药，药店里也早已售罄，没办法，<strong>只能硬抗</strong>。</p>
<p>下午向同学通知喜讯，从小猪那里获赐几片 “布洛芬”，<strong>如获至宝</strong> 。就这样又浑浑噩噩熬过一下午，期间没有任何食欲，只喝了点水。到了晚上，早早躺下，期望睡眠能带走病痛。睡觉前吃了一片 “布洛芬”，裹紧被子躺在床上跟寒冷和头痛斗争。不知斗争了多久，才缓缓睡去。</p>
<p>早上起来，出了很多汗，烧也退了。但是慢慢感觉头疼欲裂，外加浑身酸痛。尤其是两个屁股，跟刚打过针一样。就这样躺在床上一动不动，我才确认自己 “中招了”。在这之前我还一直怀疑是这两天太冷，所以受凉发烧。</p>
<p>自己屋里的同事已经有中招的，并且对面的同事也已经出现了发烧的症状。在这种情况下，我居然还天真地以为自己能够幸免，真是太 <strong>naive</strong>。</p>
<p>后续症状正如很多人所分享的那样——嗓子疼、虚弱、咳嗽。不再赘述，因为我相信能够看到这里的你也大概率经历了这些过程，至少我身边的人就很少有幸免的。</p>
<p>总之，一年过去，经历了很多事，但又感觉什么都没发生，恍如一场梦。回头看去，只有一些残存的记忆；细细品嚼，又能品出些许滋味。</p>
<p>在这里做一些总结吧。<strong>经验教训</strong> 如下：</p>
<ul>
<li>不要为了待在舒适圈，而一味的做出妥协，要有跳出舒适圈的勇气。在上学的事上，如果一开始没有一步步妥协，就不会有后来等待通知、听天由命的被动局面。（Life springs from sorrow and calamity; Death comes from ease and pleasure 【<a href="https://en.wiktionary.org/wiki/%E7%94%9F%E6%96%BC%E6%86%82%E6%82%A3%EF%BC%8C%E6%AD%BB%E6%96%BC%E5%AE%89%E6%A8%82#Chinese" target="_blank" rel="noopener noreferrer">生於憂患，死於安樂 - Wiktionary</a>】）</li>
<li>勇于面对困难，而不是选择逃避。回想整个申请过程，一开始是担心英语考试，后面又不敢发邮件套磁，然后一步步逃避。直到最后退无可退，才不得不迎上去，然后发现原本以为的不可逾越也不过如此。</li>
<li>要有正确的自我认知，不要心存侥幸。如果条件相似，发生在别人身上的事情很有可能也发生在自己身上。</li>
</ul>
<p>最后，给明年做一些规划。首先是希望明年能静下心来多读一些书，包括专业书和课外书。专业书虽然会偶尔翻一翻，但是很少有从头到尾读下来的情况。对于一些好的书，即使读过大部分，还是应该重新读一读，温故而知新。</p>
<p>同时还应该读一些课外书，回想起来，我读课外书最多的时候居然还是高中。当时每天挤出每一分一秒时间，读了很多书。后面上大学之后，感觉有了更多自由时间，反而没怎么读过书。一方面，生活不够规律，另一方面，浪费在多媒体娱乐上的时间太多了。</p>
<p>其次，应该多多锻炼身体。毕竟年龄越来越大了，再不注意生活习惯只怕以后吃不消。</p>
<p>这里量化一下这些 <strong>计划</strong>，更好地防止自己偷懒：</p>
<ul>
<li>完整阅读至少两本经典专业书籍。</li>
<li>至少读五本好书。</li>
<li>每周至少锻炼两次，每次不少于半小时。</li>
</ul>
<p><em>人生没有意义，而我在努力让其看起来有意义一点。不知道前面路还有多久，且行且珍惜。</em></p>]]></description></item><item><title>Zotero 配置记录（二：坚果云 WebDAV）</title><link>https://xinyu-yang.github.io/blog/2022/22-11-24_zotero-config/</link><pubDate>Thu, 24 Nov 2022 11:18:16 +0800</pubDate><author>作者</author><guid>https://xinyu-yang.github.io/blog/2022/22-11-24_zotero-config/</guid><description><![CDATA[<h2 id="zotero-配置记录坚果云-webdav">Zotero 配置记录（坚果云 WebDAV）</h2>
<p>之前写过 <a href="../22-02-08_zotero-config.md" rel="">一篇</a> 使用 <code>Zotfile + OneDrive</code> 软链接的方式实现附件同步的记录，但是最近准备切换到坚果云。</p>
<p>之所以使用坚果云所提供的 WebDAV 做备份，不是因为原来的方案不能用。事实上，原来的方案不管在 Windows 平台还是 MacOS 上都表现得很好。
但是如果想要在移动设备上（主要是平板）使用同步功能，软链接的方式就很麻烦了。因为移动设备不支持软链接。</p>
<p>我之前的做法是在 Zotero 里看一下基本信息，如年份、类别、文件名等。然后去 OneDrive 里找到文件，打开。虽然操作也没那么复杂，但是这种方式总让人觉得不优美，很麻烦。
正好有同学在 iPad 上使用 <code>Zotero + 坚果云</code>，我就试了一下，然后发现这种方式太漂亮了！直接沦陷，决定放弃原来的方案，转投坚果云。</p>
<p>坚果云 <a href="https://www.jianguoyun.com/s/pricing" target="_blank" rel="noopener noreferrer">免费版</a> 提供每月 1GB 上传和 3GB 下载。算了一下，感觉对于纯文档操作来说，绰绰有余。</p>
<p>本来坚果云的配置非常方便，但是网上的教程不是写的冗长，就是分不清软链接硬链接的关系，让人看了一头雾水。简单的一个过程非得写的那么麻烦，真是蛋疼。本文将准确直白的记录下该过程。</p>
<p>首先注册坚果云账号，这步没什么难度。但是值得注意的是网上有人说使用带符号的邮箱注册的话，在 Zotero 中配置会有问题。
我本人的邮箱不存在该问题，但是还是提醒大家注意一下。</p>
<p>登录之后，点击 <code>账户信息</code>，然后切换到 <code>安全选项</code> 部分，在底部点击<code>添加应用</code>。
然后随便起个名字，就写 <code>Zotero</code> 吧，注意这个名字仅仅是个名字，跟随后的存储目录无关。
然后你会获得一个密码。到此为止，你所拥有的信息有：</p>
<ol>
<li>服务器地址：https://dav.jianguoyun.com/dav/ （界面上就有）</li>
<li>账户：xxx@xxx.xx （就是注册邮箱）</li>
<li>应用密码：xxxxx （就是刚才所获得的密码）</li>
</ol>
<p>使用这三个信息，你就可以在 <code>Zotero -&gt; Preference -&gt; Sync</code> 页面的 <code>File Syncing</code>部分进行配置。选择 <code>Using WebDAV</code>，然后将上述三条信息填上，然后点击 <code>Verify Server</code>。
理想情况应该显示同步成功。
随后点一下 Zotero 的同步按钮（就是那个绿色的小圆圈箭头）同步下。</p>
<p>多点几次，耐心等等，确认都同步上去了，这个可以通过网页打开坚果云查看，点击 <code>我的文件</code>，就有一个叫 <code>zotero</code> 的文件夹。</p>
<p>待同步之后，还要进行的一个操作就是删除在 Zotero 云盘中占用的空间。
首先打开 <a href="https://www.zotero.org/settings/storage" target="_blank" rel="noopener noreferrer">https://www.zotero.org/settings/storage</a> , 登录。
然后在该页面底部可以看到一个 <code>Purge Storage in My Library</code> 按钮，该按钮将会删除所有的存在 Zotero 云盘中的文件。所以操作之前确定备份好所有的文件！</p>
<p>然后就大功告成了，iPad 和手机端配置类似。</p>]]></description></item><item><title>Python relative import 深入理解</title><link>https://xinyu-yang.github.io/blog/2022/22-05-18_python-import/</link><pubDate>Wed, 18 May 2022 22:05:01 +0800</pubDate><author>作者</author><guid>https://xinyu-yang.github.io/blog/2022/22-05-18_python-import/</guid><description><![CDATA[<p>随着程序的复杂，会逐渐将不同的功能放置在不同的文件中。项目也从简单脚本的单一文件转变为更加复杂的文件结构，这就涉及到不同文件的导入问题。</p>
<p>以前写的程序都比较简单，即使有多个文件，但也是单层次的扁平结构，操作起来也比较简单，尝试一下就可以正确导入。</p>
<p>但是当文件有了更复杂的层次之后，发现文件导入并没有自己想象的那么简单。每次都是盲人摸象般的盲目尝试，直到程序不会报错。靠着这种开盲盒般的操作方式，即使最后得出正确结果，也不知道怎么回事。</p>
<p>也看过一些关于文件导入的文章，但一是没有自己的实际操作；二是很多文章讲的比较肤浅，不涉及本质；甚至有的文章还会给读者错误的导向，害人不浅（这一点后面会说）。</p>
<h2 id="从-modulenotfounderror-说起">从 <code>ModuleNotFoundError</code> 说起</h2>
<p>一般报该错误，常见的有两个原因：</p>
<ol>
<li>如果是第三方包，那么是相应的模块没有安装，直接 <code>pip install *</code> 安装即可。</li>
<li>如果自己写的程序，那么就是包导入的路径不对。本文主要关注的也是该问题。</li>
</ol>
<p>如上所述，如果是第二种情况，即包导入的位置不对。那么我们就应该添加包的查询位置，<code>sys.path</code> 就是用来指定包查找位置的列表。</p>
<p>下面将以下述文件结构举例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">src
</span></span><span class="line"><span class="cl">	├── foo
</span></span><span class="line"><span class="cl">	│   ├── foo.py
</span></span><span class="line"><span class="cl">	│   ├── bar.py
</span></span><span class="line"><span class="cl">	│   ├── __init__.py
</span></span><span class="line"><span class="cl">	├── hello.py
</span></span><span class="line"><span class="cl">	├── main.py
</span></span></code></pre></td></tr></table>
</div>
</div><p>这里 <code>hello.py</code> 中的代码为：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">helloworld</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;hello world&#34;</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>bar.py</code>中的代码为：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">bar</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;This is in bar&#34;</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>接下来试图从<code>foo.py</code> 中导入该函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="c1"># foo.py</span>
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">hello</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">hello</span><span class="o">.</span><span class="n">helloworld</span><span class="p">()</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>该程序理所当然报 <code>ModuleNotFoundError</code>，这是因为包的位置没有被添加到导入路径中，前面也提到，<code>sys.path</code>其实是一个列表，所以我们只需将需要的路径添加到该列表中即可。接下来修改代码如下（很多博客中写的都是此方法）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="c1"># foo.py</span>
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">sys</span>
</span></span><span class="line"><span class="cl"><span class="n">sys</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&#34;..&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">hello</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">hello</span><span class="o">.</span><span class="n">helloworld</span><span class="p">()</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>如果我们在路径 <code>foo</code> 下运行：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ python foo.py
</span></span></code></pre></td></tr></table>
</div>
</div><p>那么程序可以顺利执行。<strong>但是</strong>如果我们在程序根目录下执行：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ python ./foo/foo.py
</span></span></code></pre></td></tr></table>
</div>
</div><p>那么依然会报 <code>ModuleNotFoundError</code> 。经过分析，发现这是因为我们在添加文件路径到 <code>sys.path</code> 的时候，加入的只是相对路径。</p>
<p>而相对路径是相对于现在的执行路径而言的，当前的执行目录为根目录，根目录的上一层当然没有要找的 <code>hello</code>模块，所以程序当然报错。</p>
<p>所以合理的方式是直接导入绝对路径，那么无论在哪里运行，都是可以找到相应的模块的，具体代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="c1"># foo.py</span>
</span></span><span class="line"><span class="cl">import sys, os
</span></span><span class="line"><span class="cl">sys.path.append<span class="o">(</span>os.path.join<span class="o">(</span>sys.path<span class="o">[</span>0<span class="o">]</span>, <span class="s2">&#34;..&#34;</span><span class="o">))</span>
</span></span><span class="line"><span class="cl">import hello
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">hello.helloworld<span class="o">()</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>其中<code>sys.path[0]</code>通过阅读<a href="https://docs.python.org/3/library/sys.html" target="_blank" rel="noopener noreferrer">官方文档</a>可以得知，其代表启动 Python 解释器的脚本的目录路径。</p>
<p>这里就把文件的绝对路径以相对路径（<code>&quot;..&quot;</code>）的方式添加到了查找列表中。添加后的 <code>sys.path</code> 如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="o">[</span><span class="s1">&#39;**/src/foo&#39;</span>, <span class="s1">&#39;/usr/local/lib/python38.zip&#39;</span>, <span class="s1">&#39;/usr/local/lib/python3.8&#39;</span>, <span class="s1">&#39;/usr/local/lib/python3.8/lib-dynload&#39;</span>, <span class="s1">&#39;/home/yang/ML/py4flink/lib/python3.8/site-packages&#39;</span>, <span class="s1">&#39;**/src/foo/..&#39;</span><span class="o">]</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="相对导入-relative-import">相对导入 Relative Import</h2>
<p>按照上述方式可以将模块整个导入，但是有时候我们并不想直接导入整个包，而只想导入包的一部分，比如 <code>hello.py</code>文件下 <code>helloworld</code> 函数。那么我们那么尝试着只导入该函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="c1"># foo.py</span>
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">sys</span><span class="o">,</span> <span class="nn">os</span>
</span></span><span class="line"><span class="cl"><span class="n">sys</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">path</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s2">&#34;..&#34;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">hello</span> <span class="kn">import</span> <span class="n">helloworld</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">helloworld</span><span class="p">()</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>通过测试发现，不管是在根目录还是在 <code>foo</code>目录下都可以正常运行。</p>
<p>接下来我们尝试着从<code>bar.py</code>中导入<code>bar</code> 函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="c1"># foo.py</span>
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">sys</span><span class="o">,</span> <span class="nn">os</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">bar</span> <span class="kn">import</span> <span class="n">bar</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">bar</span><span class="p">()</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>同样，不管从根目录还是从 <code>foo</code> 目录下运行 <code>foo.py</code>都是没有问题的。</p>
<p>此时我们尝试另外一种操作，假设在根目录下的 <code>main.py</code> 文件中需要调用 <code>foo.py</code>中的某个函数 <code>foo</code> ，其代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="c1"># foo.py</span>
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">sys</span><span class="o">,</span> <span class="nn">os</span>
</span></span><span class="line"><span class="cl"><span class="n">sys</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">path</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s2">&#34;..&#34;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">bar</span> <span class="kn">import</span> <span class="n">bar</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">foo</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">    <span class="n">bar</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;This is in foo&#34;</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这是一个很常见的操作，我们需要在 <code>main</code>文件下调用包里的某个文件，然后包里的文件又是相互调用的关系。然后我们尝试在 <code>main</code> 文件中导入该函数，代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="c1"># main.py</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">foo</span> <span class="kn">import</span> <span class="n">foo</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">foo</span><span class="o">.</span><span class="n">foo</span><span class="p">()</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>然后程序居然会报如下错误：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"> File <span class="s2">&#34;**src/foo/foo.py&#34;</span>, line 6, in foo
</span></span><span class="line"><span class="cl">    from bar import bar
</span></span><span class="line"><span class="cl">ModuleNotFoundError: No module named <span class="s1">&#39;bar&#39;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这是为什么呢？按理说 <code>foo.py</code>和 <code>bar.py</code>同属一个目录，直接从本目录下导入应该没有问题吧，为解决该问题，我们先打印出一些信息，在<code>foo.py</code>中添加一些调试代码，同时将导入<code>bar</code>的操作后移：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="c1"># foo.py</span>
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">sys</span><span class="o">,</span> <span class="nn">os</span>
</span></span><span class="line"><span class="cl"><span class="n">sys</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">path</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s2">&#34;..&#34;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">foo</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;This is in foo&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="vm">__name__</span><span class="si">}</span><span class="s1">, __file__: </span><span class="si">{</span><span class="vm">__file__</span><span class="si">}</span><span class="s1">, __package__: </span><span class="si">{</span><span class="nb">repr</span><span class="p">(</span><span class="n">__package__</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="kn">from</span> <span class="nn">bar</span> <span class="kn">import</span> <span class="n">bar</span>
</span></span><span class="line"><span class="cl">    <span class="n">bar</span><span class="p">()</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>再次执行 <code>main</code> 程序，在报错之前，打印出如下结果：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="o">[</span><span class="s1">&#39;**/src&#39;</span>, <span class="s1">&#39;/usr/local/lib/python38.zip&#39;</span>, <span class="s1">&#39;/usr/local/lib/python3.8&#39;</span>, <span class="s1">&#39;/usr/local/lib/python3.8/lib-dynload&#39;</span>, <span class="s1">&#39;/home/yang/ML/py4flink/lib/python3.8/site-packages&#39;</span>, <span class="s1">&#39;**/src/..&#39;</span><span class="o">]</span>
</span></span><span class="line"><span class="cl">__main__, __file__: **/src/foo/foo.py, __package__: <span class="s1">&#39;foo&#39;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>发现导入文件的路径变成了根目录，所以无法找到<code>bar</code>文件的路径了。为了验证该猜想，我们手动在<code>main</code>文件中把<code>bar</code>文件的导入路径加上：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="c1"># main.py</span>
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">os</span><span class="o">,</span> <span class="nn">sys</span>
</span></span><span class="line"><span class="cl"><span class="n">sys</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">path</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s2">&#34;foo&#34;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">foo</span> <span class="kn">import</span> <span class="n">foo</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">foo</span><span class="o">.</span><span class="n">foo</span><span class="p">()</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>运行 <code>main</code> 程序，顺利执行！</p>
<p>但是在写程序的时候，我们不可能像这样把所有包中的文件绝对引用路径全都加上。我们还是希望不管被哪个程序导入，包里所有文件的相对引用位置是不变的。</p>
<p>通过阅读官方文档得知，我们可以采用包相对导入来解决这个问题。相对导入的形式类似于<code>bash</code>中的相对路径，通过在包前面加<code>.</code>来表示相对位置，一个代表本目录，两个代表上级目录，三个代表。。。</p>
<p>根据该方案，我们将 <code>foo.py</code>中的导入操作修改如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">.bar</span> <span class="kn">import</span> <span class="n">bar</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>再次运行 <code>main</code> 程序，顺利执行！</p>
<p>此时好像一切都没有问题了，然后我们尝试着再次执行 <code>foo.py</code> ，发现居然又报错了，这次错误变成了：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">File <span class="s2">&#34;foo/foo.py&#34;</span>, line 8, in foo
</span></span><span class="line"><span class="cl">    from .bar import bar
</span></span><span class="line"><span class="cl">ImportError: attempted relative import with no known parent package
</span></span></code></pre></td></tr></table>
</div>
</div><p>加上一个点之后居然就导入不了了！经过网上搜索，找到了一些解决方案【<a href="https://stackoverflow.com/a/28154841" target="_blank" rel="noopener noreferrer">1</a>】【<a href="https://iq-inc.com/importerror-attempted-relative-import/" target="_blank" rel="noopener noreferrer">2</a>】。</p>
<p>但是还是不太懂根本原因，后来看了<a href="https://docs.python.org/3/reference/import.html" target="_blank" rel="noopener noreferrer">官方文档</a>和<a href="https://stackoverflow.com/a/21233334" target="_blank" rel="noopener noreferrer">该回答</a>中关于<code>__package__</code>变量的解释，我才大概搞明白是怎么回事。其中一些重要的摘录如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-html" data-lang="html"><span class="line"><span class="cl">__package__:
</span></span><span class="line"><span class="cl">...
</span></span><span class="line"><span class="cl">This attribute is used instead of __name__ to calculate explicit relative imports for main modules, as defined in PEP 366. It is expected to have the same value as __spec__.parent.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Changed in version 3.6: The value of __package__ is expected to be the same as __spec__.parent.
</span></span></code></pre></td></tr></table>
</div>
</div><p>大概意思就是该变量用于计算相对导入的位置，并且该变量的值必须和<code>__spec__.parent</code>的值相同。</p>
<p>根据上文可知，当我们执行<code>main.py</code>的时候，我们所打印出的<code>__package__</code>值为<code>'foo'</code> 而当我们单独执行 <code>foo.py</code>的时候，其打印出的值为：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">__main__, __file__: foo/foo.py, __package__: None
</span></span></code></pre></td></tr></table>
</div>
</div><p>所以我认为根本的原因是：当单独执行<code>foo.py</code>的时候，其所在目录下的文件并不被当作 python module，而只是被当成是普通的脚本进行执行。因此相应的<code>__package__</code>值为<code>None</code> ，进而进行relative import的时候，因不满足上述条件，所以报错。</p>
<p>而当从<code>main.py</code>中导入的时候，<code>foo.py</code>目录中的文件都被当成是<code>foo</code>包的一部分，所以可以使用relative import导入成功。</p>
<p>那么能不能以模块的方式运行<code>foo.py</code>呢？答案是可以的，只需要在执行的时候加上<code>-m</code>选项，比如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ python -m foo.foo
</span></span></code></pre></td></tr></table>
</div>
</div><p>那么<code>foo.py</code>就会被当成一个模块来执行。同时我还从<a href="https://stackoverflow.com/a/28151907" target="_blank" rel="noopener noreferrer">该回答</a>中学到一种方式：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="k">if</span> <span class="nv">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span>:
</span></span><span class="line"><span class="cl">    from bar import bar
</span></span><span class="line"><span class="cl"><span class="k">else</span>:
</span></span><span class="line"><span class="cl">    from .bar import bar
</span></span></code></pre></td></tr></table>
</div>
</div><p>这样就可以避免出错了。</p>
<p>至此，大功告成！</p>
<h2 id="总结">总结</h2>
<p>最后说些总结：</p>
<ol>
<li>参考<a href="https://iq-inc.com/importerror-attempted-relative-import/" target="_blank" rel="noopener noreferrer">该文</a>，除<code>main.py</code>等少数包之外，尽量将所有被调用的文件组织成包的形式。</li>
<li>尽量采用<code>import</code>直接导入本地文件，而不是<code>from * import *</code></li>
<li>如果一定要使用<code>from * import *</code>，对于相同路径下的文件，一定要根据是否封装为模块选择合适的导入方式，或者是像上述所说，加上一个判断。</li>
</ol>]]></description></item><item><title>Zotero 配置记录（一：OneDrive 软链接）</title><link>https://xinyu-yang.github.io/blog/2022/22-02-08_zotero-config/</link><pubDate>Tue, 08 Feb 2022 22:21:16 +0800</pubDate><author>作者</author><guid>https://xinyu-yang.github.io/blog/2022/22-02-08_zotero-config/</guid><description><![CDATA[<h2 id="zotero-配置记录onedrive-软链接">Zotero 配置记录（OneDrive 软链接）</h2>
<p>随着所读论文的增多，渐渐觉得有必要对读过的论文进行整理归类。而之前所用的方法可以称之为“文件夹管理”，即通过文件夹对论文进行分类存放。
但感觉这种方式不够灵活专业，更重要的是在写论文的时候还得一个个手动查找添加 bib 文件。
工具都是为需求而生的，以前没读过几篇论文的时候一直 get 不到文献管理工具的意义。
待我尝试之后，才发现该类工具的强大之处。</p>
<p>我最开始尝试的是 EndNote。原因是以前听说过该工具非常强大，并且我们学校恰好有正版软件。
于是很快我就从学校网站上下载了该软件。鼓捣了一会愣是没搞明白怎么使用，从网上看了一些教程，也还是一头雾水。
按理来说，除了非常专业的工具外，对于经常使用各种软件的我，一般的软件不至于连功能都看不懂。
这对我来说是个很大的打击。</p>
<p>我本人有一个习惯，就是选择某个选项之前，即使是某类软件的选择，也会进行大量的调研，读各种博客经验分享，甚至是实际尝试，最后做出选择。
读了一些网上的帖子之后，我将目光锁定到了 Zotero 和 Mendeley 上。</p>
<ul>
<li>Zotero 开源免费（好印象），易用，但同步空间较少（只有 300M）</li>
<li>Mendeley 闭源免费，易用，空间较多 （2GB）</li>
</ul>
<p>经过衡量我决定采用 Zotero + Onedrive 的方式，Zotero 进行文献管理，Onedrive 进行文件同步，Nice! （当然其他的网盘如 Dropbox、GoogleDrive 也适用）</p>
<p>经过实际尝试之后，发现 Zotero 相对于 EndNote 操作简单直观，真是好用太多了。
以下是相关配置：</p>
<div class="details admonition tips open">
        <div class="details-summary admonition-title">
            <i class="icon fas fa-pencil-alt fa-fw"></i>NOTE<i class="details-icon fas fa-angle-right fa-fw"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content">不同设备的语言设置务必相同</div>
        </div>
    </div>
<h3 id="zotero-sync">Zotero Sync</h3>
<p>链接所注册账户，对文件同步进行简单的设置，具体步骤：</p>
<p>打开 Edit -&gt; Zotero Preferences -&gt; Sync</p>
<ul>
<li>Settings -&gt; Data Syncing: 链接账户</li>
<li>Settings -&gt; File Syncing -&gt; Sync attachment files in My Library using: <code>Zotero</code>: True</li>
</ul>
<h3 id="zotfile-插件">ZotFile 插件</h3>
<p>该插件可以将所导入的 pdf 等格式的文件自动归类到所设置的目标目录。对我来说，目标目录是 Onedrive 的同步目录。</p>
<p>下载：从<a href="http://zotfile.com/#how-to-install--set-up-zotfile" target="_blank" rel="noopener noreferrer">该地址</a>下载</p>
<p>安装：Tools -&gt; Add-ons -&gt; ⚙(Install Add-on From File&hellip;)</p>
<p>相关配置：
打开 Edit -&gt; Zotero Preferences
打开 Zotero -&gt; Preferences (MacOS)</p>
<ol>
<li>Advanced
<ul>
<li>Files and Folders -&gt; Base directory: <code>E:\OneDrive\ZotFile</code></li>
<li>Files and Folders -&gt; Base directory: <code>/Users/[username]/OneDrive/ZotFile</code> (MacOS)</li>
<li>Files and Folders -&gt; Data Directory Location -&gt; Custom: <code>E:\Zotero</code></li>
<li>Files and Folders -&gt; Data Directory Location -&gt; Custom: <code>/Users/[username]/Zotero</code> (MacOS 默认)</li>
</ul>
</li>
</ol>
<p>以上设置是帮我们附件的基路径和文件存储目录。
很多软件安装后都需要设置一个默认目录来保存相应数据，而 <code>Data Directory Location</code> 就是这个作用，它将保存 Zotero 所用到的所有数据。</p>
<p>而 <code>Base directory</code> 则是帮我确定一个附件的基路径。我们可以将附件的地址分为两部分：<code>基地址 + 相对地址</code>。
相对地址一般是我们的文件存储结构，其一般保持不变。
而基地址就可以根据需求进行不同的配置，比如在不同的电脑上对于该路径的设置不同。
这种 <code>基地址 + 相对地址</code> 的方式大大增加了灵活性。</p>
<p>打开 Tools -&gt; ZotFile Preferences</p>
<ol>
<li>General Settings:
<ul>
<li>Source Folder for Attaching New Files: <code>E:\Zotero\storage</code></li>
<li>Source Folder for Attaching New Files: <code>/Users/[username]/Zotero/storage</code> (MacOS)</li>
<li>Location of Files -&gt; Custom Location: <code>E:\OneDrive\ZotFile</code></li>
<li>Location of Files -&gt; Custom Location: <code>/Users/[username]/OneDrive/ZotFile</code> (MacOS)</li>
<li>Location of Files -&gt; Use subfolder defined by <code>\%y\%T</code></li>
</ul>
</li>
</ol>
<p>这里的 <code>Source Folder for Attaching New Files</code> 指的是需要被转移的附件的源路径。这个路径是位于我们上面所设置的 <code>Data Directory Location</code> 下的。</p>
<p>有了源路径，那么目的路径呢? 目的路径就是 <code>Custom Location</code> 所配置的内容。这个恰好也是我们上面所述的 <code>基地址</code>。
因为文件被转移到了该文件夹下，所以我们当然要在这里找到文件。</p>
<ol start="2">
<li>Renaming Rules:
<ul>
<li>Renaming Format -&gt; Use Zotero to Rename: <code>False</code></li>
<li>Renaming Format -&gt; Format for all Item Types: <code>{%a_}{%j_}{%y_}{%t}</code></li>
<li>Renaming Format -&gt; Format for Patents: <code>{%a_}{%y_}{%t}</code></li>
<li>Additional Setting -&gt; Delimiter: <code>_</code></li>
</ul>
</li>
</ol>
<p>关于这部分设置可以参考</p>
<ul>
<li><a href="https://www.nrel.colostate.edu/set-up-best-reference-manager/" target="_blank" rel="noopener noreferrer">https://www.nrel.colostate.edu/set-up-best-reference-manager/</a></li>
<li><a href="https://mp.weixin.qq.com/s/0heWcOlwgrF6GHmPTc-poA" target="_blank" rel="noopener noreferrer">https://mp.weixin.qq.com/s/0heWcOlwgrF6GHmPTc-poA</a></li>
</ul>
<h3 id="better-bibtex-插件">Better bibtex 插件</h3>
<p>该插件完善了 Zotero 关于 bib 格式设置上的缺陷，非常好用。</p>
<p>下载：从<a href="https://retorque.re/zotero-better-bibtex/" target="_blank" rel="noopener noreferrer">该地址</a>下载，安装方式与上述相同</p>
<p>相关配置：打开 Edit -&gt; Zotero Preferences -&gt; Better BibTeX</p>
<ol>
<li>Citation keys
<ul>
<li>Citation key format: <code>auth.lower+year+shorttitle(1).lower</code></li>
<li>Keeping citation keys unique -&gt; On conflict &hellip;: <code>postfixed</code></li>
</ul>
</li>
<li>Exprot
<ul>
<li>Fields -&gt; When a reference &hellip;: <code>DOI</code></li>
<li>Fields -&gt; Fields to omit &hellip;: <code>abstract,file,note,keywords</code></li>
</ul>
</li>
</ol>
<p>关于这部分可参考上述下载地址。</p>
<h3 id="delitem-插件">delitem 插件</h3>
<p>使用以上方法链接附件，在 Zotero 删除文件的时候并不会删除其所链接的文件，这显然不是我们想要的。
如果想要删除，还要自己定位到文件真正保存的文件夹，执行手动删除。幸运的是现在已经有插件可以帮我们简化该过程。</p>
<p>该插件可以删除链接文件：<a href="https://github.com/redleafnew/delitemwithatt" target="_blank" rel="noopener noreferrer">下载</a>，是 ZotFile 插件的一个功能补充。
该插件不需要额外的设置，直接安装即可使用。
其功能主要体现在：选中某条目右键，显示删除附件等选项。</p>]]></description></item><item><title>2022 年的第一场雪</title><link>https://xinyu-yang.github.io/blog/2022/22-01-26_the-first-snow/</link><pubDate>Wed, 26 Jan 2022 19:16:14 +0800</pubDate><author>作者</author><guid>https://xinyu-yang.github.io/blog/2022/22-01-26_the-first-snow/</guid><description><![CDATA[<meting-js auto="https://music.163.com/#/song?id=77437" theme="#448aff" autoplay="false"></meting-js>
<p>这首歌应该是我这代人所接触到的第一代神曲，很难想象它已经二十年了。每到下雪的时候，尤其是第一场雪的时候，总是能够想起这首歌。
恰逢最近北京下雪，重听此歌，感觉熟悉又生疏。
有一个模糊地场景浮现在脑海里，临近春节、冰雪未融，一群已放假的小孩满心欢喜地结伴去镇上赶会。
天气正冷，但他们呼着白气说着笑着，一路走走停停，甚至还会微微出汗。
到了集会上，卖东西的小贩、买年货的附近村民，或者是同时具备两种身份的人们熙熙攘攘，一派热闹喜庆。
一条街上往往会有一两个大超市或者时髦的店面，在门口放一个大音箱，我第一次听到这首歌或许就是从这些大音箱里。</p>
<p>说是赶会，但到了镇上也就是重点关注几个卖爆竹的小摊，
仔细盘算着家长给的钱怎么花，该买划炮？还是买二踢脚？或者是买气 gua（得）？[1]。
随着我们慢慢长大，发现每一年爆竹摊上的花样都越来越多。
后来有小蜜蜂，就是那种不会爆炸，而是在地上飞快地旋转，甚至还能飞上天的东西。
还有烟雾弹之类的，现在想想这类爆竹倒没啥意思，只会冒烟。但是当时图新鲜，感觉还是挺好玩的。</p>
<p>咳咳~ 话题逐渐跑偏，重新说回下雪。</p>
<p>许久未见下雪，也即是对雪花的期待最强的时候，如果能迎来一场酣畅淋漓的大雪，会让人开心的手舞足蹈。
这种说法可能有些夸张，我不知道是不是所有人都跟我一样喜欢雪。当然，家里常年下雪的极可能除外。</p>
<p>在这场雪之前，“料事如神” 的气象台自然也早早地预见了这场持续几天的大降雪。
第一天，满怀期待，但不出所料，雪下的果然不大。
稀稀拉拉飘了一天，地上也不过薄薄的一层。第二天也差不多。</p>
<p><figure><a class="lightgallery" href="https://s2.loli.net/2022/01/26/WGSMNTEd9FpZo3c.jpg" title="https://s2.loli.net/2022/01/26/WGSMNTEd9FpZo3c.jpg" data-thumbnail="https://s2.loli.net/2022/01/26/WGSMNTEd9FpZo3c.jpg" data-sub-html="<h2>紫操傍晚雪景</h2>">
        
    </a><figcaption class="image-caption">紫操傍晚雪景</figcaption>
    </figure></p>
<p>第三天早上发现雪还在下，窗外的空调外机上已经厚厚一层雪，“总算是下大了！”。
于是怀着激动的心情，我马上起床、洗漱、出门，然后开心的骑着自行车去了学校。
到主楼门口发现地上雪也同样很厚。于是准备先去实验室看看有没有人，然后找人一块去堆雪人。</p>
<p>到了紫操之后，发现操场已经覆盖了厚厚一层白雪。再加上已是年末，学校里人少，雪地上少了很多踩踏的痕迹。</p>
<p><figure><a class="lightgallery" href="https://s2.loli.net/2022/01/26/5MDNf4nJVpBwuxc.jpg" title="https://s2.loli.net/2022/01/26/5MDNf4nJVpBwuxc.jpg" data-thumbnail="https://s2.loli.net/2022/01/26/5MDNf4nJVpBwuxc.jpg" data-sub-html="<h2>紫操雪景</h2>">
        
    </a><figcaption class="image-caption">紫操雪景</figcaption>
    </figure></p>
<p>好美一场雪，雪大，风小，雪花飘然落下，很富有诗意。
突然想到小时候背的一篇文言文，其中有一句 “未若柳絮因风起”，确是此情此景的准确描述。
文中还有另外一句 “撒盐空中差可拟”，想来我也确实遇到过这样的雪，寒风刺骨，细小的雪粒如刀子一般打在脸上。
这样的雪想必是不太讨人喜欢。</p>
<p>走到操场上，踩在雪地上咯吱作响，非常舒适。
书包往足球框旁边一放，很快就开始动手堆雪人。
开始上手之后，发现滚雪球比我想得难多了。雪球并没有如我想的那样，放在地上一滚就能沾上很多雪，进而逐渐变大。
该开始堆的时候，所有的雪几乎都是用手糊上去的。待我感觉雪球已经差不多大小的时候，就开始在地上滚。
但是可能是雪太蓬松的缘故，雪球的重量还是不足以把雪沾上来。于是就不得不一直用手追按着雪球来回滚动，就像在地上搓泥丸一样（伸腿瞪眼丸）。
期间还有一个大妈端着手机走来，隐隐约约听到她说了句“真是个老小孩”，额~ <strong>老</strong>小孩~</p>
<p>哎，看来自己真的是老了呀😟</p>
<p>滚了一上午，感觉筋疲力尽，才推了两个半大的雪球，不过还好比例适中。于是就准备把他们放在一块，堆成个雪人的形状，如下图所示：</p>
<!--![](https://s2.loli.net/2022/01/26/9ntqwLlVd8eMBvW.jpg "雪人")-->
<figure><a class="lightgallery" href="https://s2.loli.net/2022/01/26/9ntqwLlVd8eMBvW.jpg" title="https://s2.loli.net/2022/01/26/9ntqwLlVd8eMBvW.jpg" data-thumbnail="https://s2.loli.net/2022/01/26/9ntqwLlVd8eMBvW.jpg" data-sub-html="<h2>雪人</h2>">
        
    </a><figcaption class="image-caption">雪人</figcaption>
    </figure>
<p><em>[1] 就是穿云箭，具体发音是这个，但是不太清楚是哪个字，“**得”是我们那个方言中常用的说法，如“面条得”、“瓜子得”&hellip;</em></p>]]></description></item><item><title>Markdown 中的数学公式</title><link>https://xinyu-yang.github.io/blog/2021/21-12-04_math-in-markdown/</link><pubDate>Sat, 04 Dec 2021 00:11:45 +0800</pubDate><author>作者</author><guid>https://xinyu-yang.github.io/blog/2021/21-12-04_math-in-markdown/</guid><description><![CDATA[<p>本文主要记录在使用不同的主题时，所遇到的有关 markdown 中公式渲染的问题。</p>
<p>首先是 even 主题，该主题使用的是 mathjax 进行公式的渲染，经过网上了解， mathjax 是一个很成熟的解决方案，所以其对数学公式的支持还是很完善的，但是在使用较复杂的数学公式环境过程中还是遇到了一个问题，如:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-markdown" data-lang="markdown"><span class="line"><span class="cl">\begin{align}
</span></span><span class="line"><span class="cl">x <span class="err">&amp;</span>= y + 1 \\
</span></span><span class="line"><span class="cl">y <span class="err">&amp;</span>= z + 2
</span></span><span class="line"><span class="cl">\end{align}
</span></span></code></pre></td></tr></table>
</div>
</div><p>在 $\LaTeX$ 中是没有问题的，但是在 hugo 就无法被正确渲染，只有将换行符<code>\\</code>更改为<code>\\\\</code>才能正常工作，好像看到网上有相关的讨论（没有记录），说导致该问题的原因是 markdown 编译器在进行解析的时候会将第一斜杠解释为<em>转义</em>，那么最后的结果是只剩一个斜杠，所以如果想让其最后仍然有两个斜杠，则不得不用四个斜杠。虽说敲四个斜杠是麻烦了点，但是好歹问题算是大概解决了。</p>
<p>后来试用 CodeIT 主题时则出现了更严重的问题，主要是因为该主题使用的是据说是性能更好的 $KaTeX$ 渲染器。该渲染器作为托管在 github 的开源项目还是挺受欢迎的，但是 katex 对于公式的支持就不那么完善了，截止到目前的最新版本 0.13.0，刚能够支持诸如<code>align,align*</code>等环境。而 CodeIT 使用的仍然是 0.11.1 的老版本，但这还不是主要问题，主要问题是原本在 mathjax 中可行的方案在 katex 中不可行了，比如根据<a href="https://katex.org/docs/0.11.1/supported.html" target="_blank" rel="noopener noreferrer">文档</a> katex v0.11.1 中是支持<code>aligned</code>环境的，但是以下代码并不能够被正确渲染：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-markdown" data-lang="markdown"><span class="line"><span class="cl">\begin{aligned}
</span></span><span class="line"><span class="cl">x <span class="err">&amp;</span>= y + 1 \\\\
</span></span><span class="line"><span class="cl">y <span class="err">&amp;</span>= z + 2
</span></span><span class="line"><span class="cl">\end{aligned}
</span></span></code></pre></td></tr></table>
</div>
</div><p>该代码可以在 even 主题下正常工作，但是无法在 CodeIT 在工作，经网上搜索，发现了该<a href="https://github.com/halogenica/beautifulhugo/issues/183" target="_blank" rel="noopener noreferrer">解决方案</a>，经该方案介绍，使用如下代码可正常工作：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-markdown" data-lang="markdown"><span class="line"><span class="cl">\begin{aligned}
</span></span><span class="line"><span class="cl">x <span class="err">&amp;</span>= y + 1 \cr
</span></span><span class="line"><span class="cl">y <span class="err">&amp;</span>= z + 2
</span></span><span class="line"><span class="cl">\end{aligned}
</span></span></code></pre></td></tr></table>
</div>
</div><p>其效果为：
$$
\begin{aligned}
x &amp;= y + 1 \cr
y &amp;= z + 2
\end{aligned}
$$</p>
<p>主要改动为将斜杠更换为<code>\cr</code>，经测试可以正常工作，然后将该方式在 even 主题中测试也可以工作，所以就计划采用这种方式来代替双斜杠的功能，虽然感觉像是最后对问题的妥协，但是好歹是解决了该问题😂</p>
<p>后来有对问题做进一步的探索，做法是在浏览器中查看网页的源代码，我发现使用斜杠做为换行符的方式都会在公式行的最后引入一个<code>&lt;br&gt;</code>标签，如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-html" data-lang="html"><span class="line"><span class="cl">\begin{aligned}
</span></span><span class="line"><span class="cl">x <span class="ni">&amp;amp;</span>= y + 1 \\ <span class="p">&lt;</span><span class="nt">br</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">y <span class="ni">&amp;amp;</span>= z + 2
</span></span><span class="line"><span class="cl">\end{aligned}
</span></span></code></pre></td></tr></table>
</div>
</div><p>具有标签的代码在使用 mathjax 渲染器的时候是可以被正常渲染的，但是在 katex 中却不行。而使用<code>\cr</code>进行换行则不会引入<code>&lt;br&gt;</code>标签，因此在 katex 中可用。
最后附上将换行符更改为<code>\cr</code>的命令:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">sed -i <span class="s1">&#39;s/\\\\\\\\/\\cr/&#39;</span> <span class="o">[</span>blogname<span class="o">]</span>.md
</span></span></code></pre></td></tr></table>
</div>
</div><p>&mdash;&mdash;&mdash;&mdash;21/04/08更新&mdash;&mdash;&mdash;&ndash;</p>
<p>除上述所示问题外，今天又遇到了另外一个问题，那就是在公式中使用特殊字符（如%）时需要进行转义，一般写为<code>\%</code>，但是这又会遇到一个问题，就是在$符号之间的字符不能够像在 ` 符号中那样被免于转义。也就是说<code>\%</code>中的斜杠会在markdown解析的过程中解析为转义字符，因此到公式解析器的时候剩下的就只剩一个%符号了，所以需要使用两个符号才行。关于这个问题，感觉主要问题还是在markdown解析器那里没有执行正确的解析。当然，以上只是我的猜想，有时间我会去验证的。</p>
<p>知道问题之后的解决方式呢？如果实在不得不用特殊字符的转义，那就使用上述方法，可以解决。如果不是必要，比如我这里就是将%作为模运算符号，其实math里有专门的符号<code>\mod</code>表示该含义，所以出于兼容性期间，决定使用<code>\mod</code>符号，因为万一哪一天markdown解析器可以正常解析了，岂不是还要把两个斜线换成一个。</p>
<p>同时这里有一个总结：
<div class="details admonition tip open">
        <div class="details-summary admonition-title">
            <i class="icon fas fa-lightbulb fa-fw"></i>总结<i class="details-icon fas fa-angle-right fa-fw"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content"><strong>在markdown的公式环境中尽量减少使用转义符👉<code>\</code>👈</strong></div>
        </div>
    </div></p>]]></description></item><item><title>乘坐北京地铁有感</title><link>https://xinyu-yang.github.io/blog/2021/21-11-24_beijing-subway/</link><pubDate>Wed, 24 Nov 2021 20:21:38 +0800</pubDate><author>作者</author><guid>https://xinyu-yang.github.io/blog/2021/21-11-24_beijing-subway/</guid><description><![CDATA[<p>今天再次有幸乘坐北京早上八点左右的地铁，有一些想法，本文进行记录。</p>
<p>之所以强调北京早上八点的地铁，因为这个时候的地铁不同一般时间，具有鲜明的特点。如果用一个字来形容的话，那就是“快”。不光地铁快，人也快。
人是怎么个快法呢？就是地铁站里的乘客大多都是在小跑，而不是普通的走路甚至是快走。此时的乘客就像是灾难电影中慌忙逃生的人群。如果是初次置身于此情此景，恐怕会感到惊讶。</p>
<p>仍记得 17 年刚来北京那会，年少无知，坐扶梯的时候站在了扶梯左侧，受到过几次不耐烦的 “借过一下” 甚至是抱怨。
我刚开始还觉得有点奇怪，后来渐渐习惯了， 便察觉自己之前的少不更事，并养成了坐扶梯一定站在右边的习惯，或者干脆加入他们，在左侧走，体验 <em>速度 x2</em>。</p>
<p>这个习惯是在北京养成的，以至于后来即使在其他城市坐地铁时也是如此。即使这些城市没有人在扶梯上走，事实上北京也是我迄今为止唯一经历过此情此景的城市。当然，原因可能是我并没有经历过其他城市的早高峰。</p>
<p>其实三年前有过一段时间的工作经历，也是每天都在赶早高峰，但是这次经历似乎有不一样的体验。或许是自己三年来对这个场景变得陌生，也或许是自己当时没有时间静心观察这些。
不知为何，此时心里突然有了一个令自己哭笑不得的想法：希望以后自己能做一个走着坐地铁的人。</p>
<p>今天在做第一班车的时候空间还算比较富裕，但是当转到另外一条线时，情况就发生了变化。看着停靠的车厢里挤满了人，本以为会有好多人下车，从而能够给我们下面这帮排队的人腾出点位置。可没曾想居然一个下的都没有，看着队列前面还有好几个人，就想着等前面几个上去，然后自己等下一班吧。
结果等我前面的人都走强行挤上去之后，我后面的人也跃跃欲试，此时上不上车已由不得我了，因此只能拼命挤上车，为了不让门夹住书包，只得拼命抓紧扶手把自己的身体往里挤。</p>
<p>还好等到门顺利关上，我就可以稍微放松，把身体倚在门上。很快到了下一站，可怕的是这种情况还在重复，又挤上来两个大姐。我本来握在侧边扶手上的手被大姐建议“抬一下”以便她能上来，然后我就把手以一个奇怪的角度握住上方的扶杆。
因为姿势别扭且费力，我就想反正都几乎动不了了，也就没必要扶什么扶手了。想到这里我自认为机智地把手松开，然后发现我的手似乎没地可放，垂直放下去是不可能的，因为此时很难通过那道人与人之间紧贴而形成的屏障。
所以我就又把手搭在了扶手上，这下扶手可真的被用来 <strong>“扶”</strong> 手了。</p>
<p>当我在车厢里无聊的左顾右看的时候，我注意到其实大多数人都很专注，有的在专心刷短视频，有的在看剧，甚至还有的在玩连连看。
总之，为了不浪费在车上的时间，社畜们各显神通。令人惊奇的是，在这种环境下，他们居然表现出了就像在自家沙发上玩手机一样的舒适感，人类超强的适应能力再次得到了证明。</p>
<p>随后我又想到了一个问题，他们是怎么把手机拿出来的呢？我感觉比较可能的答案就是：他们在上车的时候手机就一直拿在手里，高举着手机走进车厢，然后高举着下车。就像虔诚的信徒将十字架举过头顶，从而彰显着所持物品的无上地位。
想到这里感觉还挺有意思，似乎干愣着也没那么无聊了。</p>
<p>北京给我最深的印象不是遍布的古迹、公园，也不是繁华的商圈，而是北京的 <strong>“快”</strong> 和 <strong>“挤”</strong>。不同的人肯定感触不同，而匆忙拥挤的生活节奏可能就是我这个阶层的人在这个城市所能拥有的最多的感受吧。</p>]]></description></item><item><title>托福考试总结</title><link>https://xinyu-yang.github.io/blog/2021/21-10-27_toefl-summary/</link><pubDate>Wed, 27 Oct 2021 10:34:07 +0800</pubDate><author>作者</author><guid>https://xinyu-yang.github.io/blog/2021/21-10-27_toefl-summary/</guid><description><![CDATA[<h2 id="心路历程">心路历程</h2>
<p>现在已经距离考试有一个多月了，早就打算写一写总结，但是一拖再拖，就像我下的坚持学习英语的决心那样，一直没有付诸实践。现在做一个简单的开篇，慢慢填补内容，免得再往后拖。</p>
<p>书归正传，我之所以要考英语，是因为要出国读博，（插播：写下这段文字的我刚收到纸质版 TOEFL 成绩单）。一直以来英语都是我不敢直面的学科，对于这门课我心里只有逃避，就想着某一天再也不用学英语。曾经高考的时候，以为高考就是结点。后来上大学之后，又结结实实被四六级折磨了几年，因为不是硬性毕业规定，所以直到本科毕业都没能考过六级（最高一次 423）。
后来考研，又不得不面对这个老对手，不过因为考研英语比较难，很难考出比较高的分数且拉开差距，所以并没有太多的压迫感。</p>
<p>到后来读研究生，发现英语不但没有从我的生命中消失，反而显得越发重要。从读论文，到听国外学者的讲座，甚至到自己参加国际会议，英语都必不可少。所以自己平时也在背背单词什么的，事实也证明，经常接触英语确实可以提高英语水平，因为在这期间通过了一直没有考过的英语六级。
但在我下定决心出国之前，也从没想过要考托福或者雅思之类的。</p>
<p>后来由于一些原因，在本实验室读博无望的情况下，我决定出国读博。相对于国际疫情和中美贸易战等因素，我最担心的可能就是自己的英语考试了。不管去哪个国家，英语是必须通过的标准，也是我在做准备工作时的最高优先级。</p>
<p>最终经过了三个多月的集中备考，总共经历了两次考试，最终的分数定格在了 103，相对于网上各种复习俩星期分数 105+ 的大佬们，这个分数肯定不算啥，但对我来说已经是很不错的成绩了。
接下来将介绍我备考的经过。</p>
<h2 id="复习经验">复习经验</h2>
<p>正式的英语备考从研究生毕业开始，毕业之后就紧张的投入到备考之中了。首先是先报名，登录到网站上之后，我惊奇的发现北京最近的可以报名的时间竟然在四个多月之后。于是果断地查看了临近地区的考点，幸运的是石家庄就有两个月之后的名额，于是毫不（不敢）犹豫地报上了名。
刚开始备考的前几天我先在网上看了各种备考的经验和指南，对 TOEFL 有了一个大概的认识，包括考试时长、形式、大概内容等。
然后开始做了几套 TPO，做完之后发现阅读是我感觉唯一有把握的，听力完全听不懂，口语就更不用说了，完全不知道如何下手，至于作文嘛，感觉也没啥能力拿高分，就随便写了写~</p>
<p>于是，针对以上问题，我开始了备考准备之路。首先按照网上的备考经验用 Excel 表格做了一个备考计划，第一次计划了一周的内容。打算先看看效果，然后再根据自己的情况进行调整。
刚开始的计划不算特别多，大概就是每天精听半套 TPO，做一套阅读题，写一篇作文并更改。对，在这个阶段，口语直接放弃了😂，或者是完全不知道怎么复习。</p>
<p>一周之后，计划差不多完成了。听力还是听不懂，阅读则可以稳定在 25 以上，作文还是语法错误连篇，且有时候不知道怎么写，在计时的时间内连 300 字都写不到。
于是，我针对该学习效果进行了计划的调整。将比较薄弱的听力调整为每天听写半套 TPO（后几天改成了跟读），阅读每天一篇，以维持状态。作文和<del>口语</del>复习方式不变。</p>
<p>又过了一周左右，发现听力还是没有提高，始终维持在 16-20 之间，鉴于听写或跟读实在是太耽误时间，再加上有的帖子说需要将 TPO 都听一篇，熟悉所有话题。我就决定还是精听吧，每天一套 TPO，提高速度。阅读偶尔会计时做一套，分数大概维持在 25-27 左右，但始终没有突破 27。
作文感觉好了一点点，但是进步不大。对于我来说，遣词造句都很困难，所以也就没有做过多的解题思路，答题逻辑方面的练习，而是将重点放在了如何能写出一些没有语法错误的句子。
与此同时，口语也每天练习一套，但一般都是草草就过了，有时候实在啥都说不出来的就多说几遍。后来的事实证明，这种口语练习方式不能说是收效甚微吧，简直可以说是毫无用处。</p>
<p>等差不多过了一个月左右的时候，听力还是没有提高。因为之前看过的很多备考帖子和视频都是建议精听，所以我就想当然地以为只要精听一段时间，听力自然而然的就会提高。
因此每天几乎如打卡一般，听完了就算完成任务了。
但已经精听了一个月了，我的听力还是没有提高，此时我已经有点慌了，我就想是不是这个方法不太适合我。于是又在网上重温了各种关于听力的备考经验帖、视频，甚至请教了前段时间备考的同学。
但似乎最终只能得出一个结论：继续保持精听。</p>
<p>即使心里非常忐忑，还是继续保持每天的精听练习，只是听的时候不敢再有丝毫大意，聚精会神，确保自己能听懂每一个词。
随着时间一天天过去，虽然偶尔听力分数能到 22-23 分，但是大部分还是在 20 分左右徘徊。在这期间阅读、作文和口语也都在练习。</p>
<p>很快就到了第一次考试，个人加考试环境等种种因素导致最终只考了 86（27+21+16+22） 分。此时距离备考已经过了两个月，最终还是没能考到 90 分，心情还是比较沮丧的。但同时也感觉 90 分不是那么遥不可及。</p>
<p>考完之后，觉得听力还是需要多加练习，当然，这一点我考试之前就知道，因为毕竟平时的练习效果摆在那，自己确实就是这个水平。
除了听力，另外让我震惊的就是口语了，分数低得超乎我的想象。不过想想自己之前复习口语的态度，也算是理所当然吧。</p>
<p>第二次考试跟第一次相隔差不多 40 天，但感觉自己的有效复习时间顶多 20 天。因为第一次考试完等成绩的那一周时间几乎什么都没干。然后后来又干了点其他事，也算是对托福备考的逃避。</p>
<p>等考前 20 天左右再准备复习时，就采取了重点复习听力口语，保持阅读作文的策略（其实差不多一直这样）。听力的练习方式就是 1.5 倍速精听 TPO 真题，一套接着一套，一篇接着一篇，疯狂听。当然，对于每一篇，一定要完全听懂才算合格。</p>
<p>痛定思痛下，决定对口语也要采用更积极的态度去复习，说到这里，我不得不感谢在网上看到的一个备考经验贴。该帖给我提供了很多方法上的借鉴，同时还有心态上的鼓励。
发帖的应该是位小姐姐，她把自己的备考经验和资料放到了这个 <code>6635388600</code> 百度云盘群里，需要的可以加群下载。</p>
<p>这其中对我最重要的就是关于口语第一题的备考，大概思路就是找一些常用的语料库熟练背诵，然后说的时候就往上套。该方法其实可以分为两步：</p>
<ul>
<li>第一步：把所有的范文全部熟练背诵，最好能达到不假思索的程度</li>
<li>第二步：疯狂做题（每天 20+ ），把所有的题都往语料库上靠，然后熟练作答</li>
</ul>
<p>通过该方法，第一题可以比较熟练的答出来，这会给作答后面的几道题带来很大的信心提升。即使单从英语熟练度上来看，经常练习也是很有帮助的。</p>
<p>第二次考试的时候，口语从 16 分提高到了 22 分，虽然不高，但对我来说是一个很大的进步了。而这很大程度上都要感谢上面的练习方法。</p>
<h2 id="考试过程">考试过程</h2>
<p>疫情期间的报名和考试并不是一件容易的事情，对我来说，事实也是如此。报名的曲折和备考中的挫折可以说是相得益彰、互不相让。</p>
<p>首先，因为北京的考试报不上，就报名了还算离得比较近的石家庄，这个过程还算比较顺利。直到考试前两周的时候，收到了一条考场取消的短信，才拉开了我曲折的报名之路的大幕。考场由于官方取消，可以免费更换考场或者退考。
于是，没有任何迟疑，我迅速寻找周边能报名的地，搜索了一圈之后发现呼和浩特似乎是个不错的选项，从北京坐高铁只需要两个多小时。
已经算是周边离得最近的了，同时也觉得内蒙那边人烟应该比较稀少，不大可能因为疫情取消吧（实际上取消考场的石家庄好像也没有疫情消息，至少从官方上没有）。</p>
<p>于是就赶紧报名了内蒙古农业大学的考场，考试时间距离石家庄那场又晚了两周。心里感慨浪费了时间的同时还有一些庆幸，
感慨浪费时间是因为我不想第一次考试花太多时间备考，因为这样的话感觉容易一直陷入一些复习盲区，不能对自己的错误进行及时的纠正。
庆幸当然是因为我直到自己复习的实在是不行😂，反正就是想逃避。</p>
<p>等把石家庄的车票、住宿都退掉，然后又订好呼和浩特的车票和住宿，并全力备考的时候，我又收到了考场取消的消息。
上网查了查内蒙古好像也没有新的疫情，考场就这样莫名其妙地取消了。心烦且无语，但经历过一次改签后，也有一些心理准备。
不敢有任何迟疑，我又马上投入到新的考场查询、转考、退票、订票等一系列操作当中。
但查来查去，好像在差不多的考试时间，附近城市都没有考场。无奈只好把范围一再扩大，最后发现西安有一个几乎同一时间的考场，于是稍作权衡，决定转考到西安。</p>
<h3 id="西安考试">西安考试</h3>
<p>好在这次的考场没有被取消，但随后的经历让我对这件事的好坏有了怀疑。
这次的考试地点是陕西师范大学，西安的两个托福考场之一，记住这个考场的名字，因为我接下来要重点说一下关于这个考场的切实体会。
因为西安当时要办全运会（后来才知道），所以入境要求严格，根据网上可以查到的相关通知，所有的来客都要携带核酸检测证明。
好在我看到了该通知，坏在我在上车之前才看到该通知。本来就觉得北京和西安都是低风险地区，而且北京对低风险地区没有什么核酸检测要求。
所以我就想当然的以为西安也没有要求。结果临上车一查，吓了自己一大跳，然后脑子里就飞快地盘算 “咋办？咋办？”。</p>
<p>现在做核酸检测也来不及了，而且就算来得及，几个小时之后还是拿不到结果。然后就又想如果没有核酸证明，到时候会被怎么处理，也许直接让买票回去，或者强制隔离，再或者现场做核酸。
感觉最后一种应该是最好的可能了。
然后，就怀着这样忐忑的心情，我上了高铁。一路上在搜索关于西安疫情管控的消息，但是没有看到任何有价值的信息。
于是我原本打算好好利用起来复习的几个小时，就这样白白浪费掉了。路上宾馆前台给我打来电话，问我当晚能否入住，我感觉她们可能比较了解相应的防疫政策，
就询问她们，但也没有得到准确回复，不过据说顶多会现场给做核酸。
听到这些，我的心也就稍稍宽慰了些。</p>
<p>等下了火车之后，我就紧张地关注附近有没有盘查点，并且一边还想着如何应对。结果直到我进了地铁站，除了期间有一个比较敷衍的查看行程码的关口，期间没有遇到任何盘查。哎，虚惊一场。</p>
<p>因为考场要求 48 小时之内的核酸检测，所以我就提前两天到了，然后考试前一天早早地去检测核酸，然后下午拿到结果。住的地方我定在了紧挨着学校的一个宾馆，后来知道这其实也是陕师大的招待所。
宾馆在一个三层的美食城里面，宾馆前台正对着一层美食城门口。待我放好东西之后，差不多是下午六点多，于是我就准备去找点吃的。溜达了一下发现，这个美食城其实就是陕师大围墙的一部分，从学校东门出来就进到了美食城的里面。
到饭点的时候，来吃饭的大都是学校的学生。</p>
<div class="mapbox" id="id-1" style="width: 100%; height: 20rem;"></div>
<p>吃完饭后，我发现门口的保安管的好像并不严，就打算进去看看考场的位置。然后我就背着书包大摇大摆地进了学校。进去之后，感觉学校挺大的，但是从东门进离考场不远。从考场楼下溜达完之后，我就从另外一条路返回学校大门，然后发现了一条更近的小路。
第二天在附近的医院做完核酸检测并顺利的拿到证明，然后又经过了紧张焦虑的一晚上，第三天考试才正式开始。</p>
<p>顺着前两天熟悉过的考场位置，我不到八点就到了考场，此时一楼负责检查的一个老师正在玩狂野飙车。看到有人来，就赶紧结束了游戏。
此时的我感觉紧张的心都快跳出来了，看到这个老师还在这悠闲地打游戏，不禁感慨人的悲伤真是互不相通啊。
随后我按照他们的指示出示了身份证什么的，然后寄存了书包，最后经过了类似于坐火车时一样的安全扫描，我就被告知去二楼等待。
此时二楼已经来了俩考生，有一个正在斜倚着靠背睡觉。我就找了个位置坐了下来，按要求填了一个保证书，随后焦急不安地度过考试前的最后二十多分钟。</p>
<p>然后等时间差不多之后，我们就被告知排队进入楼上考场。然后我们就排好了队，一个个照相，最后进入了考场的指定座位。
坐到座位上之后，我先检查了所有的东西，包括铅笔、纸、耳机、鼠标等。当我测试铅笔的时候，还被警告不能写东西。
因为疫情的原因，整个考试都要带着口罩，并且耳机什么的也都有一次性保护套（可能一直都有），但是考场并没有给套上，所以还得等待考试开始的时候自己套上。</p>
<p>考场的桌子摆放相当拥挤，并且隔板很低，我正常坐直的话，可以很容易的看到前面考生的屏幕。当然，别人的动作也会对我造成干扰，而且很有可能口语的时候会非常吵，这让我感觉很郁闷。
事实证明我的担忧并非多虑，在考试听力的时候，还真的遇到了一个让人很崩溃的事。</p>
<!--欲知后事如何，请看下回分解。。。-->
<p>听力考试时间，大家纷纷举手找老师换草稿纸，前面已经说过，座位之间的挡板很低，所以人来人往的免不了影响注意力，但也算可以接受。正当我努力将注意力拉回考试之际，右前方有位大姐举手换草稿纸。
监考老师没有注意到，于是她就开始呼叫老师。虽然可以听出其出于不影响其他人而故意压低的声音，然而这种声音已经足以使我的注意力转到她那。
然后监考老师匆忙赶来，给她更换了草稿纸。原以为事情就此结束，但随后她突然自言自语了一声“我记的笔记还在原来的纸上”，于是再次呼叫老师。
监考老师再次匆匆赶来，但是考试时间并不会停，所以等老师赶来的时候，那道题的时间已经结束。
看着无法更改的结果，她很生气，于是就你一言我一语地跟监考老师理论了起来，什么 “没及时看到我举手”，“耽误我的考试时间” 等等。
直到下到题开始，监考老师劝她先考试，争论才暂时结束。而这些生动的对话场景就发生在我面前。</p>
<p>听完我对这件事如此详细的叙述，你应该就能明白我的听力分数能有多么精彩。这种干扰对于听力好的可能影响不大，但是对于我这种水平本来就不太行，分数全靠状态的选手而言，打击不可谓不大。</p>
<h3 id="开封考试">开封考试</h3>
<p>第二次考试是在开封大学，大约是在我第一次考试的 40 天之后。在这期间，我专心复习了大概 20 天左右。复习过程大体与之前相似，不再赘述。其中最大的区别就是对于口语的复习不再那么消极了，可参考复习经验部分。</p>
<p>第一天坐火车到开封北站，然后一路公交到达开封大学对面的一个小区，我定的民宿就在这个小区里。
在公交上的一路感觉城市道路宽敞干净，猜想可能是因为经过的是新区，在规划上自然更现代化一些。
到了小区之后才发现，小区进门的两排低矮小楼全是各式各样的民宿，我就住在进小区门右手边的那栋。价格挺便宜，好像只要七十多一晚。
对于条件我没有太多要求，只希望晚上能够休息好，不吵就行。整体结果还算是符合期望，除了直到九点多才逐渐平息的挖掘机施工的声音。
看起来这好像是一个比较新的小区，边边角角有一些未竟的施工处。</p>
<p>下午到了之后，现在房间待了会，在地图上看了下周围的商铺，就准备出去找点吃的。出门走了大概四五百米的样子，有一排店铺，拐角处是一间超市，其他都是些饭馆什么的。
徘徊片刻，最终选定了附近的小馆子，点了份羊肉烩面，毕竟好久没吃到了。
进门的时候，店里只有一个十四五岁的小兄弟，体态壮硕，穿着校服，书包放在桌子一边，边看手机边吃饺子，颇有气势。
心想这小兄弟可比我在这个年龄胆子大多了，我在他这个年龄，几乎都没有出过门，如果没有人带着或跟人一块，可能都不敢进馆子里吃东西。</p>
<p>不一会，烩面上来，没有我记忆中那么好吃，不过也还行。正吃着面，那小兄弟突然说了句 “这 JB 饺子，dao 一个烂一个，不吃了”。
给我上面的中年男人出来，说 “这别问我，得问你妈去”，然后端着盘子回了后厨。
此时的我心想，他们仅寥寥说了两句话，他们的关系，甚至性格已经昭然若揭。不禁感慨，语言真是博大精深。
然后又想起来，当我叙述一件事的时候总是啰啰嗦嗦、没完没了，其实很多时候完全可以用很精炼的语言描述。进而觉得学习之路漫长。</p>
<p>第二天考试，早上很早就睡不着了，然后在房间里也等不住，就匆匆吃了点面包赶去考场了。
因为是周三的考试，进门的时候门卫还纳闷了一些有没有考试，待得到同伴的确认，才查了核酸、准考证等信息，让进了考场。
在进楼的时候还赶上了学生在进教室，颇为热闹。考场在最高层六层，待上去之后，发现门还没开，就在楼道里和其他赶到的同学站着等待。
随后进了考场，过程大概与西安那次相同。但感觉似乎不如上次专业，因为有的监考老师甚至还在用河南方言交流。
但后来我觉得我得为我这个草率的结论道歉。</p>
<p>整个过程监考老师都非常友好，并且甚至在考试之前还会给我们将考试流程。虽然我认为任何一个来考试的人并且备考过的人都应该对这套流程颇为熟悉，但还是很感谢监考老师耐心的介绍。
他甚至还鼓励我们不要紧张、发挥出自己的实力就行。感觉还是颇为认真负责的。</p>
<p>等到我进了考场之后，发现这简直跟我上次考试的地方完全不同啊。显而易见的就是隔板高了很多，目测至少有一米五的高度，完全不用担心别人的走动扰乱注意力。
其次是座位之间的间隔要宽敞得多，这也就意味着口语的干扰也会小很多，考试的时候发现也确实如此。</p>
<p>考试的时候同样是非常紧张，不知为何，觉得自己完全无法进入到专心答题的状态。阅读有一道做过的原题，好像是恐龙灭绝。
即使如此，阅读还是没剩太多时间，以至于觉得自己做的颇为仓促。
幸运的是，听力也有一道原题，关于巴黎铁塔那道，虽然无法记住原题，但是因为听过很多次，大概记得在讲什么，这已经非常有帮助了。
这次听力加试，我怀疑第一个 Section 就是加试题目，因为我感觉第一个 Section 我完全没听懂。而从后来的分数来看，如果不是加试的话完全考不到那个分。
而且还有另外一个原因，就是我在听第一个 Section 的间隙回头看了一个同学的屏幕，他的听力内容跟我不一样，我就知道这大概率是加试了。</p>
<p>这次给我感觉改变最大的就是口语考试，考试的时候我居然靠着背的素材很流利地答完了第一题，这给后面的考试打下了很好的信心基础。虽然后面的题也还是答得磕磕绊绊 😂 。
但是对于作文，我反倒觉得考的不是特别行。</p>
<p>终于打完了所有的题，考试结束！怀着忐忑的心情，我点了一个又一个按钮，直到分数突然出现在我的眼前 Reading 29 Listening 28 ，哇！那时的我欣喜若狂，感觉所有的努力都没有白费。
终于走出了那么多天的阴霾，仿佛如获新生。这种感觉我当时考研的时候仿佛也有过。</p>
<p>考完试之后，心情愉悦，感觉浑身是劲，于是动力十足地背起行囊，准备利用火车出发之前的这几个小时看看这个历史悠久且带给我幸运的城市。
其实来开封最想看的是开封铁塔，但是距离稍微有点远，并且清明上河园等景区就在附近，于是就决定挑这些比较近的地方打发完这几个小时。
最近看到一个新闻，河南的”所有“景区免门票一个月，现在恰好在免门票范围内。那么好的白嫖机会可不能浪费，想到这里，不觉又加快脚步。</p>
<p>因为距离不远，大概不到两公里的样子，所以准备直接步行过去，我戴上耳机，步伐轻快，不一会就到了清明上河园门口。
但我所到的大门没开，问了一个清洁阿姨，她给我指了另外一个门，距离也就一两百米的样子。到了门口，看大牌子写着票价 120，并且排队买票的人络绎不绝。
心想不是免费吗？于是又查了下，原来有个免费景点名单，清明上河园不在其中，且是河南唯二之一不免费的五星级景点，另一个是少林寺。</p>
<p>进不进去呢？一方面想来都来了，不能因为不免费就不去吧；另一方面又想，那么贵的门票，也看不了一会就要走，很亏。最终选择了后者，还有一个原因是附近有好几处公园，没必要在这棵树上吊死，去其他地方溜达溜达吧。
附近果然景色不错，即使没有进到具体某个公园里面，但在河边溜达，就已经让人心旷神怡了。可能因为是工作日，且不是河边各色酒吧的营业时间，所以河边几乎空无一人。</p>
<p><figure><a class="lightgallery" href="https://s2.loli.net/2021/12/27/xZjkEPtIYeG8HqQ.jpg" title="开封" data-thumbnail="https://s2.loli.net/2021/12/27/xZjkEPtIYeG8HqQ.jpg" data-sub-html="<h2>开封</h2><p>开封</p>">
        
    </a><figcaption class="image-caption">开封</figcaption>
    </figure></p>
<p>走了好长时间，稍微有点累，于是随便找了个河边的大石头坐下来休息，并随手拍了张照。在一个温度适中、天气晴朗的午后，悠闲地坐在河边欣赏景色，好不惬意。稍微休息了会，开始继续溜达。
附近大概有四五个公园，溜达了好几处，竟只有一处免费，好一个“所有景区免门票”啊。免费的那个公园是以文人字画为主题的公园，刚进公园，就赶上了一个话剧表演。
名为《羲之买鹅》，讲的内容大概是两个年轻书生想求得王羲之的真迹，见街上有一个大婶在卖鹅，所售之鹅体态俊美。
他们也知道王羲之非常喜欢鹅，于是就想了个主意，重金请大婶将鹅卖给王羲之，因为他们见到王羲之没有带很多钱，于是就让大婶把价钱开高一些，好让王羲之写个借条，以获得他的真迹。
最终计划成功，书生获得了王羲之真迹，大婶获得了丰厚的报酬，王羲之获得了自己喜欢的鹅，三全其美，很有意思。</p>
<p>又溜达了一会，感觉时间差不多了，并且也确实走累了，就决定赶往开封火车站了。看路边有共享电动车，且路途不算远，于是就扫码开了辆电单车，边观光边走，不一会就到了火车站，开封之行到这里也就结束了。</p>
<h2 id="总结">总结</h2>
<p>这次（暂且称为一次）考试虽说不是什么高考考研一类的大考，但中间过程曲折艰辛，使其足以成为我最为印象深刻的几次考试了。最后总结下这次考试的体会：</p>
<ul>
<li>不能逃避问题，就像我一直在逃避学习英语，但最终也逃不掉。</li>
<li>勇敢的迈出第一步，会发现有的问题可能并没有想象中那么无法完成。</li>
</ul>]]></description></item><item><title>Vim 学习记录</title><link>https://xinyu-yang.github.io/blog/2021/21-09-28_vim-learning/</link><pubDate>Tue, 28 Sep 2021 10:34:49 +0800</pubDate><author>作者</author><guid>https://xinyu-yang.github.io/blog/2021/21-09-28_vim-learning/</guid><description><![CDATA[<h2 id="介绍">介绍</h2>
<p>很久以来，一直想写一些关于 Vim 的使用博客。但是随着对 Vim 的了解加深，我意识到自己还达不到创作文章介绍Vim的能力。
一方面是因为自己对 Vim 的了解实在是有限，很多东西都只是鹦鹉学舌，了解简单的用法，而介绍这些基本用法的博客文章等浩如烟海，因此没有重复赘述的必要。
另一方面是因为随着学习的深入，我也接触到了很多优秀的博客文章，值得仔细研读。同时也意识到自己的水平跟这些文章的作者相去甚远，想要达到同等水平况且需要些时日，更不用说写出更有深度的东西了。</p>
<p>鉴于以上原因，我决定首先将我学习过程中所参考的优秀学习资料进行汇总和简介。如果初学者能看到本文，并因此在学习中少走些弯路，那便是本文的价值。
另外，我应该不会写偏向于大而全的 Vim 介绍博客，至少目前不会。但是我可能会写一些关于某些功能点的深入学习和记录的文章，我认为在当前网络中所能搜索到的文章中，这类更有价值。</p>
<p>目前本人主要使用的是 Vim ，但是目前 Neovim 似乎后来居上，大有取而代之之势，并且 github 上有很多优秀活跃的 Neovim 插件在开发。从长久趋势来看，新的东西总是基于已有设计，总结经验，克服弊端，并最终淘汰旧的。从传承上来看， Neovim 不过是对 Vim 的推倒重建式的重构，亦如当年 Vim 对于 Vi 编辑器的改良一般。</p>
<p>据称 Neovim 完全兼容 Vim 的功能和配置，并提供了额外的功能，从其风靡程度来看，我也相信这一点。但至少从目前来看，我还没有足够的理由和动机去使用它。也许还是缺少一个契机。这个契机就是遇到 Vim 无法或很难解决的痛点，并且 Neovim 可以很容易解决。而在这之前，则需要对 Vim 更加熟练的使用。</p>
<h2 id="综合教程">综合教程</h2>
<h3 id="入门教程-vimtutor">入门教程: Vimtutor</h3>
<p>Vimtutor 作为自带的官方教程，其作为入门教程的权威性自然不言而喻。当然，除了其明面上的地位之外，其作为一个入门教程，给初学者提供了一个很好的实际操作体验，该教程会提供一些例子供阅读者进行实际的操作，比起仅仅列举式的功能介绍，该导论还是挺容易被初学者接受的。
下面是截取的一部分例子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span><span class="lnt">22
</span><span class="lnt">23
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-vim" data-lang="vim"><span class="line"><span class="cl"><span class="p">~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>                     <span class="nx">Lesson</span> <span class="m">1</span>.<span class="m">3</span>: <span class="nx">TEXT</span> <span class="nx">EDITING</span> <span class="p">-</span> <span class="nx">DELETION</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>           ** <span class="nx">Press</span>  <span class="nx">x</span>  <span class="nx">to</span> <span class="nx">delete</span> <span class="nx">the</span> <span class="nx">character</span> <span class="nx">under</span> <span class="nx">the</span> <span class="nx">cursor</span>. **<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>  <span class="m">1</span>. <span class="nx">Move</span> <span class="nx">the</span> <span class="nx">cursor</span> <span class="nx">to</span> <span class="nx">the</span> <span class="nx">line</span> <span class="nx">below</span> <span class="nx">marked</span> <span class="p">---&gt;</span>.<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>  <span class="m">2</span>. <span class="nx">To</span> <span class="nx">fix</span> <span class="nx">the</span> <span class="nx">errors</span><span class="p">,</span> <span class="nx">move</span> <span class="nx">the</span> <span class="nx">cursor</span> <span class="nx">until</span> <span class="nx">it</span> <span class="nx">is</span> <span class="nx">on</span> <span class="nx">top</span> <span class="nx">of</span> <span class="nx">the</span><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>     <span class="nx">character</span> <span class="nx">to</span> <span class="nx">be</span> <span class="nx">deleted</span>.<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>  <span class="m">3</span>. <span class="nx">Press</span> <span class="nx">the</span>  <span class="nx">x</span>  <span class="nx">key</span> <span class="nx">to</span> <span class="nx">delete</span> <span class="nx">the</span> <span class="nx">unwanted</span> <span class="nx">character</span>.<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>  <span class="m">4</span>. <span class="nx">Repeat</span> <span class="nx">steps</span> <span class="m">2</span> <span class="nx">through</span> <span class="m">4</span> <span class="nx">until</span> <span class="nx">the</span> <span class="nx">sentence</span> <span class="nx">is</span> <span class="nx">correct</span>.<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="p">---&gt;</span> <span class="nx">The</span> <span class="nx">ccow</span> <span class="nx">jumpedd</span> <span class="nx">ovverr</span> <span class="nx">thhe</span> <span class="nx">mooon</span>.<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span>  <span class="m">5</span>. <span class="nx">Now</span> <span class="nx">that</span> <span class="nx">the</span> <span class="nx">line</span> <span class="nx">is</span> <span class="nx">correct</span><span class="p">,</span> <span class="nx">go</span> <span class="nx">on</span> <span class="nx">to</span> <span class="nx">lesson</span> <span class="m">1</span>.<span class="m">4</span>.<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="nx">NOTE</span>: <span class="nx">As</span> <span class="nx">you</span> <span class="nx">go</span> <span class="nx">through</span> <span class="nx">this</span> <span class="nx">tutor</span><span class="p">,</span> <span class="nx">do</span> <span class="nx">not</span> <span class="nx">try</span> <span class="nx">to</span> <span class="nx">memorize</span><span class="p">,</span> <span class="nx">learn</span> <span class="nx">by</span> <span class="nx">usage</span>.<span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err">
</span></span></span><span class="line"><span class="cl"><span class="err"></span><span class="p">~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~</span><span class="err">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>整篇教程不长，一小时之内就能读完，然后就能够对平时经常用到的绝大部分功能有一个大概的认识。如果想要熟练掌握，还是要勤加练习，并且强迫自己用不同的方式实现某一功能。</p>
<p>该教程是随Vim一块安装的，打开方式很简单，只需在终端敲入<code>vimtutor</code>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ vimtutor
</span></span></code></pre></td></tr></table>
</div>
</div><p>如果想打开中文版（对，居然自带中文版😃），可以使用<code>vimtutor zh_cn</code>命令。
当然，该文档也可以从Vim中打开，在<code>normal</code>模式敲入：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-vim" data-lang="vim"><span class="line"><span class="cl"><span class="p">:</span><span class="nx">e</span> $<span class="nx">VIMRUNTIME</span><span class="sr">/vim/</span><span class="nx">tutor</span>/<span class="nx">tutor</span>.<span class="nx">zh_cn</span>.<span class="nx">utf</span><span class="m">-8</span><span class="err">
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>不过还是推荐使用<code>vimtutor</code>进行打开，因为在使用该命令时，<code>Vim</code>会自动把原文档复制一份成临时文件然后打开。因此，对通过该方式打开的文档进行操作不会改变原文档。这样使用者就可以放心操作了。</p>
<h3 id="其他入门教程">其他入门教程</h3>
<h4 id="简明vim练级攻略httpscoolshellcnarticles5426html"><a href="https://coolshell.cn/articles/5426.html" target="_blank" rel="noopener noreferrer">简明Vim练级攻略</a></h4>
<p>这是一篇11年的教程，虽然时间稍早，但是排版易读，语言诙谐，并且加入了很多图片和动图，对读者比较友好。目前该文已有超多120万的阅读量👍。
这篇教程整体内容跟Vimtutor差不多，可以看成是Vimtutor的补充，读完Vimtutor之后可以读下这篇，跟着操作一遍，可以起到复习的效果。</p>
<h4 id="vim实操教程httpswwwbookstackcnreadlearn-vimreadmemd"><a href="https://www.bookstack.cn/read/learn-vim/README.md" target="_blank" rel="noopener noreferrer">Vim实操教程</a></h4>
<p>文如其名，这同样是一份注重实际操作的教程，整体内容也跟上两个文档差不多，可以作为补充一块阅读。
该教程的优点是排版较好，有着类似于书籍的章节排版，逻辑清晰。而且相对上两篇而言，比较新一些，同时有一些关于插件的简单介绍。</p>
<h4 id="每日一vimhttpsliuzhijuniteyecomcategory270228"><a href="https://liuzhijun.iteye.com/category/270228" target="_blank" rel="noopener noreferrer">每日一vim</a></h4>
<p>这是一个教程系列，共计30篇，每篇介绍一个功能，篇幅较短，阅读的时候不会有心里负担，当然对于功能的介绍也是浅尝辄止，读者可以根据需要有选择性的阅读。</p>
<h3 id="高级进阶vim从入门到精通vim-galore-zh_cnhttpsgithubcomwsdjegvim-galore-zh_cn">高级进阶：<a href="https://github.com/wsdjeg/vim-galore-zh_cn" target="_blank" rel="noopener noreferrer">Vim从入门到精通（vim-galore-zh_cn）</a></h3>
<p>当搜索Vim的学习教程时，很多人都推荐《Vim galore》，这篇文章就是其中文翻译。虽然中文翻译有点俗套的编程语言教程内味，但是并不影响这是一篇很好的Vim教程。</p>
<p>该仓库下就链接了其他语言的版本，英文好的可以读英文原版，不太好的可以读中文，并且该教程还有日语、西班牙语和俄语选项，都是开源社区贡献的，这也从侧面印证了该教程的牛x。</p>
<p>相对于上面所提到的入门教程，该文章提供了更加深入的介绍，但同时也不那么容易阅读，需要反复咀嚼才能将其学透。
我在第一次看该教程的时候，已经读了上面那些教程，并且有了一段时间的Vim使用经验，但是还是有很多地方读不懂和不理解。后来慢慢的对于里面的内容有了认识（比如那么多的寄存器），但是还是有些不太懂。
所以建议初学者可以先不要读此教程，待有了一定的基础之后再来阅读，当然该教程也需要反复复习。越是经典的教程越是值得我们反复咀嚼，并且每次阅读都会有新的收获。</p>
<h3 id="高级进阶vim学习笔记httpsyyq123githubiolearn-vim">高级进阶：<a href="https://yyq123.github.io/learn-vim/" target="_blank" rel="noopener noreferrer">Vim学习笔记</a></h3>
<p>这是一个颇为低调的学习笔记，如果不是偶然看到，可能很难搜索到该教程，该教程所对应的github博客主页甚至都是空白的。据作者称，这是他从一本书整理而来。
经过简单浏览我发现这本书还是不错的，介绍深入浅出，不会只简单介绍基本操作，而是对Vim有较为高级的介绍。
博客内容很丰富，感觉有时间可以学习学习。</p>
<h2 id="插件">插件</h2>
<h3 id="配置教程">配置教程</h3>
<h4 id="所需即所获像-ide-一样使用-vimhttpsgithubcomyangyangwithgnuuse_vim_as_ide"><a href="https://github.com/yangyangwithgnu/use_vim_as_ide" target="_blank" rel="noopener noreferrer">所需即所获：像 IDE 一样使用 vim</a></h4>
<p>这是我阅读的第一篇关于Vim插件配置的文章，主要是我在搜索关于Vim配置的文章的时候，这篇文章高居搜索引擎榜首。虽然已经五年没有更新了，但仍然在github上有9k Star。
这是我读到并且跟着操作的第一篇关于插件配置的博客，该博客涉及的内容很多，以至于很难短时间内搞明白所有的内容，事实上我到现在还搞不明白有些插件的用处。因此需要在实际操作中逐渐摸索。
因为时间原因，文中有些插件早已经被开发者放弃或者被其他的插件所代替。因为不同的人需求也不尽相同，所以有很多文中列举的插件其他使用者可能会觉得根本没有必要。</p>
<p>考虑到以上原因，我采用的方法是首先将所有的配置文件直接拷贝下来，然后逐渐学习和摸索每个插件的用处，然后增删改查，最后打造属于自己的配置。
直接使用现成配置的好处是增加学习过程中的收获感，因为配置完成之后直接就可以看到最终的效果，虽然这个阶段对每一个功能都一脸茫然，但是仍然可以增加自己的成就感。而如果从头开始摸索的话，则可能因为工作量太大并且久久看不到自己想要的效果而丧失学习乐趣。</p>
<p>逐渐摸索下来之后便可对插件进行逐一学习和探索，并且你会逐渐发现这项工作深不见底。因为从对已有插件简单的使用到掌握复杂的配置已经是一个颇为困难的过程，更不用说你甚至可以直接写自己所需的插件。真是学海无涯啊~</p>
<p>这里同样推荐一些成熟配置以供参考，当然关于Vim的配置在网上一搜一大堆，在github的topics中也能找到很多高star<a href="https://github.com/topics/vimrc" target="_blank" rel="noopener noreferrer">仓库</a>，以下是摘录的几个：</p>
<h4 id="spacevimhttpsspacevimorg"><a href="https://spacevim.org/" target="_blank" rel="noopener noreferrer">SpaceVim</a></h4>
<p>该项目也许是最有名的Vim配置，在github的<code>vimrc</code>话题中高居榜首，其甚至有<a href="https://spacevim.org/cn/" target="_blank" rel="noopener noreferrer">中文文档</a>（后来才知道该项目原来就是由国人发起的👍）。官网称自己为Vim发布（Vim distribution），感觉就像BSD是作为Linux操作系统的一个发布一样。该发布非常成熟，当然也比较复杂。
我没用过，但是感觉入门成本应该比较低，按照成熟的官方文档进行配置应该没啥问题。因此该配置对于想直接使用Vim配置完全体的用户来说比较友好。</p>
<p>但是我本人没有用该配置的原因也是如此，该配置太成熟和复杂了，以至于很难入手去学习。对我自己而言，一个简易配置，并且容易上手鼓捣的版本才比较适合我。
因为这样可以很好的折中使用体验和入门成本，这也是我选择上述文章学习的原因。</p>
<p>另外要说的一点，当自己逐渐熟悉Vim的配置流程之后，会发现SpaceVim的源码是一个很好的学习材料。</p>
<h4 id="k-vimhttpsgithubcomwklkenk-vim"><a href="https://github.com/wklken/k-vim" target="_blank" rel="noopener noreferrer">k-vim</a></h4>
<p>该配置在github上也有高star，并且作者是国人。该配置的说明文档不是特别详细，但是问题不大，因为该配置并不是特别复杂，并且在配置文件中有很好的注释。虽然感觉项目稍老，而且开发也不是特别活跃，但是是一个很好的入门和学习素材。</p>
<p>另外作者还开发了一个简化版的<a href="https://github.com/wklken/vim-for-server" target="_blank" rel="noopener noreferrer">vim-for-server</a>版本，用于不太方便安装插件的场景，对我很有启发，我决定也要搞这么一个东西。</p>
<h4 id="myvimhttpsgithubcomxinyu-yangmyvim"><a href="https://github.com/xinyu-yang/myvim" target="_blank" rel="noopener noreferrer">myvim</a></h4>
<p>最后允许我厚颜无耻的放上我自己的Vim配置，这是我自己摸索的一个配置，虽然简单，但是暂时够用，同时我也会不断的摸索和完善该配置。</p>
<p>在某博客上读到一句话，感觉比较赞同，大概意思是<strong>应该将Vim打造成适合自己的方式，而不是自己去适应已有的配置</strong>。这也可能也是大多数人一直乐此不疲折腾的原因吧。
所以以上参考都只是参考和学习资料，毕竟什么配置最合适只有自己知道。</p>
<h3 id="插件推荐">插件推荐</h3>
<p>关于插件的推荐，网上同样有很多相关的教程。同时，也可以经常看<a href="https://vimawesome.com/" target="_blank" rel="noopener noreferrer">vimawesome 网站</a>。这个网站有很多流行的插件推荐，可以根据自己的需要进行摸索，
这里我根据自己的使用情况介绍几个个人感觉比较重要的：</p>
<p>我认为首先需要做的是一些美化工作，这包括找一个合适的主题，还有漂亮的状态显示工具。
当然，在最开始之前，最好安装一个插件管理程序，以便于管理。</p>
<p>关于这方面的插件有几个不错的，其中包括<code>Vundle</code>, <code>vim-plug</code>, <code>dein</code>。这几个插件的评分都挺高的，而且功能也相近。</p>
<p>其中<a href="https://github.com/VundleVim/Vundle.vim" target="_blank" rel="noopener noreferrer">Vundle</a>是一个比较老的插件，同时可能也是最流行的一个。
目前对我来说，该插件完全够用。因为我只是需要一个能自动安装插件的这么一个管理器，而且我平时用的插件也不算多，所以对性能等要求也不算特别高。</p>
<p>但遗憾的是<code>Vundle</code>插件似乎已经停止开发了，但是其他的两个插件仍处在活跃开发中。其中<a href="https://github.com/junegunn/vim-plug" target="_blank" rel="noopener noreferrer">vim-plug</a>是我看到的被推荐次数最多的替代品，安装该插件只需要下载一个名为<code>plug.vim</code>的文件。该插件支持一些新的功能，比如可以指定版本和标签，以及设置插件加载的时间。</p>
<p>也许等我安装的插件比较多，需要这么一个懒加载插件管理器来提升速度，或者想要尝试一下新的功能的时候，我会试着学习下该插件，但目前似乎还不是时候。</p>
<p><code>dein</code>的功能不是特别了解，但感觉应该会跟<code>vim-plug</code>差不多。这三个插件选择一个即可。</p>
<p>另外，本人最近又读到了一些文章，提倡尽量简化配置，尽量多用vim自带的功能来代替那些可有可无的插件，即 <strong>“如非必要，勿增实体”</strong> 。而据说<code>vim 8.0</code>之后的版本自带插件的管理功能，关于这点，留待以后学习研究。目前还是用些易用的管理插件比较好，这同样也是基于折腾成本与获得感的考虑。</p>
<p><figure><a class="lightgallery" href="https://i.loli.net/2021/11/22/wNt5PvpkadhErHq.png" title="vim screenshot" data-thumbnail="https://i.loli.net/2021/11/22/wNt5PvpkadhErHq.png" data-sub-html="<h2>Vim 截图</h2><p>vim screenshot</p>">
        
    </a><figcaption class="image-caption">Vim 截图</figcaption>
    </figure></p>
<p>下面开始推荐我认为有必要安装的插件：</p>
<h4 id="gruvbox-主题"><code>gruvbox</code> 主题</h4>
<p>对于一个编辑器来说，好用自然是第一要素，但是颜值也是不可或缺的重要因素。漂亮的界面让人看起来心情愉悦，只有这样才能写出好的程序（或者任何东西）。
关于颜值，那么就不得不说主题了，一个主题相当于一个人的穿着，决定着整体形象。</p>
<p>我选择了比较流行，但更重要的是自己比较喜欢的 <a href="https://github.com/morhetz/gruvbox" target="_blank" rel="noopener noreferrer">gruvbox</a> 主题。我感觉该主题看起来比较舒服，而这个结论是我经过多个主题的实际安装对比得出来的，可能会有其他更漂亮和科学的主题，但是目前我选择了这个我已经比较满意的。
该主题的整体配色如上图所示。</p>
<p>同时我建议大家在选择自己的主题之前，一定要自己多多对比，然后选择自己看起来比较舒服的主题。这个就像买衣服一样，合不合适只有自己知道。（发现上面举得穿着的例子还挺合适😂）</p>
<h4 id="vim-airline-状态栏"><code>vim-airline</code> 状态栏</h4>
<p>如果说主题是编辑器的穿着的话，那么 <a href="https://github.com/vim-airline/vim-airline" target="_blank" rel="noopener noreferrer">vim-airline</a> 就像是装饰品，可以起到画龙点睛的作用。
即使不从美观角度来考虑，通过将自己经常需要敲命令查看的东西放在我们易于看到的地方，也会给效率带来巨大的提升。
而该插件可能就是目前这方面做的最好的一个。</p>
<p>该插件目前仍然在不断开发和维护当中，该插件不仅提供底部状态栏（上图 A2 部分），而且还有顶部标签栏（上图 A1 部分所示），并且提供了很多选项供使用者进行配置。当然，对于不需要深度定制的用户，简单使用默认配置即可。我就曾经在这个插件上花了很长的时间，几乎阅读了所有的文档。当最终结果还是很好的，正是有了这个插件，我才真正看到了现代编辑器应该有的样子。</p>
<p>另外，主题和状态栏的兼容还是挺重要的，幸运的是目前我用的主题和该插件是兼容的。
事实上，稍微成熟些的主题一般都会选择跟该插件进行兼容，毕竟这个插件几乎是这方面的标杆。</p>
<h4 id="tagbar-概要"><code>tagbar</code> 概要</h4>
<p>该插件主要提供文件的概览，就是代码的目录，可以浏览和跳转。就像 VS Code 中的 outline 那样，当然基本上所有的 IDE 都提供类似的功能。而 Vim 中该功能就由 tagbar 来实现。
但是仅靠 tagbar 还不够，还需要另外一个工具的支持，该工具就是 ctags，虽然我们在 Vim 中看不到它的体现，但是 ctags 非常重要，事实上很多插件和功能都要基于它来做。
比如 Vim 中自带的 <code>]</code> 命令 C 语言函数跳转功能。</p>
<p>关于 tagbar 我并没有过多的进行配置，直接把别人的配置拿过来，能显示就行了，研究过多花里胡哨的功能即浪费时间也没必要。该插件的使用效果如上图中的 B 区域所示。</p>
<h4 id="nerdtree-文件导航"><code>NERDTree</code> 文件导航</h4>
<p>该插件是 vimawesome 上最流行的插件之一，github 上的 star 也很多。但是后来我感觉没啥用，更重要的是能够找到很好的替代品，所以就卸载了该插件。
该插件主要提供的功能是文件导航（参考截图区域 C ），类似于 VS CODE 等编辑器的文件导航，这几乎也是成熟编辑器或 IDE 的标配功能。
当需要打开新的文件的时候，尤其是同目录下的文件，比较简单。
目前我所使用的是 Vim 自带的 Netrw 插件（即上图区域 C 所示）。</p>
<h4 id="youcompleteme-自动补全"><code>YouCompleteme</code> 自动补全</h4>
<p>第一次使用该插件是在写 C 语言程序的时候，该插件提供了与成熟 IDE 类似的强大补全功能，并且可以实现基于语义的跳转功能，这一点比仅支持标签匹配的 ctags 跳转要更加强大。
上图中 E 区域展示了当光标停到某个函数上时，该函数的一些信息会自动弹出来。
毫不夸张，使用该插件可以将 Vim 的生产力真正提高到一个新的台阶，让人不免感叹这才是编辑器该有的样子。</p>
<p>但是该插件存在一个非常致命的问题：很难安装</p>
<p>这主要体现在两方面，首先是依赖非常多，而且对很多软件的依赖精确到版本。另外一个问题是，如果没有科学上网的话，在编译的时候有些包会下载失败。</p>
<h4 id="ultisnip-代码段补全"><code>UltiSnip</code> 代码段补全</h4>
<h4 id="ctags-标签生成"><code>Ctags</code> 标签生成</h4>
<h4 id="lf-导航"><code>lf</code> 导航</h4>]]></description></item><item><title>可同步图床配置——PicGo+Github/Gitlab+Onedrive</title><link>https://xinyu-yang.github.io/blog/2021/21-09-09_picture-bed/</link><pubDate>Thu, 09 Sep 2021 11:05:02 +0800</pubDate><author>作者</author><guid>https://xinyu-yang.github.io/blog/2021/21-09-09_picture-bed/</guid><description><![CDATA[<h2 id="介绍">介绍</h2>
<p>本文主要用来记录图床的搭建过程，在写博客的过程中不可避免的可能会用到一些图片，因此图片的保存位置就成了一个需要思考的问题，这个问题在使用博客网站 CSDN、博客园等是不存在的，因为在使用这些网站时，只需要把图片传上去就行，图片会自行保存在这些平台所提供的图床上。曾经尝试着在本博客里直接引用博客园和 CSDN 中的图片，不出意外，果然加载不出来，可能是因为这些网站在处理请求的时候会检查<code>Referer</code>字段吧，如果仅是这种检查的话似乎可以避开，但是终究不是长久之计。</p>
<p>一开始惊喜的发现有很多的免费图床网站（比如imgbb），开心的以为这个问题解决了，后来发现没那么简单。因为这些免费的图床往往有很多限制，比如上面举例说的这个imgbb，该网站一开始用着还行，可是过几天再在博客里加载图片时只能加载出缩略图了。</p>
<p>因此就又在网上搜索解决之道，经琢磨了多篇解决方案之后，决定选择可能目前最合适的方案：使用 PicGo 作为图床管理软件，Gitee、SM.MS 等作为存储平台，并且使用 Onedrive 来同步 PicGo 的配置文件和数据库（这是<code>PicGo 2.3</code>版本以来的新功能👏），以实现备份和同步。接下来将就该方案进行介绍：</p>
<h2 id="申请-gitee-账号创建仓库">申请 Gitee 账号，创建仓库</h2>
<div class="details admonition info open">
        <div class="details-summary admonition-title">
            <i class="icon fas fa-info-circle fa-fw"></i>Gitee is Dead (May. 2022)<i class="details-icon fas fa-angle-right fa-fw"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content"><p>Gitee 已经不允许做图床了，可以切换到 Github 和 Gitlab。</p>
<blockquote>
<p>当前仓库 Web 页面仅限仓库成员可访问。如需转为公开仓库，需 点此绑定手机 后通过仓库设置提交公开申请，我们将尽快为您处理。</p>
<p>&ndash; 上述通知来自 Gitee</p>
</blockquote>
</div>
        </div>
    </div>
<p>因为 Gitee 是国内的网站，加载较快，另外就是还没有使用 Gitee 托管代码的打算，所以不如注册个账号专门用来托管图片，综合以上原因，最终使用了 Gitee。但是 Gitee 也有很多缺点，缺点之一就是空间太小了（这里不得不吐槽一句，本来就是模仿者，又那么小气，没有任何优势，难怪没人用啊~）。</p>
<p>如果没有 Gitee 账号的话，就去申请一个。账号申请就按照步骤来就行，没什么可说的。我申请的时候发现我在 github 上使用的 ID 居然还没被别人占用，就果断申请了该 ID，在 Github、Gitlab 和 Gitee 上做到了统一。</p>
<p>申请完账号后，登录，然后进入个人信息界面，随后点击左侧栏中的仓库空间管理，随后右上角会出现“新建仓库”的按钮。此时就可以新建仓库了，取名随意，但仓库必须得是公有的。</p>
<p>然后下一步是创建私人令牌，以保证 PicGo 可以控制该仓库。同样在个人设置界面的左侧“安全设置”栏下有一个“私人令牌”选项，找到并点击。然后点击右上角的生成新令牌，填写描述信息，然后选择权限，我只选择了前三个权限——<code>user_info, projects, pull_requests</code>。
我感觉这些应该就够了，最后点击提交，然后会生成一个 token ，暂时用记事本等保存该 token ，因为它不会再次出现。</p>
<h2 id="picgo-端配置">PicGo 端配置</h2>
<p>生成并保存完 token 之后，就可以进行 PicGo 端配置了。因为该软件不默认支持 Gitee 图床，所以只能通过安装插件来支持，在插件设置的搜索栏里搜索 gitee-uploader，然后点击安装。安装完之后点击插件图标右下角的设置按钮，找到“配置uploader-gitee”，点击之后会出现一个界面，主要会出现以下几条待填信息：</p>
<ul>
<li>repo      (就是刚才所创建的仓库，不过这里的格式是<code><sup>your id</sup>/<sub>repo name</sub></code>，前面的<code>gitee.com</code>就不要填了)</li>
<li>branch    (一般为master)</li>
<li>token     (这就是刚才所保存的token)</li>
<li>path      (文件的保存路径，可以自行设置，我的设置是“img/$customPath”)</li>
<li>customPath    (这就是path设置里的那个参数，我选的“年”)</li>
<li>customUrl (没填)</li>
</ul>
<p>到这里，差不多就配置好了，可以随便上传一张图片试试能不能用，我这里上传了一张蜗壳的照片。
下图是Gitee示例：</p>
<p><figure><a class="lightgallery" href="https://raw.githubusercontent.com/xinyu-yang/imgs/master/imgs/Kobe.jpg" title="测试" data-thumbnail="https://raw.githubusercontent.com/xinyu-yang/imgs/master/imgs/Kobe.jpg" data-sub-html="<h2>测试图片</h2><p>测试</p>">
        
    </a><figcaption class="image-caption">测试图片</figcaption>
    </figure></p>
<h2 id="onedrive同步配置">Onedrive同步配置</h2>
<p>PicGo是一个很棒的工具，但是之前有一个很大的问题就是没有办法进行不同主机之间的同步。这就导致在一台主机上上传过的图片只在该电脑保存有记录，其他电脑是找不到的。当然，这可以通过直接去图床网站上找链接，或者是在电脑之间复制PicGo的配置文件来解决。
但是这些解决方案都太麻烦了，而我又是一个比较懒的人。</p>
<p>目前最新的PicGo 2.3.0 仍然不能解决该问题(事实上让一个开源软件作者来搭建服务器并提供同步功能确实有点苛刻)，但是该版本提供了自定义配置文件路径的功能，为解决同步问题提供了可能。
我所采用的方案是将PicGo的配置文件所在的文件夹使用第三方云同步平台进行同步，这样就实现了同步功能。</p>
<p>可行的同步平台有很多，如 Onedrive、Dropbox、Google Drive、seafile (如果有的话)等。甚至 Baidu 云盘好像最近也免费提供了类似的服务“同步空间”，虽然每月只有1G的免费流量，但总比没有强。</p>
<blockquote>
<p>说到这里岔个题，我一直感觉用户对百度网盘的要求过于苛刻了，对于一样免费的产品，百度云盘是唯一一个能够为我提供2T免费存储空间的平台，这一点迄今还找不到替代者。至于很多用户一直以来报怨的下载速度慢的问题，我只想说反正都是白嫖的，还要啥自行车。从我自己的使用角度来讲，平时用百度网盘保存同步或者是备份一些不经常用的文件，如照片、打包的文档资料等，还是挺好的。</p>
</blockquote>
<p>书归正传，首先找到一个适合自己的同步工具，我使用的是 Onedrive，其同步文件夹为<code>D:\Onedrive\</code>，如果想改变 PicGo 的默认配置路径，则需要首先打开配置文件，然后加入这么一行配置信息：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">&#34;configPath&#34;: &#34;D:\\Onedrive\\ApplicationData\\picgo\\data.json&#34;,
</span></span><span class="line"><span class="cl">  &#34;picBed&#34;: {
</span></span></code></pre></td></tr></table>
</div>
</div><p>这是我自己的配置，个人根据情况不同进行修改，另外根据官方建议，可以手动将<code>data.json, pigco.db</code>文件复制到自己的自定义文件夹内。</p>
<h2 id="总结">总结</h2>
<p>到这里就完成了配置和自动同步配置，当然也可以添加一些其他的免费图床<code>SM.MS, Superbed</code>等图床作为备份，我也确实是这么做的。</p>
<p>最后不得不说一下，感觉 PicGo 真的是开源代码的典范，自己提供一个框架和一套接口，其他人可以按照接口开发各种各样的代码。我感觉对于实用性的工具应用，这种开发方式非常合适。
功能强大，但不臃肿，用户有足够多的定制选择权。</p>]]></description></item></channel></rss>