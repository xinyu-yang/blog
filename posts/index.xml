<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>所有文章 - 麋鹿博客 (Elk blog) | 一个分享知识和乐趣的地方</title><link>https://xinyu-yang.github.io/blog/posts/</link><description>所有文章 | 麋鹿博客 (Elk blog) | 一个分享知识和乐趣的地方</description><generator>Hugo -- gohugo.io</generator><language>zh-CN</language><managingEditor>yangxinyu75@qq.com (Xinyu Yang)</managingEditor><webMaster>yangxinyu75@qq.com (Xinyu Yang)</webMaster><copyright>This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.</copyright><lastBuildDate>Mon, 13 Feb 2023 12:37:39 +0800</lastBuildDate><atom:link href="https://xinyu-yang.github.io/blog/posts/" rel="self" type="application/rss+xml"/><item><title>网络参数RSS、RPS、RFS、aRFS 学习总结</title><link>https://xinyu-yang.github.io/blog/2023/23-02-13_network-parameters/</link><pubDate>Mon, 13 Feb 2023 12:37:39 +0800</pubDate><author>作者</author><guid>https://xinyu-yang.github.io/blog/2023/23-02-13_network-parameters/</guid><description><![CDATA[<p>最近学习，发现网络参数（包括内核参数、网卡参数）非常多，搞得人云里雾里，非常头大。因此打算在这里对学习到的东西做个总结，方便知识的梳理和以后的复习。</p>
<h2 id="receive-side-scaling-rss">Receive Side Scaling (RSS)</h2>
<p>RSS 是一个 Linux 网络协议栈中的调度机制。它的主要作用是将数据包路由到不同的接收队列，进而由该队列所对应的 CPU 进行处理，从而实现对数据包处理的负载均衡。</p>
<p>在硬件上，通常使用 <code>hash</code> 函数（一般是 <a href="https://en.wikipedia.org/wiki/Toeplitz_Hash_Algorithm" target="_blank" rel="noopener noreferrer">Toeplitz hash</a>）和长度为 <code>128 (2^7)</code> 的置换表来实现。具体做法是，首先将网络和传输层头部的一些信息（如地址端口四元组）通过 <code>hash</code> 函数计算出一个 <code>hash</code> 值，然后取该 <code>hash</code> 值的后 <code>7</code> 位。将这 <code>7</code> 位数作为索引，在置换表中寻找相应的值，该值即为相应的队列。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">[hash value] : [queue number]
</span></span><span class="line"><span class="cl">...
</span></span></code></pre></td></tr></table>
</div>
</div><p>网卡的置换表可以通过命令 <code>ethtool --show-rxfh-indir &lt;eth0&gt;</code> 来获取，例子如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span><span class="lnt">17
</span><span class="lnt">18
</span><span class="lnt">19
</span><span class="lnt">20
</span><span class="lnt">21
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">RX flow hash indirection table for eth0 with 4 RX ring(s):
</span></span><span class="line"><span class="cl">    0:      0     0     0     0     0     0     0     0
</span></span><span class="line"><span class="cl">    8:      0     0     0     0     0     0     0     0
</span></span><span class="line"><span class="cl">   16:      0     0     0     0     0     0     0     0
</span></span><span class="line"><span class="cl">   24:      0     0     0     0     0     0     0     0
</span></span><span class="line"><span class="cl">   32:      1     1     1     1     1     1     1     1
</span></span><span class="line"><span class="cl">   40:      1     1     1     1     1     1     1     1
</span></span><span class="line"><span class="cl">   48:      1     1     1     1     1     1     1     1
</span></span><span class="line"><span class="cl">   56:      1     1     1     1     1     1     1     1
</span></span><span class="line"><span class="cl">   64:      2     2     2     2     2     2     2     2
</span></span><span class="line"><span class="cl">   72:      2     2     2     2     2     2     2     2
</span></span><span class="line"><span class="cl">   80:      2     2     2     2     2     2     2     2
</span></span><span class="line"><span class="cl">   88:      2     2     2     2     2     2     2     2
</span></span><span class="line"><span class="cl">   96:      3     3     3     3     3     3     3     3
</span></span><span class="line"><span class="cl">  104:      3     3     3     3     3     3     3     3
</span></span><span class="line"><span class="cl">  112:      3     3     3     3     3     3     3     3
</span></span><span class="line"><span class="cl">  120:      3     3     3     3     3     3     3     3
</span></span><span class="line"><span class="cl">RSS hash key:
</span></span><span class="line"><span class="cl">Operation not supported
</span></span><span class="line"><span class="cl">RSS hash function:
</span></span><span class="line"><span class="cl">    toeplitz: on
</span></span></code></pre></td></tr></table>
</div>
</div><p>可见一共有 <code>128</code> 条表项，完全均匀分配给了队列 <code>rx-0 → rx-3</code>。该表可通过命令 <code>ethtool —set-rxfh-indir</code> 进行配置。</p>
<p>上述机制实现了从数据包到队列的对应，为了真正实现负载均衡，我们还需要协调好从队列到 CPU 的对应关系。又因为每个队列对应一个中断(参考<a href="../22-02-13_binding-cpu-irq-queue" rel="">上一篇</a>)，所以我们可以通过中断号绑定的方式来实现队列和 CPU 的对应。关于此，请参考关于此，请参考 <a href="../22-02-13_binding-cpu-irq-queue" rel="">理解 CPU、中断、队列、进程的绑定关系 - 麋鹿博客 (Elk blog) | 一个分享知识和乐趣的地方</a> 。</p>
<p><figure><a class="lightgallery" href="https://3.bp.blogspot.com/-g_sS7Jf3vW0/WUEN0wEK5BI/AAAAAAAAA9g/PLy6crp9q74ia1xcWX8lwS7WzRz2xL-WwCLcBGAs/s1600/RSS.png" title="RSS" data-thumbnail="https://3.bp.blogspot.com/-g_sS7Jf3vW0/WUEN0wEK5BI/AAAAAAAAA9g/PLy6crp9q74ia1xcWX8lwS7WzRz2xL-WwCLcBGAs/s1600/RSS.png" data-sub-html="<h2>RSS</h2><p>RSS</p>">
        
    </a><figcaption class="image-caption">RSS</figcaption>
    </figure></p>
<blockquote>
<p>图片来源：<a href="https://garycplin.blogspot.com/2017/06/linux-network-scaling-receives-packets.html" target="_blank" rel="noopener noreferrer">Linux Network Scaling: Receiving Packets (garycplin.blogspot.com)</a></p>
</blockquote>
<div class="details admonition tip open">
        <div class="details-summary admonition-title">
            <i class="icon fas fa-lightbulb fa-fw"></i>技巧<i class="details-icon fas fa-angle-right fa-fw"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content"><p><a href="https://www.kernel.org/doc/html/latest/networking/scaling.html" target="_blank" rel="noopener noreferrer">该文档</a> 给出建议，想要实现低延时，应该配置 CPU 数量的队列（即每个 CPU 一个）。对此，笔者的理解是，如果队列数量少了，则可能会有 CPU 闲着，处理不够及时。队列数量多了也没用，因为 CPU 就那么多。</p>
<p>针对以高速率为目的的网络，文档建议使用尽可能少的队列，在这种配置下，不会出现接收队列因为一个 CPU 饱和而溢出的情况。因为在启用中断合并（如 <code>NAPI</code>）的情况下，队列越多，中断数越多。</p>
</div>
        </div>
    </div>
<h2 id="receive-packet-steering-rps">Receive Packet Steering (RPS)</h2>
<p>RPS 逻辑上是 RSS 的软件实现，但又不完全一样。RSS 可以为每个数据包选择接收队列，因此也就选择了相对应的执行中断处理的 CPU；而在 RPS 中，中断由默认队列触发，中断处理函数结束之后，选择进行后续协议处理的 CPU。</p>
<p><figure><a class="lightgallery" href="https://3.bp.blogspot.com/-zRdZ1Bw1frw/WUNdJCURkvI/AAAAAAAAA-Q/XgYiaHsBsNc9cWwAdZu83HhfOUtuSTCkgCLcBGAs/s640/RPS.png" title="RPS" data-thumbnail="https://3.bp.blogspot.com/-zRdZ1Bw1frw/WUNdJCURkvI/AAAAAAAAA-Q/XgYiaHsBsNc9cWwAdZu83HhfOUtuSTCkgCLcBGAs/s640/RPS.png" data-sub-html="<h2>RPS</h2><p>RPS</p>">
        
    </a><figcaption class="image-caption">RPS</figcaption>
    </figure></p>
<blockquote>
<p>图片来源：<a href="https://garycplin.blogspot.com/2017/06/linux-network-scaling-receives-packets.html" target="_blank" rel="noopener noreferrer">Linux Network Scaling: Receiving Packets (garycplin.blogspot.com)</a></p>
</blockquote>
<div class="details admonition quote open">
        <div class="details-summary admonition-title">
            <i class="icon fas fa-quote-right fa-fw"></i>引用<i class="details-icon fas fa-angle-right fa-fw"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content"><p>RPS 不会增加额外的硬件设备中断，但是引入了处理器间中断（IPI）。</p>
<p>— <a href="https://www.kernel.org/doc/html/latest/networking/scaling.html" target="_blank" rel="noopener noreferrer">Scaling in the Linux Networking Stack — The Linux Kernel documentation</a></p>
</div>
        </div>
    </div>
<p>RPS 使用和 RSS 相同的 <code>hash</code> 计算方式，并且每个队列对应一个 CPU 列表。使用计算得到的 <code>hash</code> 值模上 CPU 列表的长度就得到了 CPU 号。当确定了新的 CPU 之后，数据包会被放置到相应 CPU 的 backlog 队列中。随后在新的 CPU 上触发一个 IPI 中断，告诉该 CPU 有 RPS 过来的新包需要其处理。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">[CPU id] = [hash value] mod [len(CPU list)]
</span></span></code></pre></td></tr></table>
</div>
</div><p>在编译内核时通过设置 <code>CONFIG_RPS</code> 参数来设置是否支持 RPS 功能，系统默认为开。但是需要为想要使用 RPS 功能的队列配置上面提到的 CPU 列表。</p>
<p>RPS 配置文件为 <code>/sys/class/net/&lt;device&gt;/queue/&lt;rx-queue&gt;/rps_cpus</code> ，其中 <code>&lt;device&gt;</code> 表示网络设备，如 <code>eth0</code> ，<code>&lt;rx-queue&gt;</code> 表示接收队列，如 <code>rx-0</code>。</p>
<p>该文件中存储的是一个十六进制的 <code>bitmap</code>。每一个二进制比特代表一个 CPU，最右边对应序号最小的 CPU（即 <code>CPU0</code>），最左边代表最大的。（参考<a href="../22-02-13_binding-cpu-irq-queue" rel="">上一篇</a>）</p>
<p>每个队列的配置默认为 <code>0</code>，即关闭 RPS 功能。如果要打开，用户可以根据规则自行设置。</p>
<div class="details admonition tip open">
        <div class="details-summary admonition-title">
            <i class="icon fas fa-lightbulb fa-fw"></i>技巧<i class="details-icon fas fa-angle-right fa-fw"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content"><p>如果网卡只支持单个队列，并且有多个 CPU 的的话，在 NUMA 系统中，一般将 RPS CPU 设置为在相同 <code>domain</code> 的 CPU，非 NUMA 系统就无所谓了，因为设置为每一个 CPU 的性能都是一样的。</p>
<p>对于多队列网卡，一般系统不会同时启用 RSS 和 RPS，因为这没什么好处。但也有例外，比如网卡所支持的队列数目少于 CPU 数，也就是每个 CPU 还分不到一个接收队列，那么使用 RPS 可能会使得 CPU 的任务分布更高效。</p>
</div>
        </div>
    </div>
<h2 id="receive-flow-steering-rfs">Receive Flow Steering (RFS)</h2>
<p>以上机制很好地保证了数据包处理的负载均衡，可以将处理任务合理的分配到所有的 CPU 上。</p>
<p>但是，有时候我们还需要考虑其他的因素。比如，网卡收到了属于一个运行在 <code>CPU0</code> 上的进程的数据包，那么这些数据包被 <code>CPU0</code> 处理会比其他 CPU 处理更高效。</p>
<p>原因很简单直观，数据在 CPU 内传递比跨 CPU 传递要更节省时间。因此，我们希望数据包尽量能够被其所属的进程所在的 CPU 处理，至少能够被同属一个 NUMA 域的 CPU 处理。</p>
<p>RFS 机制就是为了实现这一点。该机制利用了与 RSS/RPS 类似的 <code>hash</code> 和查找策略，即使用 <code>hash</code> 函数根据包头信息计算得到一个 <code>hash</code> 值，然后作为索引查表。但与之不同的是，RFS 所查找的匹配表（<code>rps_sock_flow_table</code>）中存储的是<strong>数据包所属进程所在的 CPU</strong>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">[hash value] : [CPU id]
</span></span><span class="line"><span class="cl">...
</span></span></code></pre></td></tr></table>
</div>
</div><ul>
<li>回顾一下，RPS/RSS 中存储的是预先配置好的 CPU 列表。</li>
</ul>
<p>如果能查找到有效的 CPU，就按照与 RPS 相同的机制，将数据包入队到 CPU 对应的 <code>backlog</code> 队列中；如果查找不到，那么就直接按照 RPS 机制转发。</p>
<p>与 RPS 预先配置好的 CPU 列表不同，<code>rps_sock_flow</code> 表是动态更新的。如果有数据包的收发操作，如 <code>inet_recvmsg(), inet_sendmsg(), inet_sendpage(), tcp_splice_read()</code> 等操作，则会插入新的值。类似的情况还发生在进程被调度到新的 CPU 的时候。这时候就需要更新匹配表中的值。如果原来的 CPU 队列上还有未处理完的数据包，那么就会发生乱序。</p>
<p>为了避免乱序，RFS 使用了另一个表 —— <code>rps_dev_flow</code> 表，每个网卡队列对应一个该表。该表的索引依旧是包头的 <code>hash</code> 值，每个索引对应两个字段：1) 现在的 CPU（也就是该数据包所属流已经把数据包放在其队列上等待其内核处理的 CPU）号。2) 当该流最后一个数据包到达后，该 CPU 的 backlog 队列的尾计数器值。</p>
<p><figure><a class="lightgallery" href="https://2.bp.blogspot.com/-US9aezp1mUE/WUI90hna5HI/AAAAAAAAA98/yhpI17Ut9wwbzCwlBxhev5Pm4vy-QR4NwCLcBGAs/s640/RFS.png" title="RFS" data-thumbnail="https://2.bp.blogspot.com/-US9aezp1mUE/WUI90hna5HI/AAAAAAAAA98/yhpI17Ut9wwbzCwlBxhev5Pm4vy-QR4NwCLcBGAs/s640/RFS.png" data-sub-html="<h2>RFS</h2><p>RFS</p>">
        
    </a><figcaption class="image-caption">RFS</figcaption>
    </figure></p>
<blockquote>
<p>图片来源：<a href="https://garycplin.blogspot.com/2017/06/linux-network-scaling-receives-packets.html" target="_blank" rel="noopener noreferrer">Linux Network Scaling: Receiving Packets (garycplin.blogspot.com)</a></p>
</blockquote>
<p>当选择处理数据包的 CPU 时，首先检查 <code>rps_sock_flow</code> 表和 <code>rps_dev_flow</code> 表中对应的 CPU 值是否相同。如果一样，说明进程还是运行在相同的 CPU 上，仍将数据包放在该 CPU 的队列上，没有问题。如果不一样，那么就看以下三个情况：</p>
<ol>
<li>现在的 CPU 队列头计数器 ≥ <code>rps_dev_flow</code> 表中的队列尾计数器。</li>
<li>现在的 CPU 未被设置 (≥ <code>nr_cpu_ids</code>)。</li>
<li>现在的 CPU 下线了。</li>
</ol>
<p>如果上面任意一条满足，就将现在的 CPU 更新为 Desired CPU （即 <code>rps_sock_flow</code> 表中的值）。否则，仍在原（现） CPU 上执行。</p>
<p>直观的理解上面的判断机制，那就是：当进程切换 CPU 时，先判断原 CPU 队列上有没有未处理完的包，如果有就不切换；如果没有，就切换。</p>
<p>Linux 内核编译可通过允许 <code>CONFIG_RPS</code> 来使能该功能，一般默认允许。但要是想让 RFS 真正工作，还需要进行配置上面提到的两个表，他们的配置路径分别为：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">/proc/sys/net/core/rps_sock_flow_entries
</span></span><span class="line"><span class="cl">/sys/class/net/&lt;dev&gt;/queues/rx-&lt;n&gt;/rps_flow_cnt
</span></span></code></pre></td></tr></table>
</div>
</div><div class="details admonition tip open">
        <div class="details-summary admonition-title">
            <i class="icon fas fa-lightbulb fa-fw"></i>技巧<i class="details-icon fas fa-angle-right fa-fw"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content"><a href="https://www.kernel.org/doc/html/latest/networking/scaling.html" target="_blank" rel="noopener noreferrer">该文档</a> 建议 <code>rps_sock_flow_entries</code> 的数量应该跟活跃流的数量相当，然后四舍五入取二的指数值。进一步，文档建议对于一般负载的服务器，值取为 <code>32768 (2^15)</code> 效果比较好。对于 <code>rps_flow_cnt</code> 的取值应该参考 <code>rps_sock_flow_entries</code>，因为前者是每个队列一个，后者是全局的，所以只要将 <code>rps_flow_cnt</code> 取为 <code>rps_sock_flow_entries / N</code> 就行，其中 <code>N</code> 为队列数。</div>
        </div>
    </div>
<p>关于该建议，本人的理解是：最好能够给每一个活跃的流都能分配一个表项，使其能够准确找到对应的 CPU。</p>
<h2 id="accelerated-rfs">Accelerated RFS</h2>
<p>Accelerated RFS 之于 RFS 相当于 RSS 之于 RPS。Accelerated RFS 在硬件上就可以选择正确的队列，随后触发该数据包所属流所在的 CPU 的中断。由此可见，如果想要在硬件上实现队列选择，我们需要一个从流到硬件队列的对应关系。</p>
<p>从上文可知，我们已经有了一个从流到 CPU 的映射关系，记录在 <code>rps_dev_flow</code> 表中。然后，我们也有 CPU 和硬件队列的关系，通过 <code>/proc/irq/&lt;irq_num&gt;/smp_affinity</code> 进行配置。</p>
<div class="details admonition info open">
        <div class="details-summary admonition-title">
            <i class="icon fas fa-info-circle fa-fw"></i>信息<i class="details-icon fas fa-angle-right fa-fw"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content">回顾一下 <code>rps_dev_flow</code> 表中存储的信息，如果该表被更新，说明有某个进程被创建，或者进程连同协议处理完全迁移到了一个新的 CPU。</div>
        </div>
    </div>
<p><figure><a class="lightgallery" href="https://1.bp.blogspot.com/-RQDZerX_Lgk/WUEN1icXAfI/AAAAAAAAA9s/EFfwdrDl7AcsT8ovL_J2x7GVh7awXBsHwCLcBGAs/s640/aRFS.png" title="aRFS" data-thumbnail="https://1.bp.blogspot.com/-RQDZerX_Lgk/WUEN1icXAfI/AAAAAAAAA9s/EFfwdrDl7AcsT8ovL_J2x7GVh7awXBsHwCLcBGAs/s640/aRFS.png" data-sub-html="<h2>aRFS</h2><p>aRFS</p>">
        
    </a><figcaption class="image-caption">aRFS</figcaption>
    </figure></p>
<blockquote>
<p>图片来源：<a href="https://garycplin.blogspot.com/2017/06/linux-network-scaling-receives-packets.html" target="_blank" rel="noopener noreferrer">Linux Network Scaling: Receiving Packets (garycplin.blogspot.com)</a></p>
</blockquote>
<p>每当 <code>rps_dev_flow</code> 表中的条目被更新，网络协议栈就会调用驱动中的 <code>ndo_rx_flow_steer</code> 函数来更新流到硬件队列的对应关系。</p>
<p>Accelerated RFS 需要在编译阶段使能 <code>CONFIG_RFS_ACCEL</code>，并且需要硬件和驱动的支持。此外，还需要使用 <code>ethtool</code> 设置 <code>ntuple</code> 过滤。其他的就不需要配置了。</p>
<div class="details admonition tip open">
        <div class="details-summary admonition-title">
            <i class="icon fas fa-lightbulb fa-fw"></i>技巧<i class="details-icon fas fa-angle-right fa-fw"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content">Accelerated RFS 机制可以将数据包直接放在最终的 CPU 硬件队列上，所以性能应该是要比 RFS 高。因此，当硬件支持该选项，应该选择此机制。</div>
        </div>
    </div>
<h2 id="总结">总结</h2>
<p>回顾一下这些机制之间的关系。首先是 RSS/RPS，该机制在接收数据包的时候，通过手动配置，甚至是根据负载情况的自动配置（如 <code>irqbalance</code>），来把数据包的处理负载均匀分配到不同的 CPU 上。<strong>RSS/RPS 仅根据负载大小进行判断</strong>，但是这可能导致从协议栈处理到上层应用处理之间数据包的转移。</p>
<p>因此 RFS/aRFS 更进一步，在进行 CPU 选择的时候考虑上层应用所处位置，对每一个流都配置一个 Desired CPU。因此，在为数据包选择 CPU 的时候，会优先选择 Desired CPU。</p>
<h2 id="参考">参考</h2>
<ol>
<li><a href="https://www.kernel.org/doc/html/latest/networking/scaling.html" target="_blank" rel="noopener noreferrer">Scaling in the Linux Networking Stack — The Linux Kernel documentation</a></li>
<li><a href="https://en.wikipedia.org/wiki/Toeplitz_Hash_Algorithm" target="_blank" rel="noopener noreferrer">Toeplitz Hash Algorithm - Wikipedia</a></li>
<li><a href="https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html/performance_tuning_guide/network-rps" target="_blank" rel="noopener noreferrer">8.7. Receive Packet Steering (RPS) Red Hat Enterprise Linux 6 | Red Hat Customer Portal</a></li>
<li><a href="https://www.kernel.org/doc/html/latest/core-api/irq/irq-affinity.html" target="_blank" rel="noopener noreferrer">SMP IRQ affinity — The Linux Kernel documentation</a></li>
<li><a href="https://garycplin.blogspot.com/2017/06/linux-network-scaling-receives-packets.html" target="_blank" rel="noopener noreferrer">Linux Network Scaling: Receiving Packets (garycplin.blogspot.com)</a></li>
</ol>]]></description></item><item><title>理解 CPU、中断、队列、进程的绑定关系</title><link>https://xinyu-yang.github.io/blog/2023/23-02-13_binding-cpu-irq-queue/</link><pubDate>Mon, 13 Feb 2023 12:27:10 +0800</pubDate><author>作者</author><guid>https://xinyu-yang.github.io/blog/2023/23-02-13_binding-cpu-irq-queue/</guid><description><![CDATA[<p>最近在学习网络性能的测试，其中涉及到 CPU、中断、队列以及进程的映射关系。因为所涉及的元素比较多，所以对于他们的映射关系感到迷迷糊糊，产生了一大堆问题，比如：中断和队列是一对一吗？CPU 和队列是一对一吗？怎么查看和修改他们的映射关系？</p>
<p>为了解决以上问题，笔者查阅了很多文档资料。为了加深理解并且防止遗忘，决定将自己的理解记录下来。</p>
<p>首先回答第一个问题：每一个队列有一个与之对应的中断号，然后可以使用 <code>Message Signaled Interrupts (MSI-X)</code> 来将中断路由给指定的 CPU。队列与中断之间的映射可以从 <code>/proc/interrupts</code> 获取，下面是一个 <code>8</code> 核 CPU 的例子：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span><span class="lnt">14
</span><span class="lnt">15
</span><span class="lnt">16
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">						CPU0       CPU1       CPU2       CPU3       CPU4       CPU5       CPU6       CPU7       
</span></span><span class="line"><span class="cl">   0:          6          0          0          0          0          0          0          0   IO-APIC    2-edge      timer
</span></span><span class="line"><span class="cl">   1:          0          4          0          0          0          0          0          0   IO-APIC    1-edge      i8042
</span></span><span class="line"><span class="cl">   8:          0          0          1          0          0          0          0          0   IO-APIC    8-edge      rtc0
</span></span><span class="line"><span class="cl">   9:          0          0          0          0          0          0          0          0   IO-APIC    9-fasteoi   acpi
</span></span><span class="line"><span class="cl">  12:          6          0          0          0          0          0          0          0   IO-APIC   12-edge      i8042
</span></span><span class="line"><span class="cl">  16:          0          0          0          0          0          0          0          0   IO-APIC   16-fasteoi   i801_smbus
</span></span><span class="line"><span class="cl">  17:          0          0          0          0          0          0          0        151   IO-APIC   17-fasteoi   snd_hda_intel:card1
</span></span><span class="line"><span class="cl"> 125:          0          0          0          0          0          0          0          0   PCI-MSI 327680-edge      xhci_hcd
</span></span><span class="line"><span class="cl"> 126:          0          0          0          0      11596          0    5250359          0   PCI-MSI 376832-edge      ahci[0000:00:17.0]
</span></span><span class="line"><span class="cl"> 127:        765          0          0          0          0          0          0   70831230   PCI-MSI 3145728-edge      enp6s0
</span></span><span class="line"><span class="cl"> 128:          0          0          0          0          0       4285          0          0   PCI-MSI 360448-edge      mei_me
</span></span><span class="line"><span class="cl"> 129:          0          0          0          0          0          0        699          0   PCI-MSI 514048-edge      snd_hda_intel:card0
</span></span><span class="line"><span class="cl"> NMI:       2784       2802       2778       2755       2605       2570       2615       2658   Non-maskable interrupts
</span></span><span class="line"><span class="cl"> LOC:  530160796  528154099  531420711  523368187  526087908  508786297  499113075  494567411   Local timer interrupts
</span></span><span class="line"><span class="cl"> SPU:          0          0          0          0          0          0          0          0   Spurious interrupts
</span></span></code></pre></td></tr></table>
</div>
</div><p>可以看出网卡 <code>enp6s0</code> 的队列所对应的中断号为 <code>127</code>。除此之外，还可以看出，该中断几乎都是由 <code>CPU7</code> 进行处理的。那么该中断跟 <code>CPU7</code> 有什么关系呢？</p>
<p>为了回答该问题，我们可以查看该中断对应的绑定信息，该信息可以用 <code>cat /proc/irq/127/smp_affinity</code> 命令获取 (可参考 <a href="https://www.kernel.org/doc/html/latest/core-api/irq/irq-affinity.html" target="_blank" rel="noopener noreferrer">SMP IRQ affinity — The Linux Kernel documentation</a>)。结果为：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ cat /proc/irq/127/smp_affinity
</span></span><span class="line"><span class="cl"><span class="m">80</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>80</code> 是一个十六进制的 <code>bitmap</code>，转换成二进制就是 <code>0b 1000 0000</code> ，从右往左数，第 <code>8</code> 个位置为 <code>1</code>，所表示的意思就是：该中断（<code>127</code>）被绑定到第 <code>8</code> 个 CPU （<code>CPU7</code>）。</p>
<p>如果要更改该绑定关系，直接将相应的数字写到该文件中即可。比如我们想将其绑定到 <code>CPU0-3</code>：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ sudo su
</span></span><span class="line"><span class="cl"><span class="c1"># echo 0f &gt; /proc/irq/127/smp_affinity</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">or
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">$ sudo sh -c <span class="s1">&#39;echo 0f &gt; /proc/irq/127/smp_affinity&#39;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这里需要注意的是，无法直接使用 <code>sudo</code>，需要先切换为 <code>root</code> 用户，才能用此操作，或者将整个命令当成脚本（参考 <a href="https://stackoverflow.com/questions/82256/how-do-i-use-sudo-to-redirect-output-to-a-location-i-dont-have-permission-to-wr" target="_blank" rel="noopener noreferrer">linux - How do I use sudo to redirect output to a location I don&rsquo;t have permission to write to? - Stack Overflow</a>）。</p>
<p>虽然理论上我们已经将网卡对应的中断绑定到 <code>CPU0-3</code>，但是笔者发现，在实际使用中（<code>Ubuntu 20.04</code>），中断默认被序列号最小的 CPU 处理，也不知道是什么原因。</p>
<p>通过以上操作，我们也回答了第二、三个问题，CPU 和队列不是一对一的关系，一个 CPU 可以对应多个队列，同时一个队列也可以配置多个 CPU。关于更改如何修改绑定，上文已经详述。</p>
<h2 id="参考文献">参考文献</h2>
<ol>
<li><a href="https://www.kernel.org/doc/html/latest/networking/scaling.html" target="_blank" rel="noopener noreferrer">Scaling in the Linux Networking Stack — The Linux Kernel documentation</a></li>
</ol>]]></description></item><item><title>深入理解大小端序与位操作</title><link>https://xinyu-yang.github.io/blog/2023/23-02-01_little-endian/</link><pubDate>Wed, 01 Feb 2023 17:39:47 +0800</pubDate><author>作者</author><guid>https://xinyu-yang.github.io/blog/2023/23-02-01_little-endian/</guid><description><![CDATA[<p>最近在读代码的时候对端序（<code>endianness</code>）的转换部分产生了一些疑惑，主要原因是对相关知识的理解还不够透彻。查找阅读了一些文献之后，有了更深刻的理解。</p>
<h2 id="概念引入">概念引入</h2>
<p>在讨论端序之前，我们先规定一些最基本的顺序，这一点很重要。</p>
<ul>
<li>人的书写以及阅读是从左往右的。</li>
<li>机器读写数据是从低地址到高地址。</li>
</ul>
<p>类似的，人们习惯按照从高位到低位来表示一个数字，比如数字 <code>256</code>，百位是 <code>2</code>，十位是 <code>5</code>，个位是 <code>6</code>。再比如一个十六进制数 <code>0x12345678</code> ，最高位是 <code>1</code> ，最低位是 <code>8</code>。</p>
<p>这种先写（读）高位数据，再写（读）低位数据的顺序，我们称之为 大端序（<code>Big-Endian</code>）。字面意思理解，就是把大的放在前面。结合上面对于基本顺序的规定，前面就是人们书写的左边，或者是机器的低地址。</p>
<p>聪明的你肯定马上会想到，那么 小端序（<code>Little-Endian</code>）相应的就是先写（读）低位，再写（读）高位。结合上面的例子，对于数字 <code>256</code>，如果按照 <code>“个十百”</code> 的表示顺序，就应该写成 <code>652</code>。</p>
<h2 id="计算机中的字节序">计算机中的字节序</h2>
<p>然后让我们回到计算机学科中来讨论。虽然计算机中数据的最小表示单位是 <code>比特（bit）</code>，但由于 <a href="https://en.wikipedia.org/wiki/Endianness" target="_blank" rel="noopener noreferrer">现代计算机体系架构的寻址粒度</a> 一般是 <code>字节（byte）</code>，所以我们所说的端序通常指的是 <strong>字节序</strong>。</p>
<p>对于比特位的前后顺序（<code>Bit Endieanness</code>），一般在数据序列化的时候讨论，而不是在计算机体系结构中。<strong>所以在本文中，我们规定，字节内的比特位的排列为从高位到低位</strong>。例如，<code>170</code> 用单字节表示为 （参考 <a href="https://www.rfc-editor.org/rfc/rfc1700.html" target="_blank" rel="noopener noreferrer">RFC 1700: Assigned Numbers (rfc-editor.org)</a>）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">				  0 1 2 3 4 5 6 7
</span></span><span class="line"><span class="cl">				 +-+-+-+-+-+-+-+-+
</span></span><span class="line"><span class="cl">				 |1 0 1 0 1 0 1 0|
</span></span><span class="line"><span class="cl">				 +-+-+-+-+-+-+-+-+
</span></span></code></pre></td></tr></table>
</div>
</div><div class="details admonition info open">
        <div class="details-summary admonition-title">
            <i class="icon fas fa-info-circle fa-fw"></i>信息<i class="details-icon fas fa-angle-right fa-fw"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content"><p>事实上，如果字节和比特位均为小端序，即先低位，再高位，这种顺序称之为严格小端序。可是<a href="https://www.rfc-editor.org/ien/ien137.txt" target="_blank" rel="noopener noreferrer">这篇文章</a>指出，严格大端序很常见，但是严格小端序没有（截止到该文）。</p>
<p>因此，我们上述的规定是合理的。</p>
</div>
        </div>
    </div>
<p>上节例子中的十六进制数 <code>0x12345678</code> ，共占用了四个字节，从最高位字节（<code>Most Significant Byte, MSB</code>）到最低位字节（<code>Least Significant Byte, LSB</code>）分别为 <code>0x12 0x34 0x55 0x78</code>。</p>
<p>如果按照 <code>Big-Endian</code> 来存储，假设从左到右为低地址到高地址，那么其在存储设备中存储为：<code>0x12 0x34 0x56 0x78</code> 。如果按照 <code>Little-Endian</code> 来存储，其存储为：<code>0x78 0x56 0x34 0x12</code>。</p>
<p>直到这里还算是云淡风轻，岁月静好。</p>
<h2 id="小端序的移位操作">小端序的移位操作</h2>
<p>对于移位操作，大家应该并不陌生，比如 <code>C</code> 语言中的：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="kt">short</span> <span class="n">i</span> <span class="o">=</span> <span class="mh">0x1080</span> <span class="o">&lt;&lt;</span> <span class="mi">1</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这条语句将 <code>0x1080</code>左移一位，然后赋值给两字节变量 <code>i</code>，这里我们主要关注移位操作。</p>
<p>首先分析 <code>Big-Endian</code> 下的情况，为了直观观察，我们将 <code>0x1080</code> 转换为二进制，如下图第一行所示。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">0001 0000 | 1000 0000 (0x1080)
</span></span><span class="line"><span class="cl">		  V
</span></span><span class="line"><span class="cl">Op: Left Shift 1 bit (&lt;&lt; 1)
</span></span><span class="line"><span class="cl">		  V
</span></span><span class="line"><span class="cl">0010 0001 | 0000 0000 (0x2100)
</span></span></code></pre></td></tr></table>
</div>
</div><p>然后将该值左移一位，变成如最后一行所示的比特串。最终的结果也变为 <code>0x2100</code>，左移相当于 <code>*2</code>，变成原来的两倍，没问题。</p>
<p>然后再看 <code>Little-Endian</code> 下的情况：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">1000 0000 | 0001 0000 (0x1080)
</span></span><span class="line"><span class="cl">		  V
</span></span><span class="line"><span class="cl">Op: Left Shift 1 bit (&lt;&lt; 1)
</span></span><span class="line"><span class="cl">		  V
</span></span><span class="line"><span class="cl">0000 0000 | 0010 0000 (0x2000)
</span></span></code></pre></td></tr></table>
</div>
</div><p>我们发现，直接进行左移的话结果不对呀！可见真实的计算机不是这么做的。</p>
<p>回过头思考左移的本质，我们发现，左移并不是简单的把二进制数往左移动，而是把数据从低位（<code>LSB</code>）往高位（<code>MSB</code>）移动。只不过人们的书写习惯是 <code>Big-Endian</code>，恰好是从大往小写，所以才造成了左移就是往左移动的错觉。</p>
<p>意识到这一点，我们再次回归上面的 <code>Little-Endian</code> 例子。如果按照从低位往高位移动的规律，我们发现数据的移动是这样的：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">&lt;- Shift 1 bit
</span></span><span class="line"><span class="cl">1000 0000 | 0001 0000 (0x1080)
</span></span><span class="line"><span class="cl">|                   ^		
</span></span><span class="line"><span class="cl">+-------------------+
</span></span></code></pre></td></tr></table>
</div>
</div><p>看起来像是循环移位一样，其实不然，如果字节数多的话，我们会发现从一个字节左边移出来的比特位总会补到该字节右边的字节上。</p>
<p>这个过程让一个简单的移位操作看起来很复杂，但其实有更好的理解方式。</p>
<p>参考 <a href="https://stackoverflow.com/questions/7184789/does-bit-shift-depend-on-endianness" target="_blank" rel="noopener noreferrer">c - Does bit-shift depend on endianness? - Stack Overflow</a> 这个问题中被采纳的回答。我们只需要将字节序简单地理解为数据在内存中的存储顺序。</p>
<p>对于该移位操作，<code>CPU</code> 首先将两个字节的数据以大端序存放到寄存器中（如果是 <code>Big-Endian</code>，直接按顺序存放即可；如果是 <code>Little-Endian</code>，将顺序颠倒下）。</p>
<p>然后对寄存器中的值执行移位操作。最后，再将值按照规则存放到原来的内存中。</p>
<p>总结下来，不管小端序还是大端序存储，左移和右移的结果跟我们手动算出来是一样的。如果在内存上的小端序存储的移位操作不能直观理解，那么就假设我们先把数据取出来，按照 <code>Big-Endian</code>（人们看起来自然的方式） 放置，然后再移位。</p>
<h2 id="小端序的按位运算">小端序的按位运算</h2>
<p>笔者正是在阅读代码的时候，看到对大小端序的转化，以及小端序的按位运算操作，才被搞得晕头转向。所以这里结合一个实际的例子来看。</p>
<p>我是在看网络编程相关的代码时遇到的该问题，因此，有必要先介绍下网络中的字节序。</p>
<p>当数据在网络中传输时，仍然需要规定一个顺序。对于独立的字节来说，字节之间的顺序没有意义，就是简单的从前往后，从左往右。</p>
<p>而对于一组字节（比如 <code>IP ID</code> 具有两个字节），其字节之间的顺序就是我们要讨论的内容。</p>
<p><a href="https://www.rfc-editor.org/rfc/rfc791" target="_blank" rel="noopener noreferrer">RFC 791</a> 以及 <a href="https://www.rfc-editor.org/rfc/rfc1700.html" target="_blank" rel="noopener noreferrer">RFC 1700</a> 中均提到：报文头和数据的传输顺序都是以<strong>八位字节</strong>为单位来说的，对于一组字节来说，其传输顺序与人的阅读习惯相同（即从左到右）。</p>
<p>这表明网络中数据的传输是 <code>Big-Endian</code> 的（<code>Big-Endian</code> 也可称为 <code>Network Byte Order</code>，网络字节序）。因此，为了能在 <code>Little-Endian</code> 计算机上正确处理从网络中来的数据，我们需要对数据进行一定的转换。</p>
<p>代码中有那么一行：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cm">/* 
</span></span></span><span class="line"><span class="cl"><span class="cm">* iph 是 iphdr 类型的变量
</span></span></span><span class="line"><span class="cl"><span class="cm">* __be32 是由 __u32 定义的类型
</span></span></span><span class="line"><span class="cl"><span class="cm">*/</span>
</span></span><span class="line"><span class="cl"><span class="n">id</span> <span class="o">=</span> <span class="nf">ntohl</span><span class="p">(</span><span class="o">*</span><span class="p">(</span><span class="n">__be32</span> <span class="o">*</span><span class="p">)</span><span class="o">&amp;</span><span class="n">iph</span><span class="o">-&gt;</span><span class="n">id</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>为了更好的理解，有必要列出 <code>iphdr</code> 结构中关于 <code>id</code> 字段的部分:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="k">struct</span> <span class="n">iphdr</span> <span class="p">{</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="n">__be16</span> <span class="n">id</span><span class="p">;</span> <span class="c1">// __be16 等同于 __u16
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="n">__be16</span> <span class="n">frag_off</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="p">...</span>
</span></span><span class="line"><span class="cl"><span class="p">};</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>那么对上面那行代码的理解就是，从 <code>id</code> 的起始地址开始，取出 <code>32</code> 比特数据，并将其作为参数传到 <code>ntohl</code> 函数中。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span><span class="lnt">11
</span><span class="lnt">12
</span><span class="lnt">13
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">    0                   1                   2                   3
</span></span><span class="line"><span class="cl">    0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1 2 3 4 5 6 7 8 9 0 1
</span></span><span class="line"><span class="cl">   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</span></span><span class="line"><span class="cl">   |Version|  IHL  |Type of Service|          Total Length         |
</span></span><span class="line"><span class="cl">   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</span></span><span class="line"><span class="cl">   |         Identification        |Flags|      Fragment Offset    |
</span></span><span class="line"><span class="cl">   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</span></span><span class="line"><span class="cl">   |  Time to Live |    Protocol   |         Header Checksum       |
</span></span><span class="line"><span class="cl">   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</span></span><span class="line"><span class="cl">   |                       Source Address                          |
</span></span><span class="line"><span class="cl">   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</span></span><span class="line"><span class="cl">   |                    Destination Address                        |
</span></span><span class="line"><span class="cl">   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</span></span></code></pre></td></tr></table>
</div>
</div><p>(上图是 IPv4 报文头)</p>
<p>我们先来看看取出来的这 <code>32</code>比特数据都是什么，根据 <code>IPv4</code> 报文头以及上述 <code>iphdr</code> 结构体可知，我们所取出来的值包括 <code>IP ID</code>、<code>分段标志位</code>、以及 <code>段偏移</code>。也就是这一行上的数据：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</span></span><span class="line"><span class="cl">   |         Identification        |Flags|      Fragment Offset    |
</span></span><span class="line"><span class="cl">   +-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+-+
</span></span></code></pre></td></tr></table>
</div>
</div><p>现在假设 <code>IP ID</code> 为 <code>0x1234</code>，标志位和段偏移分别为 <code>b010</code>、 <code>b0100010001000</code>。并且 <code>iph→id</code> 字段的起始地址为 <code>0xe0</code> 。那么，其在内存中的值为：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">Value: 0001 0010 | 0011 0100 | 0100 1000 | 1000 1000
</span></span><span class="line"><span class="cl">       \--------/ \--------/  \--------/  \--------/
</span></span><span class="line"><span class="cl">Addr:     0xe0       0xe1        0xe2         0xe3
</span></span></code></pre></td></tr></table>
</div>
</div><p>现在如果我们直接以 <code>__be32</code> 的方式将该值从 <code>Little-Endian</code> 机器上读出来，那么该值为：<code>0x88483412</code>。这个值跟我们读到的字节顺序正好是反过来的。</p>
<p>而我们在写代码的时候希望比较直观的操作。比如，如果我们想看一下 <code>Flags</code> 中第二个标志位（即 <code>Donot Fragment, DF 标志</code>）是多少，我们希望的操作是：使用按位与操作符，看一下从右往左边数第 <code>15</code> 个比特位是否为 <code>1 </code>。其实更准确的说法是：<strong>从低位往高位数，第 15 个比特位</strong>。代码形式如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="c1">// bit32 = *(__be32 *)&amp;iph-&gt;id，即我们读出来的值。
</span></span></span><span class="line"><span class="cl"><span class="c1"></span><span class="kt">int</span> <span class="n">DF</span> <span class="o">=</span> <span class="n">bit32</span> <span class="o">&amp;</span> <span class="p">(</span><span class="mi">1</span> <span class="o">&lt;&lt;</span> <span class="mi">14</span><span class="p">);</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>左移操作可以将 <code>1</code> 的值从最右边移动到右起第 <code>15</code> 位，或者说从最低位起，第 <code>15</code> 位。</p>
<p>但以现在的值来看，这种操作明显得不到我们想要的值，因为对于现在取出来的值 <code>0x88483412</code> 来说，从低位起第 <code>15</code> 位对应的是 <code>IP ID</code> 的值。</p>
<p>因此，如果想要实现一种直观的操作方式，我们可以将所取出来的值的 <strong>字节序颠倒</strong> 过来，即将 <code>0x88483412</code> 变成 <code>0x12344888</code>。</p>
<p>这样的话，我们看到的值 <code>0x12344888</code> 就跟 <code>IP</code> 头中的值一一对应上了（<code>IP ID</code> 对应 <code>0x1234</code>，标志位和段偏移对应 <code>0x4888</code>）。</p>
<p>至此，大功告成，但其实这种对应关系经历了两次翻转：</p>
<ul>
<li>一次是我们上面所述的字节序颠倒操作。</li>
<li>另一次是当我们从 <code>Little-Endian</code> 中取出数据的时候，也会有一个从 <code>Little-Endian</code> 转换为 <code>Big-Endian</code> 的颠倒操作。</li>
</ul>
<p>那么现在还剩一个问题，如何翻转呢？</p>
<p>这其实就是函数 <code>ntohl</code> 函数做的事情，该函数全称为 <code>network to host long</code>。很直观，就是将一个网络字节序（<code>Big-Endian</code>）的值转换为 <code>Little-Endian</code> 的 <code>long</code> 类型。</p>
<p>该函数的实现也挺直观，就是通过移位将字节顺序颠倒：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="cp">#define ___constant_swab32(x) ((__u32)(				\
</span></span></span><span class="line"><span class="cl"><span class="cp">	(((__u32)(x) &amp; (__u32)0x000000ffUL) &lt;&lt; 24) |		\
</span></span></span><span class="line"><span class="cl"><span class="cp">	(((__u32)(x) &amp; (__u32)0x0000ff00UL) &lt;&lt;  8) |		\
</span></span></span><span class="line"><span class="cl"><span class="cp">	(((__u32)(x) &amp; (__u32)0x00ff0000UL) &gt;&gt;  8) |		\
</span></span></span><span class="line"><span class="cl"><span class="cp">	(((__u32)(x) &amp; (__u32)0xff000000UL) &gt;&gt; 24)))
</span></span></span></code></pre></td></tr></table>
</div>
</div><p>类似的函数还有 <code>ntohs, htons, htonl</code> 等。</p>
<h2 id="小端序的优点">小端序的优点</h2>
<p>大小端序是由 <code>CPU</code> 架构来决定的，例如我们通常所接触到的 <code>x86</code> 架构，就是采用的 <code>Little-Endian</code>。上面介绍了那么多关于 <code>Little-Endian</code> 的性质，但是有一个重要问题还没有回答：为什么 <code>CPU</code> 要采用这种反直觉的存储顺序呢？</p>
<p>查阅资料，发现 <code>Little-Endian</code> 有以下优点：</p>
<ol>
<li>在进行数据类型转换的时候，不同类型的数据的地址是一样的，比如 <code>C</code> 语言中的 <code>int、short、long、char</code>。比如现在有一个 <code>short</code> 类型（<code>2</code> 字节）的变量 <code>num</code>，其值为 <code>0x80</code>。假设其初始地址为 <code>0xe0</code>，按照小端序，该变量在内存中存储为：</li>
</ol>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">1.
</span></span><span class="line"><span class="cl">Value: 0000 1000 | 0000 0000
</span></span><span class="line"><span class="cl">       \--------/ \--------/
</span></span><span class="line"><span class="cl">Addr:     0xe0       0xe1
</span></span></code></pre></td></tr></table>
</div>
</div><p>此时变量的地址为 <code>0xe0</code>，即：<code>&amp;num == 0xe0</code>;</p>
<p>现在如果想要将其扩充为 <code>int</code> 类型（<code>4</code> 字节）的变量，即 <code>int num_t = (int) num</code>; 那么其在内存中的值为：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">2.
</span></span><span class="line"><span class="cl">Value: 0000 1000 | 0000 0000 | 0000 0000 | 0000 0000
</span></span><span class="line"><span class="cl">       \--------/ \--------/  \--------/  \--------/
</span></span><span class="line"><span class="cl">Addr:     0xe0       0xe1        0xe2         0xe3
</span></span></code></pre></td></tr></table>
</div>
</div><p>此时，变量的地址仍为 <code>0xe0</code>。</p>
<p>类似，如果想要将其转换为 <code>char</code> 类型（<code>1</code> 字节），其在内存中的值将变为：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-fallback" data-lang="fallback"><span class="line"><span class="cl">3.
</span></span><span class="line"><span class="cl">Value: 0000 1000 
</span></span><span class="line"><span class="cl">       \-------/ 
</span></span><span class="line"><span class="cl">Addr:     0xe0
</span></span></code></pre></td></tr></table>
</div>
</div><p>变量地址不变。</p>
<p>在 <code>C</code> 语言中，以上操作也可以换一种说法：假设有一个数据存储在地址 <code>0xe0</code> （代码行 <code>1)</code>），如果我们以 <code>short</code> 类型来对该地址的值进行读写（即 <code>2)</code> 中的 <code>num_s</code> ），那么其值为 <code>0x0080</code>，对应上述 <code>图 1</code>；如果以 <code>int</code> 或者 <code>char</code> 类型来进行操作（<code>3) 和 4)</code> 中的 <code>num_i 和 num_c</code>），其值分别为 <code>0x00000080</code> 和 <code>0x80</code>，对应<code>图 2 和 3</code>。</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-c" data-lang="c"><span class="line"><span class="cl"><span class="mi">1</span><span class="p">)</span> <span class="kt">addr_t</span> <span class="n">addr</span> <span class="o">=</span> <span class="mh">0xe0</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="mi">2</span><span class="p">)</span> <span class="kt">short</span> <span class="o">*</span><span class="n">num_s</span> <span class="o">=</span> <span class="p">(</span><span class="kt">short</span> <span class="o">*</span><span class="p">)</span> <span class="n">addr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="mi">3</span><span class="p">)</span> <span class="kt">int</span> <span class="o">*</span><span class="n">num_i</span> <span class="o">=</span> <span class="p">(</span><span class="kt">int</span> <span class="o">*</span><span class="p">)</span> <span class="n">addr</span><span class="p">;</span>
</span></span><span class="line"><span class="cl"><span class="mi">4</span><span class="p">)</span> <span class="kt">char</span> <span class="o">*</span><span class="n">num_c</span> <span class="o">=</span> <span class="p">(</span><span class="kt">char</span> <span class="o">*</span><span class="p">)</span> <span class="n">addr</span><span class="p">;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>但是不管以何种方式操作，其地址值是相同的，即 <code>(addr_t) num_s == num_i == num_c</code>。</p>
<ol start="2">
<li>进行加法操作的时候，可以很方便的从小端开始计算。</li>
</ol>
<p>进行加法计算的时候，都是从低位到高位进行计算，所以在读取数据的时候，从低位到高位依次取出数据也符合操作逻辑。</p>
<h2 id="参考">参考</h2>
<ol>
<li><a href="https://en.wikipedia.org/wiki/Endianness" target="_blank" rel="noopener noreferrer">Endianness - Wikipedia</a></li>
<li><a href="https://www.quora.com/Why-were-microprocessors-built-as-big-or-little-endian-Why-did-Intel-choose-little-endian-architecture" target="_blank" rel="noopener noreferrer">Why were microprocessors built as big or little endian? Why did Intel choose little endian architecture? - Quora</a></li>
<li><a href="https://softwareengineering.stackexchange.com/questions/95556/what-is-the-advantage-of-little-endian-format" target="_blank" rel="noopener noreferrer">architecture - What is the advantage of little endian format? - Software Engineering Stack Exchange</a></li>
<li><a href="https://stackoverflow.com/questions/36812615/bitwise-operation-on-big-endian-and-little-endian-differences" target="_blank" rel="noopener noreferrer">c - Bitwise operation on big endian and little endian differences - Stack Overflow</a></li>
<li><a href="https://linux.die.net/man/3/ntohs" target="_blank" rel="noopener noreferrer">ntohs(3) - Linux man page (die.net)</a></li>
</ol>]]></description></item><item><title>2022 年度总结</title><link>https://xinyu-yang.github.io/blog/2022/22-12-30_22-annual-summary/</link><pubDate>Fri, 30 Dec 2022 08:54:57 +0000</pubDate><author>作者</author><guid>https://xinyu-yang.github.io/blog/2022/22-12-30_22-annual-summary/</guid><description><![CDATA[<p>转眼 2022 年就要结束了。随着年龄增大，越来越感觉光阴似箭。</p>
<p>回想起这一年，感觉可以用一句诗来形容 <strong>“山重水复疑无路，柳暗花明又一村”</strong> 。因为上学的事情，前面大半年都活在焦虑中。</p>
<p>首先是申请签证被 check，中间等了半年，每天去签证网站查看若干次，并且每周发多封邮件询问。随着日子一天天过去，心里焦虑更甚，同时也在默默准备着最坏的打算。</p>
<p>这一切都在半年之后的某一天收到拒签邮件那一刻戛然而止。最终，最担心的事情还是发生了。其实早就想过这方面的可能，但是当事情真正发生，还是觉得突如其来，又感觉如梦方醒。</p>
<p>在 check 期间，就一直发邮件询问学校，如果发生了最坏的情况，学业还能不能继续。我得到了所有来自  Graduate School, Department 和 International Center 的肯定答复。为了再三确认这件事，被拒签之后我又询问了一遍，答复还是类似的：<em>即使来不了学校，还是可以正常毕业。</em></p>
<p>虽然心有遗憾，但还是觉得如果能继续读书，就可以将就。于是，整顿情绪后，开始把重心放在学习和科研上。但是没想到在第二学期即将开始的某一天，发生了一件意想不到的事情：学校通知我 <strong>没办法继续</strong> 学业了！</p>
<p>现在回想起当时的感觉，应该有震惊和难过。震惊的是 Graduate School 对这件事做出了新的解释，即使我之前跟他们的工作人员确认过至少两次（学院和导师可能也确认过）。难过的自然是一年多以来的努力和时间白白浪费了。</p>
<p>不过事到如今，已经是最差的结果了，也没什么可以失去的了。自此人生彻底陷入了低谷，走投无路。那个时候的我正是 “山重水复疑无路” 的感觉。</p>
<p><strong>那就从头再来！</strong></p>
<p>开始找导师、发邮件、等待回复、面试。不得不感慨，欠的东西总有一天要还回来（上次是通过实验室同学介绍，所以没有找导师的过程）。</p>
<p>经过小半年的挣扎（此处略去一万字），总算是拿到了一个还算满意的 offer。自此，焦虑挣扎的日子算是告一段落。但愿 “这一村” 真的能 “柳暗花明”。</p>
<p>以上就是这一年的主脉络，经历百转千回、跌宕起伏。也许若干年后再看这段经历，不过是平淡生活中的小小涟漪。但当时身处其中，尝遍了酸甜苦辣。</p>
<p>另外，前几天也算是赶上了潮流。乘着完全放开后疫情的东风，“阳了” 一把。事情开始于一个周五晚上，准确的说应该是周六凌晨。因为周五晚上我还难掩周末的开心，精神抖擞。但事情到了后半夜就发生了变化。</p>
<p>首先是睡到后半夜的时候被冻醒了。此时我还没觉得有什么大问题，因为那两天恰好是天气最冷的两天，自己只盖了一个薄被子，再加上屋里空调没法制热。</p>
<p>本以为捂紧被子暖和一会就好，但是身体感觉越来越冷，浑身起鸡皮疙瘩。此时也已经睡不着了，只剩裹紧被子瑟瑟发抖。就这样不知躺了多久，在我看到窗外天蒙蒙亮的时候，我知道自己已经开始发烧了。</p>
<p>然后痛苦的熬过一个早上，浑身发热，晕晕乎乎。手上没有任何测温设备或者退烧药，药店里也早已售罄，没办法，<strong>只能硬抗</strong>。</p>
<p>下午向同学通知喜讯，从小猪那里获赐几片 “布洛芬”，<strong>如获至宝</strong> 。就这样又浑浑噩噩熬过一下午，期间没有任何食欲，只喝了点水。到了晚上，早早躺下，期望睡眠能带走病痛。睡觉前吃了一片 “布洛芬”，裹紧被子躺在床上跟寒冷和头痛斗争。不知斗争了多久，才缓缓睡去。</p>
<p>早上起来，出了很多汗，烧也退了。但是慢慢感觉头疼欲裂，外加浑身酸痛。尤其是两个屁股，跟刚打过针一样。就这样躺在床上一动不动，我才确认自己 “中招了”。在这之前我还一直怀疑是这两天太冷，所以受凉发烧。</p>
<p>自己屋里的同事已经有中招的，并且对面的同事也已经出现了发烧的症状。在这种情况下，我居然还天真地以为自己能够幸免，真是太 <strong>naive</strong>。</p>
<p>后续症状正如很多人所分享的那样——嗓子疼、虚弱、咳嗽。不再赘述，因为我相信能够看到这里的你也大概率经历了这些过程，至少我身边的人就很少有幸免的。</p>
<p>总之，一年过去，经历了很多事，但又感觉什么都没发生，恍如一场梦。回头看去，只有一些残存的记忆；细细品嚼，又能品出些许滋味。</p>
<p>在这里做一些总结吧。<strong>经验教训</strong> 如下：</p>
<ul>
<li>不要为了待在舒适圈，而一味的做出妥协，要有跳出舒适圈的勇气。在上学的事上，如果一开始没有一步步妥协，就不会有后来等待通知、听天由命的被动局面。（Life springs from sorrow and calamity; Death comes from ease and pleasure 【<a href="https://en.wiktionary.org/wiki/%E7%94%9F%E6%96%BC%E6%86%82%E6%82%A3%EF%BC%8C%E6%AD%BB%E6%96%BC%E5%AE%89%E6%A8%82#Chinese" target="_blank" rel="noopener noreferrer">生於憂患，死於安樂 - Wiktionary</a>】）</li>
<li>勇于面对困难，而不是选择逃避。回想整个申请过程，一开始是担心英语考试，后面又不敢发邮件套磁，然后一步步逃避。直到最后退无可退，才不得不迎上去，然后发现原本以为的不可逾越也不过如此。</li>
<li>要有正确的自我认知，不要心存侥幸。如果条件相似，发生在别人身上的事情很有可能也发生在自己身上。</li>
</ul>
<p>最后，给明年做一些规划。首先是希望明年能静下心来多读一些书，包括专业书和课外书。专业书虽然会偶尔翻一翻，但是很少有从头到尾读下来的情况。对于一些好的书，即使读过大部分，还是应该重新读一读，温故而知新。</p>
<p>同时还应该读一些课外书，回想起来，我读课外书最多的时候居然还是高中。当时每天挤出每一分一秒时间，读了很多书。后面上大学之后，感觉有了更多自由时间，反而没怎么读过书。一方面，生活不够规律，另一方面，浪费在多媒体娱乐上的时间太多了。</p>
<p>其次，应该多多锻炼身体。毕竟年龄越来越大了，再不注意生活习惯只怕以后吃不消。</p>
<p>这里量化一下这些 <strong>计划</strong>，更好地防止自己偷懒：</p>
<ul>
<li>完整阅读至少两本经典专业书籍。</li>
<li>至少读五本好书。</li>
<li>每周至少锻炼两次，每次不少于半小时。</li>
</ul>
<p><em>人生没有意义，而我在努力让其看起来有意义一点。不知道前面路还有多久，且行且珍惜。</em></p>]]></description></item><item><title>Zotero 配置记录（二：坚果云 WebDAV）</title><link>https://xinyu-yang.github.io/blog/2022/22-11-24_zotero-config/</link><pubDate>Thu, 24 Nov 2022 11:18:16 +0800</pubDate><author>作者</author><guid>https://xinyu-yang.github.io/blog/2022/22-11-24_zotero-config/</guid><description><![CDATA[<p>之前写过 <a href="../22-02-08_zotero-config/" rel="">一篇</a> 使用 <code>Zotfile + OneDrive</code> 软链接的方式实现附件同步的记录，但是最近准备切换到坚果云。</p>
<p>之所以使用坚果云所提供的 WebDAV 做备份，不是因为原来的方案不能用。事实上，原来的方案不管在 Windows 平台还是 MacOS 上都表现得很好。
但是如果想要在移动设备上（主要是平板）使用同步功能，软链接的方式就很麻烦了。因为移动设备不支持软链接。</p>
<p>我之前的做法是在 Zotero 里看一下基本信息，如年份、类别、文件名等。然后去 OneDrive 里找到文件，打开。虽然操作也没那么复杂，但是这种方式总让人觉得不优美，很麻烦。
正好有同学在 iPad 上使用 <code>Zotero + 坚果云</code>，我就试了一下，然后发现这种方式太漂亮了！直接沦陷，决定放弃原来的方案，转投坚果云。</p>
<h2 id="坚果云配置">坚果云配置</h2>
<p>坚果云 <a href="https://www.jianguoyun.com/s/pricing" target="_blank" rel="noopener noreferrer">免费版</a> 提供每月 1GB 上传和 3GB 下载。算了一下，感觉对于纯文档操作来说，绰绰有余。</p>
<p>本来坚果云的配置非常方便，但是网上的教程不是写的冗长，就是分不清软链接硬链接的关系，让人看了一头雾水。简单的一个过程非得写的那么麻烦，真是蛋疼。本文将准确直白的记录下该过程。</p>
<p>首先注册坚果云账号，这步没什么难度。但是值得注意的是网上有人说使用带符号的邮箱注册的话，在 Zotero 中配置会有问题。
我本人的邮箱不存在该问题，但是还是提醒大家注意一下。</p>
<p>登录之后，点击 <code>账户信息</code>，然后切换到 <code>安全选项</code> 部分，在底部点击<code>添加应用</code>。
然后随便起个名字，就写 <code>Zotero</code> 吧，注意这个名字仅仅是个名字，跟随后的存储目录无关。
然后你会获得一个密码。到此为止，你所拥有的信息有：</p>
<ol>
<li>服务器地址：https://dav.jianguoyun.com/dav/ （界面上就有）</li>
<li>账户：xxx@xxx.xx （就是注册邮箱）</li>
<li>应用密码：xxxxx （就是刚才所获得的密码）</li>
</ol>
<h2 id="zotero-配置">Zotero 配置</h2>
<p>使用这三个信息，你就可以在 <code>Zotero -&gt; Preference -&gt; Sync</code> 页面的 <code>File Syncing</code>部分进行配置。选择 <code>Using WebDAV</code>，然后将上述三条信息填上，然后点击 <code>Verify Server</code>。
理想情况应该显示同步成功。
随后点一下 Zotero 的同步按钮（就是那个绿色的小圆圈箭头）同步下。</p>
<p>多点几次，耐心等等，确认都同步上去了，这个可以通过网页打开坚果云查看，点击 <code>我的文件</code>，就有一个叫 <code>zotero</code> 的文件夹。</p>
<p>待同步之后，还要进行的一个操作就是删除在 Zotero 云盘中占用的空间。
首先打开 <a href="https://www.zotero.org/settings/storage" target="_blank" rel="noopener noreferrer">https://www.zotero.org/settings/storage</a> , 登录。
然后在该页面底部可以看到一个 <code>Purge Storage in My Library</code> 按钮，该按钮将会删除所有的存在 Zotero 云盘中的文件。所以操作之前确定备份好所有的文件！</p>
<p>然后就大功告成了，iPad 和手机端配置类似。</p>]]></description></item><item><title>Python relative import 深入理解</title><link>https://xinyu-yang.github.io/blog/2022/22-05-18_python-import/</link><pubDate>Wed, 18 May 2022 22:05:01 +0800</pubDate><author>作者</author><guid>https://xinyu-yang.github.io/blog/2022/22-05-18_python-import/</guid><description><![CDATA[<p>随着程序的复杂，会逐渐将不同的功能放置在不同的文件中。项目也从简单脚本的单一文件转变为更加复杂的文件结构，这就涉及到不同文件的导入问题。</p>
<p>以前写的程序都比较简单，即使有多个文件，但也是单层次的扁平结构，操作起来也比较简单，尝试一下就可以正确导入。</p>
<p>但是当文件有了更复杂的层次之后，发现文件导入并没有自己想象的那么简单。每次都是盲人摸象般的盲目尝试，直到程序不会报错。靠着这种开盲盒般的操作方式，即使最后得出正确结果，也不知道怎么回事。</p>
<p>也看过一些关于文件导入的文章，但一是没有自己的实际操作；二是很多文章讲的比较肤浅，不涉及本质；甚至有的文章还会给读者错误的导向，害人不浅（这一点后面会说）。</p>
<h2 id="从-modulenotfounderror-说起">从 <code>ModuleNotFoundError</code> 说起</h2>
<p>一般报该错误，常见的有两个原因：</p>
<ol>
<li>如果是第三方包，那么是相应的模块没有安装，直接 <code>pip install *</code> 安装即可。</li>
<li>如果自己写的程序，那么就是包导入的路径不对。本文主要关注的也是该问题。</li>
</ol>
<p>如上所述，如果是第二种情况，即包导入的位置不对。那么我们就应该添加包的查询位置，<code>sys.path</code> 就是用来指定包查找位置的列表。</p>
<p>下面将以下述文件结构举例：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">src
</span></span><span class="line"><span class="cl">	├── foo
</span></span><span class="line"><span class="cl">	│   ├── foo.py
</span></span><span class="line"><span class="cl">	│   ├── bar.py
</span></span><span class="line"><span class="cl">	│   ├── __init__.py
</span></span><span class="line"><span class="cl">	├── hello.py
</span></span><span class="line"><span class="cl">	├── main.py
</span></span></code></pre></td></tr></table>
</div>
</div><p>这里 <code>hello.py</code> 中的代码为：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">helloworld</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;hello world&#34;</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p><code>bar.py</code>中的代码为：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">bar</span><span class="p">:</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;This is in bar&#34;</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>接下来试图从<code>foo.py</code> 中导入该函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="c1"># foo.py</span>
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">hello</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">hello</span><span class="o">.</span><span class="n">helloworld</span><span class="p">()</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>该程序理所当然报 <code>ModuleNotFoundError</code>，这是因为包的位置没有被添加到导入路径中，前面也提到，<code>sys.path</code>其实是一个列表，所以我们只需将需要的路径添加到该列表中即可。接下来修改代码如下（很多博客中写的都是此方法）：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="c1"># foo.py</span>
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">sys</span>
</span></span><span class="line"><span class="cl"><span class="n">sys</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="s2">&#34;..&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">hello</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">hello</span><span class="o">.</span><span class="n">helloworld</span><span class="p">()</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>如果我们在路径 <code>foo</code> 下运行：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ python foo.py
</span></span></code></pre></td></tr></table>
</div>
</div><p>那么程序可以顺利执行。<strong>但是</strong>如果我们在程序根目录下执行：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ python ./foo/foo.py
</span></span></code></pre></td></tr></table>
</div>
</div><p>那么依然会报 <code>ModuleNotFoundError</code> 。经过分析，发现这是因为我们在添加文件路径到 <code>sys.path</code> 的时候，加入的只是相对路径。</p>
<p>而相对路径是相对于现在的执行路径而言的，当前的执行目录为根目录，根目录的上一层当然没有要找的 <code>hello</code>模块，所以程序当然报错。</p>
<p>所以合理的方式是直接导入绝对路径，那么无论在哪里运行，都是可以找到相应的模块的，具体代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="c1"># foo.py</span>
</span></span><span class="line"><span class="cl">import sys, os
</span></span><span class="line"><span class="cl">sys.path.append<span class="o">(</span>os.path.join<span class="o">(</span>sys.path<span class="o">[</span>0<span class="o">]</span>, <span class="s2">&#34;..&#34;</span><span class="o">))</span>
</span></span><span class="line"><span class="cl">import hello
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">hello.helloworld<span class="o">()</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>其中<code>sys.path[0]</code>通过阅读<a href="https://docs.python.org/3/library/sys.html" target="_blank" rel="noopener noreferrer">官方文档</a>可以得知，其代表启动 Python 解释器的脚本的目录路径。</p>
<p>这里就把文件的绝对路径以相对路径（<code>&quot;..&quot;</code>）的方式添加到了查找列表中。添加后的 <code>sys.path</code> 如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="o">[</span><span class="s1">&#39;**/src/foo&#39;</span>, <span class="s1">&#39;/usr/local/lib/python38.zip&#39;</span>, <span class="s1">&#39;/usr/local/lib/python3.8&#39;</span>, <span class="s1">&#39;/usr/local/lib/python3.8/lib-dynload&#39;</span>, <span class="s1">&#39;/home/yang/ML/py4flink/lib/python3.8/site-packages&#39;</span>, <span class="s1">&#39;**/src/foo/..&#39;</span><span class="o">]</span>
</span></span></code></pre></td></tr></table>
</div>
</div><h2 id="相对导入-relative-import">相对导入 Relative Import</h2>
<p>按照上述方式可以将模块整个导入，但是有时候我们并不想直接导入整个包，而只想导入包的一部分，比如 <code>hello.py</code>文件下 <code>helloworld</code> 函数。那么我们那么尝试着只导入该函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="c1"># foo.py</span>
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">sys</span><span class="o">,</span> <span class="nn">os</span>
</span></span><span class="line"><span class="cl"><span class="n">sys</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">path</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s2">&#34;..&#34;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">hello</span> <span class="kn">import</span> <span class="n">helloworld</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">helloworld</span><span class="p">()</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>通过测试发现，不管是在根目录还是在 <code>foo</code>目录下都可以正常运行。</p>
<p>接下来我们尝试着从<code>bar.py</code>中导入<code>bar</code> 函数：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="c1"># foo.py</span>
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">sys</span><span class="o">,</span> <span class="nn">os</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">bar</span> <span class="kn">import</span> <span class="n">bar</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">bar</span><span class="p">()</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>同样，不管从根目录还是从 <code>foo</code> 目录下运行 <code>foo.py</code>都是没有问题的。</p>
<p>此时我们尝试另外一种操作，假设在根目录下的 <code>main.py</code> 文件中需要调用 <code>foo.py</code>中的某个函数 <code>foo</code> ，其代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span><span class="lnt">7
</span><span class="lnt">8
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="c1"># foo.py</span>
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">sys</span><span class="o">,</span> <span class="nn">os</span>
</span></span><span class="line"><span class="cl"><span class="n">sys</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">path</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s2">&#34;..&#34;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">bar</span> <span class="kn">import</span> <span class="n">bar</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">foo</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">    <span class="n">bar</span><span class="p">()</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;This is in foo&#34;</span><span class="p">)</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这是一个很常见的操作，我们需要在 <code>main</code>文件下调用包里的某个文件，然后包里的文件又是相互调用的关系。然后我们尝试在 <code>main</code> 文件中导入该函数，代码如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="c1"># main.py</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">foo</span> <span class="kn">import</span> <span class="n">foo</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">foo</span><span class="o">.</span><span class="n">foo</span><span class="p">()</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>然后程序居然会报如下错误：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"> File <span class="s2">&#34;**src/foo/foo.py&#34;</span>, line 6, in foo
</span></span><span class="line"><span class="cl">    from bar import bar
</span></span><span class="line"><span class="cl">ModuleNotFoundError: No module named <span class="s1">&#39;bar&#39;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>这是为什么呢？按理说 <code>foo.py</code>和 <code>bar.py</code>同属一个目录，直接从本目录下导入应该没有问题吧，为解决该问题，我们先打印出一些信息，在<code>foo.py</code>中添加一些调试代码，同时将导入<code>bar</code>的操作后移：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt"> 1
</span><span class="lnt"> 2
</span><span class="lnt"> 3
</span><span class="lnt"> 4
</span><span class="lnt"> 5
</span><span class="lnt"> 6
</span><span class="lnt"> 7
</span><span class="lnt"> 8
</span><span class="lnt"> 9
</span><span class="lnt">10
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="c1"># foo.py</span>
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">sys</span><span class="o">,</span> <span class="nn">os</span>
</span></span><span class="line"><span class="cl"><span class="n">sys</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">path</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s2">&#34;..&#34;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="k">def</span> <span class="nf">foo</span><span class="p">():</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="s2">&#34;This is in foo&#34;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">path</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="nb">print</span><span class="p">(</span><span class="sa">f</span><span class="s1">&#39;</span><span class="si">{</span><span class="vm">__name__</span><span class="si">}</span><span class="s1">, __file__: </span><span class="si">{</span><span class="vm">__file__</span><span class="si">}</span><span class="s1">, __package__: </span><span class="si">{</span><span class="nb">repr</span><span class="p">(</span><span class="n">__package__</span><span class="p">)</span><span class="si">}</span><span class="s1">&#39;</span><span class="p">)</span>
</span></span><span class="line"><span class="cl">    <span class="kn">from</span> <span class="nn">bar</span> <span class="kn">import</span> <span class="n">bar</span>
</span></span><span class="line"><span class="cl">    <span class="n">bar</span><span class="p">()</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>再次执行 <code>main</code> 程序，在报错之前，打印出如下结果：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="o">[</span><span class="s1">&#39;**/src&#39;</span>, <span class="s1">&#39;/usr/local/lib/python38.zip&#39;</span>, <span class="s1">&#39;/usr/local/lib/python3.8&#39;</span>, <span class="s1">&#39;/usr/local/lib/python3.8/lib-dynload&#39;</span>, <span class="s1">&#39;/home/yang/ML/py4flink/lib/python3.8/site-packages&#39;</span>, <span class="s1">&#39;**/src/..&#39;</span><span class="o">]</span>
</span></span><span class="line"><span class="cl">__main__, __file__: **/src/foo/foo.py, __package__: <span class="s1">&#39;foo&#39;</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>发现导入文件的路径变成了根目录，所以无法找到<code>bar</code>文件的路径了。为了验证该猜想，我们手动在<code>main</code>文件中把<code>bar</code>文件的导入路径加上：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span><span class="lnt">6
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="c1"># main.py</span>
</span></span><span class="line"><span class="cl"><span class="kn">import</span> <span class="nn">os</span><span class="o">,</span> <span class="nn">sys</span>
</span></span><span class="line"><span class="cl"><span class="n">sys</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">append</span><span class="p">(</span><span class="n">os</span><span class="o">.</span><span class="n">path</span><span class="o">.</span><span class="n">join</span><span class="p">(</span><span class="n">sys</span><span class="o">.</span><span class="n">path</span><span class="p">[</span><span class="mi">0</span><span class="p">],</span> <span class="s2">&#34;foo&#34;</span><span class="p">))</span>
</span></span><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">foo</span> <span class="kn">import</span> <span class="n">foo</span>
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl"><span class="n">foo</span><span class="o">.</span><span class="n">foo</span><span class="p">()</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>运行 <code>main</code> 程序，顺利执行！</p>
<p>但是在写程序的时候，我们不可能像这样把所有包中的文件绝对引用路径全都加上。我们还是希望不管被哪个程序导入，包里所有文件的相对引用位置是不变的。</p>
<p>通过阅读官方文档得知，我们可以采用包相对导入来解决这个问题。相对导入的形式类似于<code>bash</code>中的相对路径，通过在包前面加<code>.</code>来表示相对位置，一个代表本目录，两个代表上级目录，三个代表。。。</p>
<p>根据该方案，我们将 <code>foo.py</code>中的导入操作修改如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-python" data-lang="python"><span class="line"><span class="cl"><span class="kn">from</span> <span class="nn">.bar</span> <span class="kn">import</span> <span class="n">bar</span>
</span></span></code></pre></td></tr></table>
</div>
</div><p>再次运行 <code>main</code> 程序，顺利执行！</p>
<p>此时好像一切都没有问题了，然后我们尝试着再次执行 <code>foo.py</code> ，发现居然又报错了，这次错误变成了：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">File <span class="s2">&#34;foo/foo.py&#34;</span>, line 8, in foo
</span></span><span class="line"><span class="cl">    from .bar import bar
</span></span><span class="line"><span class="cl">ImportError: attempted relative import with no known parent package
</span></span></code></pre></td></tr></table>
</div>
</div><p>加上一个点之后居然就导入不了了！经过网上搜索，找到了一些解决方案【<a href="https://stackoverflow.com/a/28154841" target="_blank" rel="noopener noreferrer">1</a>】【<a href="https://iq-inc.com/importerror-attempted-relative-import/" target="_blank" rel="noopener noreferrer">2</a>】。</p>
<p>但是还是不太懂根本原因，后来看了<a href="https://docs.python.org/3/reference/import.html" target="_blank" rel="noopener noreferrer">官方文档</a>和<a href="https://stackoverflow.com/a/21233334" target="_blank" rel="noopener noreferrer">该回答</a>中关于<code>__package__</code>变量的解释，我才大概搞明白是怎么回事。其中一些重要的摘录如下：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span><span class="lnt">5
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-html" data-lang="html"><span class="line"><span class="cl">__package__:
</span></span><span class="line"><span class="cl">...
</span></span><span class="line"><span class="cl">This attribute is used instead of __name__ to calculate explicit relative imports for main modules, as defined in PEP 366. It is expected to have the same value as __spec__.parent.
</span></span><span class="line"><span class="cl">
</span></span><span class="line"><span class="cl">Changed in version 3.6: The value of __package__ is expected to be the same as __spec__.parent.
</span></span></code></pre></td></tr></table>
</div>
</div><p>大概意思就是该变量用于计算相对导入的位置，并且该变量的值必须和<code>__spec__.parent</code>的值相同。</p>
<p>根据上文可知，当我们执行<code>main.py</code>的时候，我们所打印出的<code>__package__</code>值为<code>'foo'</code> 而当我们单独执行 <code>foo.py</code>的时候，其打印出的值为：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">__main__, __file__: foo/foo.py, __package__: None
</span></span></code></pre></td></tr></table>
</div>
</div><p>所以我认为根本的原因是：当单独执行<code>foo.py</code>的时候，其所在目录下的文件并不被当作 python module，而只是被当成是普通的脚本进行执行。因此相应的<code>__package__</code>值为<code>None</code> ，进而进行relative import的时候，因不满足上述条件，所以报错。</p>
<p>而当从<code>main.py</code>中导入的时候，<code>foo.py</code>目录中的文件都被当成是<code>foo</code>包的一部分，所以可以使用relative import导入成功。</p>
<p>那么能不能以模块的方式运行<code>foo.py</code>呢？答案是可以的，只需要在执行的时候加上<code>-m</code>选项，比如：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl">$ python -m foo.foo
</span></span></code></pre></td></tr></table>
</div>
</div><p>那么<code>foo.py</code>就会被当成一个模块来执行。同时我还从<a href="https://stackoverflow.com/a/28151907" target="_blank" rel="noopener noreferrer">该回答</a>中学到一种方式：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-bash" data-lang="bash"><span class="line"><span class="cl"><span class="k">if</span> <span class="nv">__name__</span> <span class="o">==</span> <span class="s1">&#39;__main__&#39;</span>:
</span></span><span class="line"><span class="cl">    from bar import bar
</span></span><span class="line"><span class="cl"><span class="k">else</span>:
</span></span><span class="line"><span class="cl">    from .bar import bar
</span></span></code></pre></td></tr></table>
</div>
</div><p>这样就可以避免出错了。</p>
<p>至此，大功告成！</p>
<h2 id="总结">总结</h2>
<p>最后说些总结：</p>
<ol>
<li>参考<a href="https://iq-inc.com/importerror-attempted-relative-import/" target="_blank" rel="noopener noreferrer">该文</a>，除<code>main.py</code>等少数包之外，尽量将所有被调用的文件组织成包的形式。</li>
<li>尽量采用<code>import</code>直接导入本地文件，而不是<code>from * import *</code></li>
<li>如果一定要使用<code>from * import *</code>，对于相同路径下的文件，一定要根据是否封装为模块选择合适的导入方式，或者是像上述所说，加上一个判断。</li>
</ol>]]></description></item><item><title>Zotero 配置记录（一：OneDrive 软链接）</title><link>https://xinyu-yang.github.io/blog/2022/22-02-08_zotero-config/</link><pubDate>Tue, 08 Feb 2022 22:21:16 +0800</pubDate><author>作者</author><guid>https://xinyu-yang.github.io/blog/2022/22-02-08_zotero-config/</guid><description><![CDATA[<h2 id="zotero-配置记录onedrive-软链接">Zotero 配置记录（OneDrive 软链接）</h2>
<p>随着所读论文的增多，渐渐觉得有必要对读过的论文进行整理归类。而之前所用的方法可以称之为“文件夹管理”，即通过文件夹对论文进行分类存放。
但感觉这种方式不够灵活专业，更重要的是在写论文的时候还得一个个手动查找添加 bib 文件。
工具都是为需求而生的，以前没读过几篇论文的时候一直 get 不到文献管理工具的意义。
待我尝试之后，才发现该类工具的强大之处。</p>
<p>我最开始尝试的是 EndNote。原因是以前听说过该工具非常强大，并且我们学校恰好有正版软件。
于是很快我就从学校网站上下载了该软件。鼓捣了一会愣是没搞明白怎么使用，从网上看了一些教程，也还是一头雾水。
按理来说，除了非常专业的工具外，对于经常使用各种软件的我，一般的软件不至于连功能都看不懂。
这对我来说是个很大的打击。</p>
<p>我本人有一个习惯，就是选择某个选项之前，即使是某类软件的选择，也会进行大量的调研，读各种博客经验分享，甚至是实际尝试，最后做出选择。
读了一些网上的帖子之后，我将目光锁定到了 Zotero 和 Mendeley 上。</p>
<ul>
<li>Zotero 开源免费（好印象），易用，但同步空间较少（只有 300M）</li>
<li>Mendeley 闭源免费，易用，空间较多 （2GB）</li>
</ul>
<p>经过衡量我决定采用 Zotero + Onedrive 的方式，Zotero 进行文献管理，Onedrive 进行文件同步，Nice! （当然其他的网盘如 Dropbox、GoogleDrive 也适用）</p>
<p>经过实际尝试之后，发现 Zotero 相对于 EndNote 操作简单直观，真是好用太多了。
以下是相关配置：</p>
<div class="details admonition tips open">
        <div class="details-summary admonition-title">
            <i class="icon fas fa-pencil-alt fa-fw"></i>NOTE<i class="details-icon fas fa-angle-right fa-fw"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content">不同设备的语言设置务必相同</div>
        </div>
    </div>
<h3 id="zotero-sync">Zotero Sync</h3>
<p>链接所注册账户，对文件同步进行简单的设置，具体步骤：</p>
<p>打开 Edit -&gt; Zotero Preferences -&gt; Sync</p>
<ul>
<li>Settings -&gt; Data Syncing: 链接账户</li>
<li>Settings -&gt; File Syncing -&gt; Sync attachment files in My Library using: <code>Zotero</code>: True</li>
</ul>
<h3 id="zotfile-插件">ZotFile 插件</h3>
<p>该插件可以将所导入的 pdf 等格式的文件自动归类到所设置的目标目录。对我来说，目标目录是 Onedrive 的同步目录。</p>
<p>下载：从<a href="http://zotfile.com/#how-to-install--set-up-zotfile" target="_blank" rel="noopener noreferrer">该地址</a>下载</p>
<p>安装：Tools -&gt; Add-ons -&gt; ⚙(Install Add-on From File&hellip;)</p>
<p>相关配置：
打开 Edit -&gt; Zotero Preferences
打开 Zotero -&gt; Preferences (MacOS)</p>
<ol>
<li>Advanced
<ul>
<li>Files and Folders -&gt; Base directory: <code>E:\OneDrive\ZotFile</code></li>
<li>Files and Folders -&gt; Base directory: <code>/Users/[username]/OneDrive/ZotFile</code> (MacOS)</li>
<li>Files and Folders -&gt; Data Directory Location -&gt; Custom: <code>E:\Zotero</code></li>
<li>Files and Folders -&gt; Data Directory Location -&gt; Custom: <code>/Users/[username]/Zotero</code> (MacOS 默认)</li>
</ul>
</li>
</ol>
<p>以上设置是帮我们附件的基路径和文件存储目录。
很多软件安装后都需要设置一个默认目录来保存相应数据，而 <code>Data Directory Location</code> 就是这个作用，它将保存 Zotero 所用到的所有数据。</p>
<p>而 <code>Base directory</code> 则是帮我确定一个附件的基路径。我们可以将附件的地址分为两部分：<code>基地址 + 相对地址</code>。
相对地址一般是我们的文件存储结构，其一般保持不变。
而基地址就可以根据需求进行不同的配置，比如在不同的电脑上对于该路径的设置不同。
这种 <code>基地址 + 相对地址</code> 的方式大大增加了灵活性。</p>
<p>打开 Tools -&gt; ZotFile Preferences</p>
<ol>
<li>General Settings:
<ul>
<li>Source Folder for Attaching New Files: <code>E:\Zotero\storage</code></li>
<li>Source Folder for Attaching New Files: <code>/Users/[username]/Zotero/storage</code> (MacOS)</li>
<li>Location of Files -&gt; Custom Location: <code>E:\OneDrive\ZotFile</code></li>
<li>Location of Files -&gt; Custom Location: <code>/Users/[username]/OneDrive/ZotFile</code> (MacOS)</li>
<li>Location of Files -&gt; Use subfolder defined by <code>\%y\%T</code></li>
</ul>
</li>
</ol>
<p>这里的 <code>Source Folder for Attaching New Files</code> 指的是需要被转移的附件的源路径。这个路径是位于我们上面所设置的 <code>Data Directory Location</code> 下的。</p>
<p>有了源路径，那么目的路径呢? 目的路径就是 <code>Custom Location</code> 所配置的内容。这个恰好也是我们上面所述的 <code>基地址</code>。
因为文件被转移到了该文件夹下，所以我们当然要在这里找到文件。</p>
<ol start="2">
<li>Renaming Rules:
<ul>
<li>Renaming Format -&gt; Use Zotero to Rename: <code>False</code></li>
<li>Renaming Format -&gt; Format for all Item Types: <code>{%a_}{%j_}{%y_}{%t}</code></li>
<li>Renaming Format -&gt; Format for Patents: <code>{%a_}{%y_}{%t}</code></li>
<li>Additional Setting -&gt; Delimiter: <code>_</code></li>
</ul>
</li>
</ol>
<p>关于这部分设置可以参考</p>
<ul>
<li><a href="https://www.nrel.colostate.edu/set-up-best-reference-manager/" target="_blank" rel="noopener noreferrer">https://www.nrel.colostate.edu/set-up-best-reference-manager/</a></li>
<li><a href="https://mp.weixin.qq.com/s/0heWcOlwgrF6GHmPTc-poA" target="_blank" rel="noopener noreferrer">https://mp.weixin.qq.com/s/0heWcOlwgrF6GHmPTc-poA</a></li>
</ul>
<h3 id="better-bibtex-插件">Better bibtex 插件</h3>
<p>该插件完善了 Zotero 关于 bib 格式设置上的缺陷，非常好用。</p>
<p>下载：从<a href="https://retorque.re/zotero-better-bibtex/" target="_blank" rel="noopener noreferrer">该地址</a>下载，安装方式与上述相同</p>
<p>相关配置：打开 Edit -&gt; Zotero Preferences -&gt; Better BibTeX</p>
<ol>
<li>Citation keys
<ul>
<li>Citation key format: <code>auth.lower+year+shorttitle(1).lower</code></li>
<li>Keeping citation keys unique -&gt; On conflict &hellip;: <code>postfixed</code></li>
</ul>
</li>
<li>Exprot
<ul>
<li>Fields -&gt; When a reference &hellip;: <code>DOI</code></li>
<li>Fields -&gt; Fields to omit &hellip;: <code>abstract,file,note,keywords</code></li>
</ul>
</li>
</ol>
<p>关于这部分可参考上述下载地址。</p>
<h3 id="delitem-插件">delitem 插件</h3>
<p>使用以上方法链接附件，在 Zotero 删除文件的时候并不会删除其所链接的文件，这显然不是我们想要的。
如果想要删除，还要自己定位到文件真正保存的文件夹，执行手动删除。幸运的是现在已经有插件可以帮我们简化该过程。</p>
<p>该插件可以删除链接文件：<a href="https://github.com/redleafnew/delitemwithatt" target="_blank" rel="noopener noreferrer">下载</a>，是 ZotFile 插件的一个功能补充。
该插件不需要额外的设置，直接安装即可使用。
其功能主要体现在：选中某条目右键，显示删除附件等选项。</p>]]></description></item><item><title>2022 年的第一场雪</title><link>https://xinyu-yang.github.io/blog/2022/22-01-26_the-first-snow/</link><pubDate>Wed, 26 Jan 2022 19:16:14 +0800</pubDate><author>作者</author><guid>https://xinyu-yang.github.io/blog/2022/22-01-26_the-first-snow/</guid><description><![CDATA[<meting-js auto="https://music.163.com/#/song?id=77437" theme="#448aff" autoplay="false"></meting-js>
<p>这首歌应该是我这代人所接触到的第一代神曲，很难想象它已经二十年了。每到下雪的时候，尤其是第一场雪的时候，总是能够想起这首歌。
恰逢最近北京下雪，重听此歌，感觉熟悉又生疏。
有一个模糊地场景浮现在脑海里，临近春节、冰雪未融，一群已放假的小孩满心欢喜地结伴去镇上赶会。
天气正冷，但他们呼着白气说着笑着，一路走走停停，甚至还会微微出汗。
到了集会上，卖东西的小贩、买年货的附近村民，或者是同时具备两种身份的人们熙熙攘攘，一派热闹喜庆。
一条街上往往会有一两个大超市或者时髦的店面，在门口放一个大音箱，我第一次听到这首歌或许就是从这些大音箱里。</p>
<p>说是赶会，但到了镇上也就是重点关注几个卖爆竹的小摊，
仔细盘算着家长给的钱怎么花，该买划炮？还是买二踢脚？或者是买气 gua（得）？[1]。
随着我们慢慢长大，发现每一年爆竹摊上的花样都越来越多。
后来有小蜜蜂，就是那种不会爆炸，而是在地上飞快地旋转，甚至还能飞上天的东西。
还有烟雾弹之类的，现在想想这类爆竹倒没啥意思，只会冒烟。但是当时图新鲜，感觉还是挺好玩的。</p>
<p>咳咳~ 话题逐渐跑偏，重新说回下雪。</p>
<p>许久未见下雪，也即是对雪花的期待最强的时候，如果能迎来一场酣畅淋漓的大雪，会让人开心的手舞足蹈。
这种说法可能有些夸张，我不知道是不是所有人都跟我一样喜欢雪。当然，家里常年下雪的极可能除外。</p>
<p>在这场雪之前，“料事如神” 的气象台自然也早早地预见了这场持续几天的大降雪。
第一天，满怀期待，但不出所料，雪下的果然不大。
稀稀拉拉飘了一天，地上也不过薄薄的一层。第二天也差不多。</p>
<p><figure><a class="lightgallery" href="https://s2.loli.net/2022/01/26/WGSMNTEd9FpZo3c.jpg" title="https://s2.loli.net/2022/01/26/WGSMNTEd9FpZo3c.jpg" data-thumbnail="https://s2.loli.net/2022/01/26/WGSMNTEd9FpZo3c.jpg" data-sub-html="<h2>紫操傍晚雪景</h2>">
        
    </a><figcaption class="image-caption">紫操傍晚雪景</figcaption>
    </figure></p>
<p>第三天早上发现雪还在下，窗外的空调外机上已经厚厚一层雪，“总算是下大了！”。
于是怀着激动的心情，我马上起床、洗漱、出门，然后开心的骑着自行车去了学校。
到主楼门口发现地上雪也同样很厚。于是准备先去实验室看看有没有人，然后找人一块去堆雪人。</p>
<p>到了紫操之后，发现操场已经覆盖了厚厚一层白雪。再加上已是年末，学校里人少，雪地上少了很多踩踏的痕迹。</p>
<p><figure><a class="lightgallery" href="https://s2.loli.net/2022/01/26/5MDNf4nJVpBwuxc.jpg" title="https://s2.loli.net/2022/01/26/5MDNf4nJVpBwuxc.jpg" data-thumbnail="https://s2.loli.net/2022/01/26/5MDNf4nJVpBwuxc.jpg" data-sub-html="<h2>紫操雪景</h2>">
        
    </a><figcaption class="image-caption">紫操雪景</figcaption>
    </figure></p>
<p>好美一场雪，雪大，风小，雪花飘然落下，很富有诗意。
突然想到小时候背的一篇文言文，其中有一句 “未若柳絮因风起”，确是此情此景的准确描述。
文中还有另外一句 “撒盐空中差可拟”，想来我也确实遇到过这样的雪，寒风刺骨，细小的雪粒如刀子一般打在脸上。
这样的雪想必是不太讨人喜欢。</p>
<p>走到操场上，踩在雪地上咯吱作响，非常舒适。
书包往足球框旁边一放，很快就开始动手堆雪人。
开始上手之后，发现滚雪球比我想得难多了。雪球并没有如我想的那样，放在地上一滚就能沾上很多雪，进而逐渐变大。
该开始堆的时候，所有的雪几乎都是用手糊上去的。待我感觉雪球已经差不多大小的时候，就开始在地上滚。
但是可能是雪太蓬松的缘故，雪球的重量还是不足以把雪沾上来。于是就不得不一直用手追按着雪球来回滚动，就像在地上搓泥丸一样（伸腿瞪眼丸）。
期间还有一个大妈端着手机走来，隐隐约约听到她说了句“真是个老小孩”，额~ <strong>老</strong>小孩~</p>
<p>哎，看来自己真的是老了呀😟</p>
<p>滚了一上午，感觉筋疲力尽，才推了两个半大的雪球，不过还好比例适中。于是就准备把他们放在一块，堆成个雪人的形状，如下图所示：</p>
<!--![](https://s2.loli.net/2022/01/26/9ntqwLlVd8eMBvW.jpg "雪人")-->
<figure><a class="lightgallery" href="https://s2.loli.net/2022/01/26/9ntqwLlVd8eMBvW.jpg" title="https://s2.loli.net/2022/01/26/9ntqwLlVd8eMBvW.jpg" data-thumbnail="https://s2.loli.net/2022/01/26/9ntqwLlVd8eMBvW.jpg" data-sub-html="<h2>雪人</h2>">
        
    </a><figcaption class="image-caption">雪人</figcaption>
    </figure>
<p><em>[1] 就是穿云箭，具体发音是这个，但是不太清楚是哪个字，“**得”是我们那个方言中常用的说法，如“面条得”、“瓜子得”&hellip;</em></p>]]></description></item><item><title>Markdown 中的数学公式</title><link>https://xinyu-yang.github.io/blog/2021/21-12-04_math-in-markdown/</link><pubDate>Sat, 04 Dec 2021 00:11:45 +0800</pubDate><author>作者</author><guid>https://xinyu-yang.github.io/blog/2021/21-12-04_math-in-markdown/</guid><description><![CDATA[<p>本文主要记录在使用不同的主题时，所遇到的有关 markdown 中公式渲染的问题。</p>
<p>首先是 even 主题，该主题使用的是 mathjax 进行公式的渲染，经过网上了解， mathjax 是一个很成熟的解决方案，所以其对数学公式的支持还是很完善的，但是在使用较复杂的数学公式环境过程中还是遇到了一个问题，如:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-markdown" data-lang="markdown"><span class="line"><span class="cl">\begin{align}
</span></span><span class="line"><span class="cl">x <span class="err">&amp;</span>= y + 1 \\
</span></span><span class="line"><span class="cl">y <span class="err">&amp;</span>= z + 2
</span></span><span class="line"><span class="cl">\end{align}
</span></span></code></pre></td></tr></table>
</div>
</div><p>在 $\LaTeX$ 中是没有问题的，但是在 hugo 就无法被正确渲染，只有将换行符<code>\\</code>更改为<code>\\\\</code>才能正常工作，好像看到网上有相关的讨论（没有记录），说导致该问题的原因是 markdown 编译器在进行解析的时候会将第一斜杠解释为<em>转义</em>，那么最后的结果是只剩一个斜杠，所以如果想让其最后仍然有两个斜杠，则不得不用四个斜杠。虽说敲四个斜杠是麻烦了点，但是好歹问题算是大概解决了。</p>
<p>后来试用 CodeIT 主题时则出现了更严重的问题，主要是因为该主题使用的是据说是性能更好的 $KaTeX$ 渲染器。该渲染器作为托管在 github 的开源项目还是挺受欢迎的，但是 katex 对于公式的支持就不那么完善了，截止到目前的最新版本 0.13.0，刚能够支持诸如<code>align,align*</code>等环境。而 CodeIT 使用的仍然是 0.11.1 的老版本，但这还不是主要问题，主要问题是原本在 mathjax 中可行的方案在 katex 中不可行了，比如根据<a href="https://katex.org/docs/0.11.1/supported.html" target="_blank" rel="noopener noreferrer">文档</a> katex v0.11.1 中是支持<code>aligned</code>环境的，但是以下代码并不能够被正确渲染：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-markdown" data-lang="markdown"><span class="line"><span class="cl">\begin{aligned}
</span></span><span class="line"><span class="cl">x <span class="err">&amp;</span>= y + 1 \\\\
</span></span><span class="line"><span class="cl">y <span class="err">&amp;</span>= z + 2
</span></span><span class="line"><span class="cl">\end{aligned}
</span></span></code></pre></td></tr></table>
</div>
</div><p>该代码可以在 even 主题下正常工作，但是无法在 CodeIT 在工作，经网上搜索，发现了该<a href="https://github.com/halogenica/beautifulhugo/issues/183" target="_blank" rel="noopener noreferrer">解决方案</a>，经该方案介绍，使用如下代码可正常工作：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-markdown" data-lang="markdown"><span class="line"><span class="cl">\begin{aligned}
</span></span><span class="line"><span class="cl">x <span class="err">&amp;</span>= y + 1 \cr
</span></span><span class="line"><span class="cl">y <span class="err">&amp;</span>= z + 2
</span></span><span class="line"><span class="cl">\end{aligned}
</span></span></code></pre></td></tr></table>
</div>
</div><p>其效果为：
$$
\begin{aligned}
x &amp;= y + 1 \cr
y &amp;= z + 2
\end{aligned}
$$</p>
<p>主要改动为将斜杠更换为<code>\cr</code>，经测试可以正常工作，然后将该方式在 even 主题中测试也可以工作，所以就计划采用这种方式来代替双斜杠的功能，虽然感觉像是最后对问题的妥协，但是好歹是解决了该问题😂</p>
<p>后来有对问题做进一步的探索，做法是在浏览器中查看网页的源代码，我发现使用斜杠做为换行符的方式都会在公式行的最后引入一个<code>&lt;br&gt;</code>标签，如下所示：</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span><span class="lnt">2
</span><span class="lnt">3
</span><span class="lnt">4
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-html" data-lang="html"><span class="line"><span class="cl">\begin{aligned}
</span></span><span class="line"><span class="cl">x <span class="ni">&amp;amp;</span>= y + 1 \\ <span class="p">&lt;</span><span class="nt">br</span><span class="p">&gt;</span>
</span></span><span class="line"><span class="cl">y <span class="ni">&amp;amp;</span>= z + 2
</span></span><span class="line"><span class="cl">\end{aligned}
</span></span></code></pre></td></tr></table>
</div>
</div><p>具有标签的代码在使用 mathjax 渲染器的时候是可以被正常渲染的，但是在 katex 中却不行。而使用<code>\cr</code>进行换行则不会引入<code>&lt;br&gt;</code>标签，因此在 katex 中可用。
最后附上将换行符更改为<code>\cr</code>的命令:</p>
<div class="highlight"><div class="chroma">
<table class="lntable"><tr><td class="lntd">
<pre tabindex="0" class="chroma"><code><span class="lnt">1
</span></code></pre></td>
<td class="lntd">
<pre tabindex="0" class="chroma"><code class="language-shell" data-lang="shell"><span class="line"><span class="cl">sed -i <span class="s1">&#39;s/\\\\\\\\/\\cr/&#39;</span> <span class="o">[</span>blogname<span class="o">]</span>.md
</span></span></code></pre></td></tr></table>
</div>
</div><p>&mdash;&mdash;&mdash;&mdash;21/04/08更新&mdash;&mdash;&mdash;&ndash;</p>
<p>除上述所示问题外，今天又遇到了另外一个问题，那就是在公式中使用特殊字符（如%）时需要进行转义，一般写为<code>\%</code>，但是这又会遇到一个问题，就是在$符号之间的字符不能够像在 ` 符号中那样被免于转义。也就是说<code>\%</code>中的斜杠会在markdown解析的过程中解析为转义字符，因此到公式解析器的时候剩下的就只剩一个%符号了，所以需要使用两个符号才行。关于这个问题，感觉主要问题还是在markdown解析器那里没有执行正确的解析。当然，以上只是我的猜想，有时间我会去验证的。</p>
<p>知道问题之后的解决方式呢？如果实在不得不用特殊字符的转义，那就使用上述方法，可以解决。如果不是必要，比如我这里就是将%作为模运算符号，其实math里有专门的符号<code>\mod</code>表示该含义，所以出于兼容性期间，决定使用<code>\mod</code>符号，因为万一哪一天markdown解析器可以正常解析了，岂不是还要把两个斜线换成一个。</p>
<p>同时这里有一个总结：
<div class="details admonition tip open">
        <div class="details-summary admonition-title">
            <i class="icon fas fa-lightbulb fa-fw"></i>总结<i class="details-icon fas fa-angle-right fa-fw"></i>
        </div>
        <div class="details-content">
            <div class="admonition-content"><strong>在markdown的公式环境中尽量减少使用转义符👉<code>\</code>👈</strong></div>
        </div>
    </div></p>]]></description></item><item><title>乘坐北京地铁有感</title><link>https://xinyu-yang.github.io/blog/2021/21-11-24_beijing-subway/</link><pubDate>Wed, 24 Nov 2021 20:21:38 +0800</pubDate><author>作者</author><guid>https://xinyu-yang.github.io/blog/2021/21-11-24_beijing-subway/</guid><description><![CDATA[<p>今天再次有幸乘坐北京早上八点左右的地铁，有一些想法，本文进行记录。</p>
<p>之所以强调北京早上八点的地铁，因为这个时候的地铁不同一般时间，具有鲜明的特点。如果用一个字来形容的话，那就是“快”。不光地铁快，人也快。
人是怎么个快法呢？就是地铁站里的乘客大多都是在小跑，而不是普通的走路甚至是快走。此时的乘客就像是灾难电影中慌忙逃生的人群。如果是初次置身于此情此景，恐怕会感到惊讶。</p>
<p>仍记得 17 年刚来北京那会，年少无知，坐扶梯的时候站在了扶梯左侧，受到过几次不耐烦的 “借过一下” 甚至是抱怨。
我刚开始还觉得有点奇怪，后来渐渐习惯了， 便察觉自己之前的少不更事，并养成了坐扶梯一定站在右边的习惯，或者干脆加入他们，在左侧走，体验 <em>速度 x2</em>。</p>
<p>这个习惯是在北京养成的，以至于后来即使在其他城市坐地铁时也是如此。即使这些城市没有人在扶梯上走，事实上北京也是我迄今为止唯一经历过此情此景的城市。当然，原因可能是我并没有经历过其他城市的早高峰。</p>
<p>其实三年前有过一段时间的工作经历，也是每天都在赶早高峰，但是这次经历似乎有不一样的体验。或许是自己三年来对这个场景变得陌生，也或许是自己当时没有时间静心观察这些。
不知为何，此时心里突然有了一个令自己哭笑不得的想法：希望以后自己能做一个走着坐地铁的人。</p>
<p>今天在做第一班车的时候空间还算比较富裕，但是当转到另外一条线时，情况就发生了变化。看着停靠的车厢里挤满了人，本以为会有好多人下车，从而能够给我们下面这帮排队的人腾出点位置。可没曾想居然一个下的都没有，看着队列前面还有好几个人，就想着等前面几个上去，然后自己等下一班吧。
结果等我前面的人都走强行挤上去之后，我后面的人也跃跃欲试，此时上不上车已由不得我了，因此只能拼命挤上车，为了不让门夹住书包，只得拼命抓紧扶手把自己的身体往里挤。</p>
<p>还好等到门顺利关上，我就可以稍微放松，把身体倚在门上。很快到了下一站，可怕的是这种情况还在重复，又挤上来两个大姐。我本来握在侧边扶手上的手被大姐建议“抬一下”以便她能上来，然后我就把手以一个奇怪的角度握住上方的扶杆。
因为姿势别扭且费力，我就想反正都几乎动不了了，也就没必要扶什么扶手了。想到这里我自认为机智地把手松开，然后发现我的手似乎没地可放，垂直放下去是不可能的，因为此时很难通过那道人与人之间紧贴而形成的屏障。
所以我就又把手搭在了扶手上，这下扶手可真的被用来 <strong>“扶”</strong> 手了。</p>
<p>当我在车厢里无聊的左顾右看的时候，我注意到其实大多数人都很专注，有的在专心刷短视频，有的在看剧，甚至还有的在玩连连看。
总之，为了不浪费在车上的时间，社畜们各显神通。令人惊奇的是，在这种环境下，他们居然表现出了就像在自家沙发上玩手机一样的舒适感，人类超强的适应能力再次得到了证明。</p>
<p>随后我又想到了一个问题，他们是怎么把手机拿出来的呢？我感觉比较可能的答案就是：他们在上车的时候手机就一直拿在手里，高举着手机走进车厢，然后高举着下车。就像虔诚的信徒将十字架举过头顶，从而彰显着所持物品的无上地位。
想到这里感觉还挺有意思，似乎干愣着也没那么无聊了。</p>
<p>北京给我最深的印象不是遍布的古迹、公园，也不是繁华的商圈，而是北京的 <strong>“快”</strong> 和 <strong>“挤”</strong>。不同的人肯定感触不同，而匆忙拥挤的生活节奏可能就是我这个阶层的人在这个城市所能拥有的最多的感受吧。</p>]]></description></item></channel></rss>