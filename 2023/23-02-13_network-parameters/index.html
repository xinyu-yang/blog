<!doctype html><html lang=zh-cn><head><meta charset=utf-8><meta name=viewport content="width=device-width,initial-scale=1"><meta name=robots content="noodp"><meta http-equiv=x-ua-compatible content="IE=edge, chrome=1"><title>网络参数RSS、RPS、RFS、aRFS 学习总结 - 麋鹿博客 (Elk blog) | 一个分享知识和乐趣的地方</title><meta name=description content="麋鹿博客 -- 一个分享知识和乐趣的地方"><meta property="og:title" content="网络参数RSS、RPS、RFS、aRFS 学习总结"><meta property="og:description" content="最近学习，发现网络参数（包括内核参数、网卡参数）非常多，搞得人云里雾里，非常头大。因此打算在这里对学习到的东西做个总结，方便知识的梳理和以后的复习。"><meta property="og:type" content="article"><meta property="og:url" content="https://xinyu-yang.github.io/blog/2023/23-02-13_network-parameters/"><meta property="og:image" content="https://xinyu-yang.github.io/logo.png"><meta property="article:section" content="posts"><meta property="article:published_time" content="2023-02-13T12:37:39+08:00"><meta property="article:modified_time" content="2023-02-13T21:07:20+08:00"><meta name=twitter:card content="summary_large_image"><meta name=twitter:image content="https://xinyu-yang.github.io/logo.png"><meta name=twitter:title content="网络参数RSS、RPS、RFS、aRFS 学习总结"><meta name=twitter:description content="最近学习，发现网络参数（包括内核参数、网卡参数）非常多，搞得人云里雾里，非常头大。因此打算在这里对学习到的东西做个总结，方便知识的梳理和以后的复习。"><meta name=application-name content="麋鹿博客"><meta name=apple-mobile-web-app-title content="麋鹿博客"><meta name=theme-color content="#ffffff"><meta name=msapplication-TileColor content="#da532c"><link rel="shortcut icon" type=image/x-icon href=/favicon.ico><link rel=icon type=image/png sizes=32x32 href=/favicon-32x32.png><link rel=icon type=image/png sizes=16x16 href=/favicon-16x16.png><link rel=apple-touch-icon sizes=180x180 href=/apple-touch-icon.png><link rel=mask-icon href=/safari-pinned-tab.svg color=#5bbad5><link rel=manifest href=/site.webmanifest><link rel=canonical href=https://xinyu-yang.github.io/blog/2023/23-02-13_network-parameters/><link rel=prev href=https://xinyu-yang.github.io/blog/2023/23-02-13_binding-cpu-irq-queue/><script async src=//busuanzi.ibruce.info/busuanzi/2.3/busuanzi.pure.mini.js></script><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/normalize.css@8.0.1/normalize.min.css><link rel=stylesheet href=/blog/css/style.min.457b41f3877ae4698fed78d872da4da64fa4f2b3d27162707df2dcb9141a227f.css integrity="sha256-RXtB84d65GmP7XjYctpNpk+k8rPScWJwffLcuRQaIn8="><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/@fortawesome/fontawesome-free@5.13.0/css/all.min.css><link rel=stylesheet href=https://cdn.jsdelivr.net/npm/animate.css@3.7.2/animate.min.css><script type=application/ld+json>{"@context":"http://schema.org","@type":"BlogPosting","headline":"网络参数RSS、RPS、RFS、aRFS 学习总结","inLanguage":"zh-CN","mainEntityOfPage":{"@type":"WebPage","@id":"https:\/\/xinyu-yang.github.io\/blog\/2023\/23-02-13_network-parameters\/"},"image":["https:\/\/xinyu-yang.github.io\/blog\/images\/avatar.png"],"genre":"posts","keywords":"arch","wordcount":3373,"url":"https:\/\/xinyu-yang.github.io\/blog\/2023\/23-02-13_network-parameters\/","datePublished":"2023-02-13T12:37:39+08:00","dateModified":"2023-02-13T21:07:20+08:00","license":"This work is licensed under a Creative Commons Attribution-NonCommercial 4.0 International License.","publisher":{"@type":"Organization","name":"Xinyu Yang","logo":"https:\/\/xinyu-yang.github.io\/blog\/images\/avatar.png"},"author":{"@type":"Person","name":"Xinyu Yang"},"description":""}</script></head><body header-desktop=fixed header-mobile=auto><script type=text/javascript>(window.localStorage&&localStorage.getItem("theme")?localStorage.getItem("theme")==="dark":"auto"==="auto"?window.matchMedia("(prefers-color-scheme: dark)").matches:"auto"==="dark")&&document.body.setAttribute("theme","dark")</script><div id=mask></div><div class=wrapper><header class=desktop id=header-desktop><div class=header-wrapper><div class=header-title><a href=/blog/ title="麋鹿博客 (Elk blog) | 一个分享知识和乐趣的地方"><img class="lazyload logo" src=/blog/svg/loading.min.svg data-src=/blog/images/avatar.png data-srcset="/blog/images/avatar.png, /blog/images/avatar.png 1.5x, /blog/images/avatar.png 2x" data-sizes=auto alt=/blog/images/avatar.png title=/blog/images/avatar.png>麋鹿博客</a></div><div class=menu><div class=menu-inner><a class=menu-item href=/blog/posts/ title=文章列表>文章 </a><a class=menu-item href=/blog/categories/>分类 </a><a class=menu-item href=/blog/tags/>标签 </a><a class=menu-item href=/blog/about/>关于 </a><a class=menu-item href=https://github.com/xinyu-yang/blog title=GitHub rel="noopener noreferrer" target=_blank><i class='fab fa-github fa-fw'></i> </a><span class="menu-item delimiter"></span><a href=javascript:void(0); class="menu-item language" title=选择语言>简体中文<i class="fas fa-chevron-right fa-fw"></i>
<select class=language-select id=language-select-desktop onchange="location=this.value"><option value=/blog/2023/23-02-13_network-parameters/ selected>简体中文</option></select>
</a><span class="menu-item search" id=search-desktop><input type=text placeholder=搜索文章标题或内容... id=search-input-desktop>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-desktop title=搜索><i class="fas fa-search fa-fw"></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-desktop title=清空><i class="fas fa-times-circle fa-fw"></i></a>
<span class="search-button search-loading" id=search-loading-desktop><i class="fas fa-spinner fa-fw fa-spin"></i></span>
</span><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题><i class="fas fa-adjust fa-fw"></i></a></div></div></div></header><header class=mobile id=header-mobile><div class=header-container><div class=header-wrapper><div class=header-title><a href=/blog/ title="麋鹿博客 (Elk blog) | 一个分享知识和乐趣的地方"><img class="lazyload logo" src=/blog/svg/loading.min.svg data-src=/blog/images/avatar.png data-srcset="/blog/images/avatar.png, /blog/images/avatar.png 1.5x, /blog/images/avatar.png 2x" data-sizes=auto alt=/blog/images/avatar.png title=/blog/images/avatar.png>麋鹿博客</a></div><div class=menu-toggle id=menu-toggle-mobile><span></span><span></span><span></span></div></div><div class=menu id=menu-mobile><div class=search-wrapper><div class="search mobile" id=search-mobile><input type=text placeholder=搜索文章标题或内容... id=search-input-mobile>
<a href=javascript:void(0); class="search-button search-toggle" id=search-toggle-mobile title=搜索><i class="fas fa-search fa-fw"></i></a>
<a href=javascript:void(0); class="search-button search-clear" id=search-clear-mobile title=清空><i class="fas fa-times-circle fa-fw"></i></a>
<span class="search-button search-loading" id=search-loading-mobile><i class="fas fa-spinner fa-fw fa-spin"></i></span></div><a href=javascript:void(0); class=search-cancel id=search-cancel-mobile>取消</a></div><a class=menu-item href=/blog/posts/ title=文章列表>文章</a><a class=menu-item href=/blog/categories/ title>分类</a><a class=menu-item href=/blog/tags/ title>标签</a><a class=menu-item href=/blog/about/ title>关于</a><a class=menu-item href=https://github.com/xinyu-yang/blog title=GitHub rel="noopener noreferrer" target=_blank><i class='fab fa-github fa-fw'></i></a><a href=javascript:void(0); class="menu-item theme-switch" title=切换主题>
<i class="fas fa-adjust fa-fw"></i>
</a><a href=javascript:void(0); class=menu-item title=选择语言>简体中文<i class="fas fa-chevron-right fa-fw"></i>
<select class=language-select onchange="location=this.value"><option value=/blog/2023/23-02-13_network-parameters/ selected>简体中文</option></select></a></div></div></header><div class="search-dropdown desktop"><div id=search-dropdown-desktop></div></div><div class="search-dropdown mobile"><div id=search-dropdown-mobile></div></div><main class=main><div class=container><div class=toc id=toc-auto><h2 class=toc-title>目录</h2><div class="toc-content always-active" id=toc-content-auto></div></div><article class="page single"><h1 class="single-title animated flipInX">网络参数RSS、RPS、RFS、aRFS 学习总结</h1><div class=post-meta><div class=post-meta-line><span class=post-author><a href=https://xinyu-yang.github.io title=Author target=_blank rel="noopener noreferrer author" class=author><i class="fas fa-user-circle fa-fw"></i>Xinyu Yang</a></span>&nbsp;<span class=post-category>收录于 <a href=/blog/categories/record/><i class="far fa-folder fa-fw"></i>record</a></span></div><div class=post-meta-line><i class="far fa-calendar-alt fa-fw"></i>&nbsp;<time datetime=2023-02-13>2023-02-13</time>&nbsp;<i class="fas fa-pencil-alt fa-fw"></i>&nbsp;约 3373 字&nbsp;
<i class="far fa-clock fa-fw"></i>&nbsp;预计阅读 7 分钟&nbsp;<i class="fas fa-eye fa-fw"></i>&nbsp;
<span id=busuanzi_container_page_pv class=more-meta><span id=busuanzi_value_page_pv><img src=/blog/img/spinner.svg alt=spinner.svg></span> 次阅读 </span>&nbsp;</div></div><div class="details toc" id=toc-static kept><div class="details-summary toc-title"><span>目录</span>
<span><i class="details-icon fas fa-angle-right"></i></span></div><div class="details-content toc-content" id=toc-content-static><nav id=TableOfContents><ul><li><a href=#receive-side-scaling-rss>Receive Side Scaling (RSS)</a></li><li><a href=#receive-packet-steering-rps>Receive Packet Steering (RPS)</a></li><li><a href=#receive-flow-steering-rfs>Receive Flow Steering (RFS)</a></li><li><a href=#accelerated-rfs>Accelerated RFS</a></li><li><a href=#总结>总结</a></li><li><a href=#参考>参考</a></li></ul></nav></div></div><div class=content id=content><p>最近学习，发现网络参数（包括内核参数、网卡参数）非常多，搞得人云里雾里，非常头大。因此打算在这里对学习到的东西做个总结，方便知识的梳理和以后的复习。</p><h2 id=receive-side-scaling-rss>Receive Side Scaling (RSS)</h2><p>RSS 是一个 Linux 网络协议栈中的调度机制。它的主要作用是将数据包路由到不同的接收队列，进而由该队列所对应的 CPU 进行处理，从而实现对数据包处理的负载均衡。</p><p>在硬件上，通常使用 <code>hash</code> 函数（一般是 <a href=https://en.wikipedia.org/wiki/Toeplitz_Hash_Algorithm target=_blank rel="noopener noreferrer">Toeplitz hash</a>）和长度为 <code>128 (2^7)</code> 的置换表来实现。具体做法是，首先将网络和传输层头部的一些信息（如地址端口四元组）通过 <code>hash</code> 函数计算出一个 <code>hash</code> 值，然后取该 <code>hash</code> 值的后 <code>7</code> 位。将这 <code>7</code> 位数作为索引，在置换表中寻找相应的值，该值即为相应的队列。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>[hash value] : [queue number]
</span></span><span class=line><span class=cl>...
</span></span></code></pre></td></tr></table></div></div><p>网卡的置换表可以通过命令 <code>ethtool --show-rxfh-indir &lt;eth0></code> 来获取，例子如下：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt> 1
</span><span class=lnt> 2
</span><span class=lnt> 3
</span><span class=lnt> 4
</span><span class=lnt> 5
</span><span class=lnt> 6
</span><span class=lnt> 7
</span><span class=lnt> 8
</span><span class=lnt> 9
</span><span class=lnt>10
</span><span class=lnt>11
</span><span class=lnt>12
</span><span class=lnt>13
</span><span class=lnt>14
</span><span class=lnt>15
</span><span class=lnt>16
</span><span class=lnt>17
</span><span class=lnt>18
</span><span class=lnt>19
</span><span class=lnt>20
</span><span class=lnt>21
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>RX flow hash indirection table for eth0 with 4 RX ring(s):
</span></span><span class=line><span class=cl>    0:      0     0     0     0     0     0     0     0
</span></span><span class=line><span class=cl>    8:      0     0     0     0     0     0     0     0
</span></span><span class=line><span class=cl>   16:      0     0     0     0     0     0     0     0
</span></span><span class=line><span class=cl>   24:      0     0     0     0     0     0     0     0
</span></span><span class=line><span class=cl>   32:      1     1     1     1     1     1     1     1
</span></span><span class=line><span class=cl>   40:      1     1     1     1     1     1     1     1
</span></span><span class=line><span class=cl>   48:      1     1     1     1     1     1     1     1
</span></span><span class=line><span class=cl>   56:      1     1     1     1     1     1     1     1
</span></span><span class=line><span class=cl>   64:      2     2     2     2     2     2     2     2
</span></span><span class=line><span class=cl>   72:      2     2     2     2     2     2     2     2
</span></span><span class=line><span class=cl>   80:      2     2     2     2     2     2     2     2
</span></span><span class=line><span class=cl>   88:      2     2     2     2     2     2     2     2
</span></span><span class=line><span class=cl>   96:      3     3     3     3     3     3     3     3
</span></span><span class=line><span class=cl>  104:      3     3     3     3     3     3     3     3
</span></span><span class=line><span class=cl>  112:      3     3     3     3     3     3     3     3
</span></span><span class=line><span class=cl>  120:      3     3     3     3     3     3     3     3
</span></span><span class=line><span class=cl>RSS hash key:
</span></span><span class=line><span class=cl>Operation not supported
</span></span><span class=line><span class=cl>RSS hash function:
</span></span><span class=line><span class=cl>    toeplitz: on
</span></span></code></pre></td></tr></table></div></div><p>可见一共有 <code>128</code> 条表项，完全均匀分配给了队列 <code>rx-0 → rx-3</code>。该表可通过命令 <code>ethtool —set-rxfh-indir</code> 进行配置。</p><p>上述机制实现了从数据包到队列的对应，为了真正实现负载均衡，我们还需要协调好从队列到 CPU 的对应关系。又因为每个队列对应一个中断(参考<a href=../22-02-13_binding-cpu-irq-queue rel>上一篇</a>)，所以我们可以通过中断号绑定的方式来实现队列和 CPU 的对应。关于此，请参考关于此，请参考 <a href=../22-02-13_binding-cpu-irq-queue rel>理解 CPU、中断、队列、进程的绑定关系 - 麋鹿博客 (Elk blog) | 一个分享知识和乐趣的地方</a> 。</p><p><figure><a class=lightgallery href=https://raw.githubusercontent.com/xinyu-yang/imgs/master/imgs/RSS.png title=RSS data-thumbnail=https://raw.githubusercontent.com/xinyu-yang/imgs/master/imgs/RSS.png data-sub-html="<h2>RSS</h2><p>RSS</p>"><img class=lazyload src=/blog/svg/loading.min.svg data-src=https://raw.githubusercontent.com/xinyu-yang/imgs/master/imgs/RSS.png data-srcset="https://raw.githubusercontent.com/xinyu-yang/imgs/master/imgs/RSS.png, https://raw.githubusercontent.com/xinyu-yang/imgs/master/imgs/RSS.png 1.5x, https://raw.githubusercontent.com/xinyu-yang/imgs/master/imgs/RSS.png 2x" data-sizes=auto alt=https://raw.githubusercontent.com/xinyu-yang/imgs/master/imgs/RSS.png></a><figcaption class=image-caption>RSS</figcaption></figure></p><blockquote><p>本文RSS、RPS、RFS、aRFS图片来源：<a href=https://garycplin.blogspot.com/2017/06/linux-network-scaling-receives-packets.html target=_blank rel="noopener noreferrer">Linux Network Scaling: Receiving Packets (garycplin.blogspot.com)</a></p></blockquote><div class="details admonition tip open"><div class="details-summary admonition-title"><i class="icon fas fa-lightbulb fa-fw"></i>技巧<i class="details-icon fas fa-angle-right fa-fw"></i></div><div class=details-content><div class=admonition-content><p><a href=https://www.kernel.org/doc/html/latest/networking/scaling.html target=_blank rel="noopener noreferrer">该文档</a> 给出建议，想要实现低延时，应该配置 CPU 数量的队列（即每个 CPU 一个）。对此，笔者的理解是，如果队列数量少了，则可能会有 CPU 闲着，处理不够及时。队列数量多了也没用，因为 CPU 就那么多。</p><p>针对以高速率为目的的网络，文档建议使用尽可能少的队列，在这种配置下，不会出现接收队列因为一个 CPU 饱和而溢出的情况。因为在启用中断合并（如 <code>NAPI</code>）的情况下，队列越多，中断数越多。</p></div></div></div><h2 id=receive-packet-steering-rps>Receive Packet Steering (RPS)</h2><p>RPS 逻辑上是 RSS 的软件实现，但又不完全一样。RSS 可以为每个数据包选择接收队列，因此也就选择了相对应的执行中断处理的 CPU；而在 RPS 中，中断由默认队列触发，中断处理函数结束之后，选择进行后续协议处理的 CPU。</p><p><figure><a class=lightgallery href=https://raw.githubusercontent.com/xinyu-yang/imgs/master/imgs/RPS.png title=RPS data-thumbnail=https://raw.githubusercontent.com/xinyu-yang/imgs/master/imgs/RPS.png data-sub-html="<h2>RPS</h2><p>RPS</p>"><img class=lazyload src=/blog/svg/loading.min.svg data-src=https://raw.githubusercontent.com/xinyu-yang/imgs/master/imgs/RPS.png data-srcset="https://raw.githubusercontent.com/xinyu-yang/imgs/master/imgs/RPS.png, https://raw.githubusercontent.com/xinyu-yang/imgs/master/imgs/RPS.png 1.5x, https://raw.githubusercontent.com/xinyu-yang/imgs/master/imgs/RPS.png 2x" data-sizes=auto alt=https://raw.githubusercontent.com/xinyu-yang/imgs/master/imgs/RPS.png></a><figcaption class=image-caption>RPS</figcaption></figure></p><div class="details admonition quote open"><div class="details-summary admonition-title"><i class="icon fas fa-quote-right fa-fw"></i>引用<i class="details-icon fas fa-angle-right fa-fw"></i></div><div class=details-content><div class=admonition-content><p>RPS 不会增加额外的硬件设备中断，但是引入了处理器间中断（IPI）。</p><p>— <a href=https://www.kernel.org/doc/html/latest/networking/scaling.html target=_blank rel="noopener noreferrer">Scaling in the Linux Networking Stack — The Linux Kernel documentation</a></p></div></div></div><p>RPS 使用和 RSS 相同的 <code>hash</code> 计算方式，并且每个队列对应一个 CPU 列表。使用计算得到的 <code>hash</code> 值模上 CPU 列表的长度就得到了 CPU 号。当确定了新的 CPU 之后，数据包会被放置到相应 CPU 的 backlog 队列中。随后在新的 CPU 上触发一个 IPI 中断，告诉该 CPU 有 RPS 过来的新包需要其处理。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>[CPU id] = [hash value] mod [len(CPU list)]
</span></span></code></pre></td></tr></table></div></div><p>在编译内核时通过设置 <code>CONFIG_RPS</code> 参数来设置是否支持 RPS 功能，系统默认为开。但是需要为想要使用 RPS 功能的队列配置上面提到的 CPU 列表。</p><p>RPS 配置文件为 <code>/sys/class/net/&lt;device>/queue/&lt;rx-queue>/rps_cpus</code> ，其中 <code>&lt;device></code> 表示网络设备，如 <code>eth0</code> ，<code>&lt;rx-queue></code> 表示接收队列，如 <code>rx-0</code>。</p><p>该文件中存储的是一个十六进制的 <code>bitmap</code>。每一个二进制比特代表一个 CPU，最右边对应序号最小的 CPU（即 <code>CPU0</code>），最左边代表最大的。（参考<a href=../22-02-13_binding-cpu-irq-queue rel>上一篇</a>）</p><p>每个队列的配置默认为 <code>0</code>，即关闭 RPS 功能。如果要打开，用户可以根据规则自行设置。</p><div class="details admonition tip open"><div class="details-summary admonition-title"><i class="icon fas fa-lightbulb fa-fw"></i>技巧<i class="details-icon fas fa-angle-right fa-fw"></i></div><div class=details-content><div class=admonition-content><p>如果网卡只支持单个队列，并且有多个 CPU 的的话，在 NUMA 系统中，一般将 RPS CPU 设置为在相同 <code>domain</code> 的 CPU，非 NUMA 系统就无所谓了，因为设置为每一个 CPU 的性能都是一样的。</p><p>对于多队列网卡，一般系统不会同时启用 RSS 和 RPS，因为这没什么好处。但也有例外，比如网卡所支持的队列数目少于 CPU 数，也就是每个 CPU 还分不到一个接收队列，那么使用 RPS 可能会使得 CPU 的任务分布更高效。</p></div></div></div><h2 id=receive-flow-steering-rfs>Receive Flow Steering (RFS)</h2><p>以上机制很好地保证了数据包处理的负载均衡，可以将处理任务合理的分配到所有的 CPU 上。</p><p>但是，有时候我们还需要考虑其他的因素。比如，网卡收到了属于一个运行在 <code>CPU0</code> 上的进程的数据包，那么这些数据包被 <code>CPU0</code> 处理会比其他 CPU 处理更高效。</p><p>原因很简单直观，数据在 CPU 内传递比跨 CPU 传递要更节省时间。因此，我们希望数据包尽量能够被其所属的进程所在的 CPU 处理，至少能够被同属一个 NUMA 域的 CPU 处理。</p><p>RFS 机制就是为了实现这一点。该机制利用了与 RSS/RPS 类似的 <code>hash</code> 和查找策略，即使用 <code>hash</code> 函数根据包头信息计算得到一个 <code>hash</code> 值，然后作为索引查表。但与之不同的是，RFS 所查找的匹配表（<code>rps_sock_flow_table</code>）中存储的是<strong>数据包所属进程所在的 CPU</strong>。</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-fallback data-lang=fallback><span class=line><span class=cl>[hash value] : [CPU id]
</span></span><span class=line><span class=cl>...
</span></span></code></pre></td></tr></table></div></div><blockquote><p>回顾一下，RPS/RSS 中存储的是预先配置好的 CPU 列表。</p></blockquote><p>如果能查找到有效的 CPU，就按照与 RPS 相同的机制，将数据包入队到 CPU 对应的 <code>backlog</code> 队列中；如果查找不到，那么就直接按照 RPS 机制转发。</p><p>与 RPS 预先配置好的 CPU 列表不同，<code>rps_sock_flow</code> 表是动态更新的。如果有数据包的收发操作，如 <code>inet_recvmsg(), inet_sendmsg(), inet_sendpage(), tcp_splice_read()</code> 等操作，则会插入新的值。类似的情况还发生在进程被调度到新的 CPU 的时候。这时候就需要更新匹配表中的值。如果原来的 CPU 队列上还有未处理完的数据包，那么就会发生乱序。</p><p>为了避免乱序，RFS 使用了另一个表 —— <code>rps_dev_flow</code> 表，每个网卡队列对应一个该表。该表的索引依旧是包头的 <code>hash</code> 值，每个索引对应两个字段：1) 现在的 CPU（也就是该数据包所属流已经把数据包放在其队列上等待其内核处理的 CPU）号。2) 当该流最后一个数据包到达后，该 CPU 的 backlog 队列的尾计数器值。</p><p><figure><a class=lightgallery href=https://raw.githubusercontent.com/xinyu-yang/imgs/master/imgs/RFS.png title=RFS data-thumbnail=https://raw.githubusercontent.com/xinyu-yang/imgs/master/imgs/RFS.png data-sub-html="<h2>RFS</h2><p>RFS</p>"><img class=lazyload src=/blog/svg/loading.min.svg data-src=https://raw.githubusercontent.com/xinyu-yang/imgs/master/imgs/RFS.png data-srcset="https://raw.githubusercontent.com/xinyu-yang/imgs/master/imgs/RFS.png, https://raw.githubusercontent.com/xinyu-yang/imgs/master/imgs/RFS.png 1.5x, https://raw.githubusercontent.com/xinyu-yang/imgs/master/imgs/RFS.png 2x" data-sizes=auto alt=https://raw.githubusercontent.com/xinyu-yang/imgs/master/imgs/RFS.png></a><figcaption class=image-caption>RFS</figcaption></figure></p><p>当选择处理数据包的 CPU 时，首先检查 <code>rps_sock_flow</code> 表和 <code>rps_dev_flow</code> 表中对应的 CPU 值是否相同。如果一样，说明进程还是运行在相同的 CPU 上，仍将数据包放在该 CPU 的队列上，没有问题。如果不一样，那么就看以下三个情况：</p><ol><li>现在的 CPU 队列头计数器 ≥ <code>rps_dev_flow</code> 表中的队列尾计数器。</li><li>现在的 CPU 未被设置 (≥ <code>nr_cpu_ids</code>)。</li><li>现在的 CPU 下线了。</li></ol><p>如果上面任意一条满足，就将现在的 CPU 更新为 Desired CPU （即 <code>rps_sock_flow</code> 表中的值）。否则，仍在原（现） CPU 上执行。</p><p>直观的理解上面的判断机制，那就是：当进程切换 CPU 时，先判断原 CPU 队列上有没有未处理完的包，如果有就不切换；如果没有，就切换。</p><p>Linux 内核编译可通过允许 <code>CONFIG_RPS</code> 来使能该功能，一般默认允许。但要是想让 RFS 真正工作，还需要进行配置上面提到的两个表，他们的配置路径分别为：</p><div class=highlight><div class=chroma><table class=lntable><tr><td class=lntd><pre tabindex=0 class=chroma><code><span class=lnt>1
</span><span class=lnt>2
</span></code></pre></td><td class=lntd><pre tabindex=0 class=chroma><code class=language-bash data-lang=bash><span class=line><span class=cl>/proc/sys/net/core/rps_sock_flow_entries
</span></span><span class=line><span class=cl>/sys/class/net/&lt;dev&gt;/queues/rx-&lt;n&gt;/rps_flow_cnt
</span></span></code></pre></td></tr></table></div></div><div class="details admonition tip open"><div class="details-summary admonition-title"><i class="icon fas fa-lightbulb fa-fw"></i>技巧<i class="details-icon fas fa-angle-right fa-fw"></i></div><div class=details-content><div class=admonition-content><a href=https://www.kernel.org/doc/html/latest/networking/scaling.html target=_blank rel="noopener noreferrer">该文档</a> 建议 <code>rps_sock_flow_entries</code> 的数量应该跟活跃流的数量相当，然后四舍五入取二的指数值。进一步，文档建议对于一般负载的服务器，值取为 <code>32768 (2^15)</code> 效果比较好。对于 <code>rps_flow_cnt</code> 的取值应该参考 <code>rps_sock_flow_entries</code>，因为前者是每个队列一个，后者是全局的，所以只要将 <code>rps_flow_cnt</code> 取为 <code>rps_sock_flow_entries / N</code> 就行，其中 <code>N</code> 为队列数。</div></div></div><p>关于该建议，本人的理解是：最好能够给每一个活跃的流都能分配一个表项，使其能够准确找到对应的 CPU。</p><h2 id=accelerated-rfs>Accelerated RFS</h2><p>Accelerated RFS 之于 RFS 相当于 RSS 之于 RPS。Accelerated RFS 在硬件上就可以选择正确的队列，随后触发该数据包所属流所在的 CPU 的中断。由此可见，如果想要在硬件上实现队列选择，我们需要一个从流到硬件队列的对应关系。</p><p>从上文可知，我们已经有了一个从流到 CPU 的映射关系，记录在 <code>rps_dev_flow</code> 表中。然后，我们也有 CPU 和硬件队列的关系，通过 <code>/proc/irq/&lt;irq_num>/smp_affinity</code> 进行配置。</p><div class="details admonition info open"><div class="details-summary admonition-title"><i class="icon fas fa-info-circle fa-fw"></i>信息<i class="details-icon fas fa-angle-right fa-fw"></i></div><div class=details-content><div class=admonition-content>回顾一下 <code>rps_dev_flow</code> 表中存储的信息，如果该表被更新，说明有某个进程被创建，或者进程连同协议处理完全迁移到了一个新的 CPU。</div></div></div><p><figure><a class=lightgallery href=https://raw.githubusercontent.com/xinyu-yang/imgs/master/imgs/aRFS.png title=aRFS data-thumbnail=https://raw.githubusercontent.com/xinyu-yang/imgs/master/imgs/aRFS.png data-sub-html="<h2>aRFS</h2><p>aRFS</p>"><img class=lazyload src=/blog/svg/loading.min.svg data-src=https://raw.githubusercontent.com/xinyu-yang/imgs/master/imgs/aRFS.png data-srcset="https://raw.githubusercontent.com/xinyu-yang/imgs/master/imgs/aRFS.png, https://raw.githubusercontent.com/xinyu-yang/imgs/master/imgs/aRFS.png 1.5x, https://raw.githubusercontent.com/xinyu-yang/imgs/master/imgs/aRFS.png 2x" data-sizes=auto alt=https://raw.githubusercontent.com/xinyu-yang/imgs/master/imgs/aRFS.png></a><figcaption class=image-caption>aRFS</figcaption></figure></p><p>每当 <code>rps_dev_flow</code> 表中的条目被更新，网络协议栈就会调用驱动中的 <code>ndo_rx_flow_steer</code> 函数来更新流到硬件队列的对应关系。</p><p>Accelerated RFS 需要在编译阶段使能 <code>CONFIG_RFS_ACCEL</code>，并且需要硬件和驱动的支持。此外，还需要使用 <code>ethtool</code> 设置 <code>ntuple</code> 过滤。其他的就不需要配置了。</p><div class="details admonition tip open"><div class="details-summary admonition-title"><i class="icon fas fa-lightbulb fa-fw"></i>技巧<i class="details-icon fas fa-angle-right fa-fw"></i></div><div class=details-content><div class=admonition-content>Accelerated RFS 机制可以将数据包直接放在最终的 CPU 硬件队列上，所以性能应该是要比 RFS 高。因此，当硬件支持该选项，应该选择此机制。</div></div></div><h2 id=总结>总结</h2><p>回顾一下这些机制之间的关系。首先是 RSS/RPS，该机制在接收数据包的时候，通过手动配置，甚至是根据负载情况的自动配置（如 <code>irqbalance</code>），来把数据包的处理负载均匀分配到不同的 CPU 上。<strong>RSS/RPS 仅根据负载大小进行判断</strong>，但是这可能导致从协议栈处理到上层应用处理之间数据包的转移。</p><p>因此 RFS/aRFS 更进一步，在进行 CPU 选择的时候考虑上层应用所处位置，对每一个流都配置一个 Desired CPU。因此，在为数据包选择 CPU 的时候，会优先选择 Desired CPU。</p><h2 id=参考>参考</h2><ol><li><a href=https://www.kernel.org/doc/html/latest/networking/scaling.html target=_blank rel="noopener noreferrer">Scaling in the Linux Networking Stack — The Linux Kernel documentation</a></li><li><a href=https://en.wikipedia.org/wiki/Toeplitz_Hash_Algorithm target=_blank rel="noopener noreferrer">Toeplitz Hash Algorithm - Wikipedia</a></li><li><a href=https://access.redhat.com/documentation/en-us/red_hat_enterprise_linux/6/html/performance_tuning_guide/network-rps target=_blank rel="noopener noreferrer">8.7. Receive Packet Steering (RPS) Red Hat Enterprise Linux 6 | Red Hat Customer Portal</a></li><li><a href=https://www.kernel.org/doc/html/latest/core-api/irq/irq-affinity.html target=_blank rel="noopener noreferrer">SMP IRQ affinity — The Linux Kernel documentation</a></li><li><a href=https://garycplin.blogspot.com/2017/06/linux-network-scaling-receives-packets.html target=_blank rel="noopener noreferrer">Linux Network Scaling: Receiving Packets (garycplin.blogspot.com)</a></li></ol></div><div class=post-footer id=post-footer><div class=post-info><div class=post-info-line><div class=post-info-mod><span>更新于 2023-02-13&nbsp;<a class=git-hash href=https://github.com/xinyu-yang/blog/commit/c9eeddfb76c68c56259a82e4e51afcb127a9a463 target=_blank rel="noopener noreferrer" title="commit by yxy.gram(yangxinyu75@live.com) c9eeddfb76c68c56259a82e4e51afcb127a9a463: update images">
<i class="fas fa-hashtag fa-fw"></i>c9eeddf</a></span></div><div class=post-info-license></div></div><div class=post-info-line><div class=post-info-md><span><a class=link-to-markdown href=/blog/2023/23-02-13_network-parameters/index.md target=_blank rel="noopener noreferrer">阅读原始文档</a></span></div><div class=post-info-share><span><a href=javascript:void(0); title="分享到 Twitter" data-sharer=twitter data-url=https://xinyu-yang.github.io/blog/2023/23-02-13_network-parameters/ data-title="网络参数RSS、RPS、RFS、aRFS 学习总结" data-via=xinyuyang18 data-hashtags=arch><i class="fab fa-twitter fa-fw"></i></a><a href=javascript:void(0); title="分享到 Facebook" data-sharer=facebook data-url=https://xinyu-yang.github.io/blog/2023/23-02-13_network-parameters/ data-hashtag=arch><i class="fab fa-facebook-square fa-fw"></i></a><a href=javascript:void(0); title="分享到 Hacker News" data-sharer=hackernews data-url=https://xinyu-yang.github.io/blog/2023/23-02-13_network-parameters/ data-title="网络参数RSS、RPS、RFS、aRFS 学习总结"><i class="fab fa-hacker-news fa-fw"></i></a><a href=javascript:void(0); title="分享到 微博" data-sharer=weibo data-url=https://xinyu-yang.github.io/blog/2023/23-02-13_network-parameters/ data-title="网络参数RSS、RPS、RFS、aRFS 学习总结"><i class="fab fa-weibo fa-fw"></i></a></span></div></div></div><div class=post-info-more><section class=post-tags><i class="fas fa-tags fa-fw"></i>&nbsp;<a href=/blog/tags/arch/>arch</a></section><section><span><a href=javascript:void(0); onclick=window.history.back()>返回</a></span>&nbsp;|&nbsp;<span><a href=/blog/>主页</a></span></section></div><div class=post-nav><a href=/blog/2023/23-02-13_binding-cpu-irq-queue/ class=prev rel=prev title="理解 CPU、中断、队列、进程的绑定关系"><i class="fas fa-angle-left fa-fw"></i>理解 CPU、中断、队列、进程的绑定关系</a></div></div><div id=comments><div id=tcomment></div><noscript>Please enable JavaScript to view the comments powered by <a href=https://twikoo.js.org/>Twikoo</a>.</noscript></div></article></div></main><footer class=footer><div class=footer-container><div class=footer-line><span id=busuanzi_container_site_pv>本站总访问量 <span id=busuanzi_value_site_pv><img src=/blog/img/spinner.svg alt=spinner.svg></span> 次</span>
<span class=division>•</span>
<span id=busuanzi_container_site_uv>本站总访客数 <span id=busuanzi_value_site_uv><img src=/blog/img/spinner.svg alt=spinner.svg></span> 人</span></div><div class=footer-line><a href=https://gohugo.io/ target=_blank rel="noopener noreferrer" title="Hugo 0.110.0">Hugo</a> - <a href=https://github.com/xinyu-yang/EnjoyIt target=_blank rel="noopener noreferrer" title="EnjoyIt 0.0.1"><i class="fas fa-heart fa-fw"></i>EnjoyIt</a><span class=division> •</span>
<i class="far fa-copyright fa-fw"></i><span itemprop=copyrightYear>2021 - 2023</span><span class=author itemprop=copyrightHolder>&nbsp;<a href=https://xinyu-yang.github.io target=_blank rel="noopener noreferrer">Xinyu Yang</a></span>&nbsp;•&nbsp;<span class=license><a rel="license external nofollow noopener noreferrer" href=https://creativecommons.org/licenses/by-nc/4.0/ target=_blank>CC BY-NC 4.0</a></span></div></div></footer></div><div id=fixed-buttons><a href=# id=back-to-top class=fixed-button title=回到顶部><i class="fas fa-arrow-up fa-fw"></i>
</a><a href=# id=view-comments class=fixed-button title=查看评论><i class="fas fa-comment fa-fw"></i></a></div><script type=text/javascript src=https://cdn.jsdelivr.net/npm/twikoo@1.4.11/dist/twikoo.all.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/smooth-scroll@16.1.3/dist/smooth-scroll.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/autocomplete.js@0.37.1/dist/autocomplete.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/lunr@2.3.8/lunr.min.js></script><script type=text/javascript src=/blog/lib/lunr/lunr.stemmer.support.min.8127f0ca4cabc7246f3620f3ef3bf9b1db02805dfe03d6d4c57bc74bc0bf6eea.js integrity="sha256-gSfwykyrxyRvNiDz7zv5sdsCgF3+A9bUxXvHS8C/buo="></script><script type=text/javascript src=/blog/lib/lunr/lunr.multi.min.5746f79fe1d78782987dc8168accfb7cf0c9f488651e4e4d56a6472329231b69.js integrity="sha256-V0b3n+HXh4KYfcgWisz7fPDJ9IhlHk5NVqZHIykjG2k="></script><script type=text/javascript src=/blog/lib/lunr/lunr.zh.min.df40c83b86d7cea2122cd35d56db3e6e4bc34b09a62755f0f3c48b5e9c66a8a4.js integrity="sha256-30DIO4bXzqISLNNdVts+bkvDSwmmJ1Xw88SLXpxmqKQ="></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/lazysizes@5.2.2/lazysizes.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/clipboard@2.0.6/dist/clipboard.min.js></script><script type=text/javascript src=https://cdn.jsdelivr.net/npm/sharer.js@0.4.0/sharer.min.js></script><script type=text/javascript>window.config={code:{copyTitle:"复制到剪贴板",maxShownLines:10},comment:{twikoo:{el:"#tcomment",envId:"https://twikoo-comment-xinyu-yang.vercel.app/"}},search:{highlightTag:"em",lunrIndexURL:"/blog/index.json",lunrLanguageCode:"zh",lunrSegmentitURL:"/blog/lib/lunr/lunr.segmentit.js",maxResultLength:10,noResultsFound:"没有找到结果",snippetLength:50,type:"lunr"}}</script><script type=text/javascript src=/blog/js/theme.a63aa926c3cd8d6695367caa381f19bdaa78efc1bd87b33c0a4968ca187b5c7f.js integrity="sha256-pjqpJsPNjWaVNnyqOB8Zvap478G9h7M8Ckloyhh7XH8="></script><script type=text/javascript>window.dataLayer=window.dataLayer||[];function gtag(){dataLayer.push(arguments)}gtag("js",new Date),gtag("config","G-NSNR248K3V")</script><script type=text/javascript src="https://www.googletagmanager.com/gtag/js?id=G-NSNR248K3V" async></script><script id=baidu_analytics type=text/javascript>var _hmt=_hmt||[];(function(){if(window.location.hostname==="localhost")return;var t,e=document.createElement("script");e.async=!0,e.src="https://hm.baidu.com/hm.js?b72cf2095ce01c4c9d6392678286aafd",t=document.getElementsByTagName("script")[0],t.parentNode.insertBefore(e,t)})()</script></body></html>