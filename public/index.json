[{"categories":["乱七八糟"],"content":"一路花香一路唱 xxx和xss自然可以称得上是\"花\"，如果我们在放音乐的时候所发出的声音姑且可以称为\"唱\"，那么这首歌便可以说是我们行程的真实写照了。 西北游记-青甘大环线 ","date":"2021-06-14","objectID":"/posts/21-06-14_journey-to-northwest/:0:0","tags":["游记"],"title":"西北游记","uri":"/posts/21-06-14_journey-to-northwest/"},{"categories":["乱七八糟"],"content":"旅途开始 旅程将从西宁开始，也将在西宁结束，绕着青海和甘肃省的一些著名景点游览一圈，有始有终（如图一）。6月5号我们首先从北京大兴机场乘坐飞机出发前往西宁市，从学校到大兴机场打车用了一个半小时，距离颇远，但大家心情愉快，有说有笑，虽然遥远但并不觉漫长（更何况路上司机师傅还主动给我们展示了电动汽车的加速性能😏）。飞机起飞后两小时就到达了西宁马家堡（pu）机场，计划打车先去宾馆放东西，然后去夜市逛逛，但不幸的是车堵在了一条进城的路上，耽误了不少时间，所以后面逛夜市的计划也就泡汤了。其实在飞机即将降落的时候，我们就透过窗户看到了一条堵得长长的公路，当时身处局外感叹这条路好堵的时候，怎么也没想到一小时后，自己也将会堵在这条路上，不得不感叹世事难料啊😂。走走停停中，我们一路好奇地打量着这个城市的每一个招牌，寻找属于这个城市的独特印记，最后在将近十一点的时候才到宾馆。 办理入住的时候，前台大姐看着我们的身份证突然说了句”我原来家在知春路”，因为出来旅行，大脑已经从工作学习状态（包括地点）转换出来，所以对于这句略显突兀的话，我们先是一愣，待反应过来”知春路“乃是北京的一处地名，便和她互认”老乡“聊了几句，她跟我们简短分享了她的一些经历和她对于北京和西宁生活节奏的体会。后来从“知春路”的插曲中得到了一些思考，也许旅行的意义就是换个新的环境，将思想暂时从紧张的学习工作中解脱出来，从而得到片刻的放松。由此得到的启示就是，旅行的时候要把学习工作的事完全抛到脑后（危）。 图一：旅行行程图（图片来源于网络） ","date":"2021-06-14","objectID":"/posts/21-06-14_journey-to-northwest/:1:0","tags":["游记"],"title":"西北游记","uri":"/posts/21-06-14_journey-to-northwest/"},{"categories":["乱七八糟"],"content":"祁连大草原，张掖七彩丹霞 本来应该满怀期待早起出发，不巧的是昨天我刚下飞机就看到了??邮件的回复，并且老师希望能够视频交流一下，时间定为第二天早上9:30，按照计划我们此时应该已经在路上了。这突然的变故使我措手不及，因此我把这件事跟同伴说了一下，他们纷纷肯定了这件事的重要性，并愿意更改计划，这件事使我颇为感动（希望他们能够看到😉）。经过商议，最终决定等我在宾馆开完会再出发。结果，后来的事实表明我们太低估这次会议的时长，原本以为一个小时结束的视频共持续了两个多小时，同伴们就在宾馆打了一上午牌（后来知道叫uno）。会议完之后，出于对同伴的愧疚，我提议请大家吃饭，好的那种。 同伴告诉我由于天气原因，成哥决定将游览路线从顺时针改成逆时针（如图一）。我们匆匆收拾行李下楼，至此第一次见到了成哥。由于原本上午计划的行程被耽误了，所以下午只能拼命赶路，只为能够在天黑之前到达张掖的七彩丹霞景区（因为不是油菜花开花的季节，所以门源花海还不存在）。前两个小时一直在走盘山公路，我小时候就比较容易晕车，虽说长大后好了很多，但是对于这种拐弯抹角的山路还是毫无招架之力。每拐一个弯就像是用棍子在胃里搅拌一下，没过多久我的胃里就翻江倒海，但好在这种路况并没有持续太久，在差不多到达祁连大草原的时候就结束了。在这期间差不多两点的时候，我们在路边的一个面馆匆匆吃了顿中午饭。当时地处高原，且天空下着小雨，又冷又饿又难受的我感到非常虚弱，就让同伴帮我随便点了碗炸酱面，幸运的是这个面吃着还不错。 图二：雪山 匆匆吃完饭后，我们再次出发，后面的行程中，道路稍微平缓了一些，雨也渐渐转停。透过车窗可以看到路边山坡上的牛羊和远处的雪山，虽然当时刚下过雨的天空灰暗，几乎与远处灰白的雪山融为一体，但是我们还是被眼前这高冷神秘且纯净的雪山所震撼，在崎岖的山路上快速穿行的汽车里，我们透过车窗按下快门，尽可能记录下这些迷人的风景。在此期间，我们经过了祁连大草原，汽车从公路上飞驰而过，近处是翠绿葱郁的草原，远处是连绵不断的祁连山脉。看到这些景色，不禁遐想，当年年仅19岁的霍去病也许就是在这个山谷与匈奴骑兵短兵相接，将河西走廊纳入汉王朝的版图，为后来的丝绸之路扫清障碍。 图三：张掖七彩丹霞 将近傍晚的时候我们到达了张掖市七彩镇，著名的七彩丹霞景区就在这里。刚进景区就出现了一个小插曲，xss的手机落在了厕所，还好等赶忙回去寻找的时候碰到了一个捡到手机的好心人，总算是有惊无险。同样是天气原因，七彩丹霞虽然仍是鲜艳瑰丽，但是少了阳光的加持，因此也就失去了震撼人心的力量。虽然没能看到阳光下的霞光万丈，心里不免有些遗憾，但大自然的鬼斧神工还是让人流连忘返。 晚饭的时候吃了一个比较有特色的菜，食材是鸡肉和类似于小花卷一样的面食，具体菜名忘了，可能叫鸡肉炖xx之类的吧，鸡肉本身普普通通，但是那个面食还是挺不错的，就连担心吃不惯面食的xss都颇为满意。还有一个菜叫沙葱炒鸡蛋，其品相和味道都和韭菜炒鸡蛋差不多，据说沙葱是当地的一个特色野菜，感觉就是粗细如粉条的迷你版大葱。一件有趣的事就发生在这道沙葱炒鸡蛋上，准确地说是发生在盛菜的盘子上。xyy吃这道菜的时候够不着，xss就试图挪动这个盘子，结果用手轻轻一拉，盘子就从中间分开了，我们被这个突如其来的重大事故惊的目瞪口呆，待稍稍回过神来，就开始讨论这个奇迹发生的原因，主要进行了如下猜测： xss在扯盘子的时候使用内力震碎了盘子。 盘子盛上热菜以后，由于热胀冷缩或者量子力学等物理原因断开了。 服务员放盘子的时候力气稍大，再加上盘子本身质量的问题，所以就碎了。 我本人比较赞同第三种可能，考虑到我们所处的真实世界与武侠世界有较大区别，首先排除第一条，其次我们猜想如果盘子自己裂开应该会发出声音，而且我也想不出合理的物理解释，所以暂且把第二条也排除，最后就只剩下第三条。 ","date":"2021-06-14","objectID":"/posts/21-06-14_journey-to-northwest/:2:0","tags":["游记"],"title":"西北游记","uri":"/posts/21-06-14_journey-to-northwest/"},{"categories":["乱七八糟"],"content":"嘉峪关城一瞥，敦煌沙丘四顾 早起赶路，匆匆赶了半天，终于到达了酒泉市，我们在途中某川菜馆吃了顿午饭，吃饭之余，我们还关注了一下上午刚结束的高考语文作文题目，并就此引出了一段对高考语文的讨论，主题无非还是对高考刻板套路的嘲讽，以此体现自己作为曾经亲历者的优越感，就像一个久经沙场的老兵谈论自己参加过的某个战役。最后的讨论在xxx带我们温习”我家门口有两棵树，一棵是枣树，另一棵还是枣树“的阅读理解中结束，按照这句话的格式，我们还临摹了一句我们的真实情况写照——”我们今天有两个计划，上午赶路，下午还是赶路“。 事情果然如计划进行，继续赶路，下午到了不远处的嘉峪关，但是成哥说里面没什么好看的，且门票价格不菲，不建议进去看。于是我们采纳了成哥的建议，在景区门口处与身后刻着”天下第一雄关——嘉峪关“的大石头合了几张影，然后跑到了景区侧面远远地眺望了一下关城就离开了，据说里面那三个城楼一样的建筑完全是后来修建的。我们在三四点左右到达瓜州，并在一个十字路口旁的一排卖瓜的店铺前稍作停留，这些店铺均为活动板房，稍显简陋，且四周看不到任何其他建筑和人家。但因为地处十字路口，所以频繁有大小车辆经过，且方便停留，不一会就有好几个旅行团的大巴车停在店铺前，并由导游带着游客下车，看来是一个典型的“屠宰场“。下车前成哥嘱咐我们进去吃瓜，但是不要买，吃完直接就走。记得刚从张掖出发的时候，成哥就告诉我们回头要带我们去一个免费吃瓜的地，吃完就走，当时我们还以为去地里偷瓜，并提醒成哥换成”跑“可能更合适。 瓜还不错，挺甜的，牛肉干也不错，只是不小心吃到一个辣的，害我喝了好多水。接下来继续赶路，并在四五点左右到达了敦煌。在宾馆休息了一会，大概六点多，成哥带我们去了一个沙漠露营基地，名字很有意思——”熊出漠“，这可能也是后来xss把工作小哥阿虎错叫成阿熊的原因，不过如果按照字面意思的话，熊好像指的是我们😒。 营地包括不限次数的滑沙和单次的沙漠摩托以及太阳落山之后的自助火锅和篝火晚会等，夏季西北部地区的落日比较晚，大概要到晚上九点多太阳才下山，因此我们还有比较充分的时间近距离地接触沙漠。因为以前从未踏足过沙漠，所以我刚到营地的时候还是感到很新鲜的，但逐渐发现在沙漠中行走是一件很困难的事情，好在xss提前买的鞋套起到了很大的作用，要不然满鞋沙子会更难受（是的，我后来体会到了😞）。我们首先玩了一下滑沙，遇到了颇为健谈且富激情的阿虎，这位老哥洗脑般的声音至今仍记忆犹新，尤其是在给xxx拍照的时候所发出的”天呐，好美啊“的感叹至今仍在我脑海里回荡（一部分原因是我非常同意他的看法😏）。然后我们排队去坐沙漠摩托，因为该项目体验颇为刺激，所以xxx直接就放弃了该项目。虽然我心里一直抱着不能怂的信念，但随着离队头越来越近，心里还是一直犯嘀咕。坐完之后感觉跟坐过山车一样（虽然我没坐过过山车😂），不同的是沙漠摩托没有安全带之类的保障，而且感觉该项目对司机要求较高，如果技术不行，很有可能翻车。我们刚到的时候太阳大，风也大，好在随着夕阳西下，太阳慢慢变得稍微温和了些，风也渐渐平息，依托沙漠广阔壮丽而又纯净的背景，成哥颇为熟练地帮我们每人拍了好多照片。 图四：沙丘 太阳落山之后，我们回到了营地的宴席上，除了想一心干饭的xyy外，我们其他几个抱着好奇的心态参加了“篝火晚会”，整个过程大概就是在主持人的号召下，所有人一块挥手、蹦蹦跳跳和转圈圈，也许是因为我没有融入该氛围，所以感觉整个过程颇为尴尬。随后的“沙漠蹦迪”也差不多，且音效和灯光效果劲爆，在感到心律不齐和头昏眼花之后，我们就退出了这场”狂欢“。待我想返回宴席饱餐一顿的时候，失望地发现自助火锅的味道实在是不敢恭维，挑来选去，竟然感觉最好吃且顶事的是黄瓜，因为吃饭时间较晚且考虑到晚上还有看星星的环节，为了填饱肚子，我坚持吃下了不少黄瓜。同样吃了不少黄瓜的还有xss，但是ta居然喜欢吃煮过的。 草草地吃完晚饭后，大概已经晚上十点多了，此时我们准备去沙漠上看星星，临走之前我又拿了几段黄瓜边走边啃。这次往沙丘里走最大的失误就是没穿鞋套，以至于后来回去之后鞋袜里抖出好多沙子。往沙丘里稍走一段，避开营地的灯光就可以看到满天繁星，但若想长曝光把星星尽可能拍得好看，还要找一个合适的小沙沟，以避开四周各种光源。但这并不是一件容易的事，因为直到午夜也还是有沙漠摩托和拿着手电筒的行人来往经过，毫无疑问，这片区域的沙丘已经被现代化的文明侵入，没有了原本的宁静，自然也不复本来的面貌。 图五：沙漠星空 ","date":"2021-06-14","objectID":"/posts/21-06-14_journey-to-northwest/:3:0","tags":["游记"],"title":"西北游记","uri":"/posts/21-06-14_journey-to-northwest/"},{"categories":["乱七八糟"],"content":"举世闻名莫高窟，沙漠奇绝月牙泉 终于到了莫高窟！在这次旅行的所有景点中，莫高窟是我最期待的一个，原因可能在于莫高窟的名气太大了，以至于总是能无意间从各种渠道获取莫高窟的信息，我甚至可以想象当听到有人说他不知道莫高窟的时候，我应该如何控制自己惊讶的语气来表现对他的嘲讽，即使我对莫高窟的认识也仅仅是听说过而已。 鲁迅曾经说过”期望越大，失望越大“，这次果然又应验了。我们大概上午十点到达莫高窟景区，首先是观看两场巨幕小电影，电影主要介绍了莫高窟的建造历史和几个重要洞窟，后来觉得这些介绍还是挺有必要的，要不然更是什么都看不懂。我以前看过一个纪录片《河西走廊》，其中有一集专门介绍莫高窟，内容形式跟那两个小电影差不多。看完小电影，我们乘坐景区的大巴车到达真正的莫高窟。莫高窟的洞窟数量很多，但是适合参观的并不多，而现在开放给游客的就更少了，只有六十四个，而景区导游只会随机的带我们参观八个洞窟，其中包括必看的由”九层楼“（98窟）、涅槃窟（158窟）和藏经洞（17窟），出于保护壁画等原因，洞窟里不允许开灯和拍照，再加上参观的人多且时间紧，所以我们只能跟随导游在昏暗拥挤的石窟里走马观花地看一看。 图六：莫高窟九层楼 整个过程并无太多惊喜，甚至于在开头小电影里看到的雕像栩栩如生的220窟也没有参观，自然也就难免失望。后来想了一下，失望应该是必然的，原因在于莫高窟的价值体现在历史、文化和艺术的记载和传承上，而像我这样的文盲游客只图看个热闹，没有相应的文化积累和研究，自然觉得失望。并且洞窟内的壁画大多是经变图，这是中国工匠所独创的以绘画的形式来表现佛教典故的方式。因为缺乏相应的佛教知识，所以参观的时候自然对于壁画的内容一脸懵逼，依靠导游的讲解才勉强知道大概内容。如果我对里面的佛教典故都能够如数家珍，那么参观的体验可能就大不相同了。我之所以这样认为，是有一定的事实依据的，因为我曾在某个壁画的一角看到了关于唐玄奘和猴行者取景的场景，那种感觉就像是在异乡遇到了老熟人，兴奋且惊喜。 下午观看了一场关于敦煌的演出——《又见敦煌》，据说该节目是来敦煌必看的几样东西之一，并且曾经创下11天门票收入一个亿的记录（可能一个原因是票价确实很贵😓）。于是我们下午也满怀期待去看了该演出，该演出的形式是我以前没有见过的，我暂且把它称之为交互式舞台剧，其采用多视角表演和叙述的方式，拉近了观众与表演者的距离，表现方式独具匠心、别具一格。比如透过玻璃地板俯视表演者的一举一动，给人一种上帝视角的感觉，还有透过玻璃天花板仰视着覆盖在玻璃上的沙子被一层层拨开，仿佛亲眼见到了敦煌文物重见天日的时刻，并且不时还穿插着身着现代衣着的表演者与身着古装的表演者之间的对话，而身着现代衣着的表演者就站在我们中间，仿佛我们也能与古人对话一般，彻底打破了观众与历史人物之间的壁垒。 舞台剧的相当一部分内容集中到了王圆箓偷卖经书的情节，由此引发了我对王道士行为的思考，在我看来，王道士把经书卖到国外不见得是件坏事，塞翁失马焉知非福，如果当初没有送到国外，也许早就焚毁殆尽在后来的战争和动荡中。而现在经书虽然散落世界各地，但庆幸地是大部分都得到了很好的保存，只要还保存完好，就还有回来的机会。况且即使别的国家得到了很多稀世珍品，但其终究还是中国文化的一部分，而文化这种东西只能被自己遗忘，是无法被别人夺走的。 差不多也是当天的六点钟左右我们去了敦煌另一个著名景点——”鸣沙山月牙泉“，月牙泉是沙漠中一汪形似月亮的泉水，地方不大，但因为处在沙漠之中，所以相当惊艳。在去月牙泉之前，成哥带我们去了一家面馆吃午饭，老板非常热情，我们刚坐下就给我们端上来一盘西瓜，非常甜，据说是新疆产的。然后我们每人点了一碗面，等面上来的时候，如脸盆一样的碗着实使我大吃一惊，每个人面前放着这么一只碗，看起来十分诙谐，让人忍俊不禁。也许面馆老板早已司空见惯，淡定地看着我们这群没见过世面的人在这里一惊一乍，说笑个不停，又是合影又是摆拍。不仅是碗，碗里的面也很惊人，面条如巴掌般宽，偌大的碗里，总共只有两三根这么宽的面条，开始还担心吃不饱，结果到最后吃撑了才勉强吃完。 图七：月牙泉 吃完饭之后，我们就去了景区，因为前一天去过沙漠露营地，该拍的照片也拍了不少，所以这次再来到鸣沙山的时候并没有太多激动和欣喜。对于这个景点我们唯一感兴趣的其实就是月牙泉了，于是我们目标明确地朝月牙泉走去。等我们到达月牙泉之后发现在近距离只能看到月牙的一角，无法看出月牙的轮廓，于是我们朝着对面的沙丘爬去，事实上这也是很多人都在做的。沙丘稍微有点高，但好在有一个木梯子铺在沙地上，踩着木梯走就跟爬山一样，虽然相对轻松很多，但是爬到山顶还是气喘吁吁。我们到达山顶的时候，太阳正在落山，于是就有了图七。太阳下山之后，我们也觉得没意思，就下山回去了。成哥最后带我们去逛了一下敦煌的夜市，据说很热闹，到了之后感觉稀松平常，无甚特别，匆匆转了一圈就结束了今天的行程。 ","date":"2021-06-14","objectID":"/posts/21-06-14_journey-to-northwest/:4:0","tags":["游记"],"title":"西北游记","uri":"/posts/21-06-14_journey-to-northwest/"},{"categories":["乱七八糟"],"content":"西出阳关，天降翡翠 离开敦煌后，我们前往下一个目的地，古代中国最西边的关隘——阳关。王维的诗句”劝君更进一杯酒，西出阳关无故人“使得阳关家喻户晓，即使故阳关早已经消失在茫茫戈壁之上，后来重建的阳关还是吸引无数游客慕名前来。不由得感慨文化是如此的强大，可以贯穿古今、超越物质的存在而经久不息。不觉想起李白的诗句”古来圣贤皆寂寞，惟有饮者留其名“，本来是一句扯淡的大话，没想到一语成谶，”岑夫子“和”丹丘生“真的因为一场酒局而千古留名。相同的例子还有那个著名的唐朝农民”汪伦“，按照戴建业老师的说法”汪伦这狗东西真是走了狗屎运，就因为送了下李白，结果一千多年后，全世界都知道唐朝有个农民叫汪伦。“ 图八：阳关古城遗址 书归正传，阳关的标志性建筑就是古阳关现存的唯一一处烽火台遗址，原来八点几米，现只存三米多了，除此之外，古阳关就再没有其他古迹留存了。烽火台四周是一望无际的戈壁，阳关烽燧孤零零的矗立在这片广袤辽阔的土地上，更显凄凉和悲壮，仿佛艰辛孤苦而又坚毅挺拔的戍边将士。图八中栈道所围就是古阳关所在地，如今已荡然无存。（来到这才知道原来”阳关道“里的阳关也是指这里） 阳关烽燧景点周围毫无遮蔽，酷热难耐，稍作停留我们就返程了。不禁心想，古代的阳关是否也像是今天那么炎热干燥，但即使是这样，作为古代中国的西大门，不知有多少往来商旅将阳关看作前方路途的希望。 翡翠湖是一片断断续续的盐湖，目前免费，据成哥说很快就要开始收费了。在阳光的照射下，湖水颜色清澈且碧绿如翡翠，岸边是厚厚一层白色的盐结晶，我随手拿起一小块放到嘴里尝了尝，味道齁咸，是盐无疑。见湖水颜色清澈见底，我就在湖边洗了洗刚才摸到泥巴的手，待手上的湖水干了之后，竟留下一层白色粉末，而且拍打不掉。湖边那么多结晶，湖水自然是饱和状态，自己刚才怎么就没想到呢。 图九：翡翠湖 湖水梦幻般纯净的颜色使其成为拍照的绝佳地点，湖边随处可见的是拍照和被拍的俊男靓女，还有少数是像我这种负责拿东西拎包的摄（打）影（杂）助（人）理（员）。当无事可干的时候，我就看xxx和xss拍照，但这件事有风险，因为有时候会由于笑得太大声而被驱逐。有时候我也会想一些乱七八糟问题，比如湖水为什么那么绿？青海为什么那么多盐湖？为什么有的有盐，有的没有？这些问题一般都想不出个所以然，往往最后归结为”大自然的鬼斧神工”便不了了之。 随着逐渐日落，再加上寒风阵阵，我很快就被冻得瑟瑟发抖，且因为衬衣外套与湖水颜色相近，有时拍照还需要脱了外套，其中辛酸不言而喻。从翡翠湖回来之后我吃到了旅途中第二好吃的东西——羊肉炕锅，据说就是把羊肉、油炸土豆片和洋葱等放一块焖一下，最后放上一些烤饼。炕锅非常美味解馋，以至于我在多天之后的某个晚上写下这些回忆的时候还能不自觉地流下口水😂。同时我感觉这顿饭比较符合我在前文说的”好的“的标准，所以我决定这顿我请，因此其他人在吃这顿”白嫖羊肉炕锅“的时候应该比我吃到的更加美味，好在后来我也体验到了这个味道，就是第二天成哥在另一家店请我们吃羊肉炕锅的时候，这就是我感觉第一好吃的东西，当然，这是后话。 ","date":"2021-06-14","objectID":"/posts/21-06-14_journey-to-northwest/:5:0","tags":["游记"],"title":"西北游记","uri":"/posts/21-06-14_journey-to-northwest/"},{"categories":["乱七八糟"],"content":"U形国道，雅丹地貌，日食 U形国道不过是315国道上的一段上下坡，但因为其拍照效果较好，竟成了一处”网红“景点，不知道当初设计这段路的工程师会不会预料到这一点。我们到达时，路旁停了许多大大小小的汽车，而国道上多的是趁着没车的间隙走到路的中间，顶着寒风搔首弄姿的人。当然，不久我们也将成为其中的一员。但我们还算属于比较遵守交通规则的一类，如果远远地望到有车开来，便急忙躲开。另外还有一类人淡定地站在路中间，自顾自地拍照，根本不管有无汽车到来，甚至置汽车喇叭于不顾，见到此景，我们往往嗤之以鼻（虽然有五十步笑百步之嫌😂）。经过昨天翡翠湖边寒风的毒打，我们纷纷把最厚的衣服穿上，xxx不仅穿上了棉袄，头上还围了一个围巾，不过外形依旧漂亮，而且还多了一些常年在田间劳作的中国女性气质。由于我昨天被风刮的头稍微有点疼，因此今天在头上缠了一个类似于发带的东西，用以保暖，后来的事实证明此方法极为有效。 图十：U形国道 成哥驱车带我们前往南八仙（希望没记错）参观雅丹地貌，雅丹地貌按照我的理解，就是由于风雨等因素的侵蚀，使得土壤中比较柔软的部分逐渐消失，从而只剩下更为坚硬的部分，最终的呈现效果就是空旷的地面上伫立着一坨坨（按照xss的惯用量词）土堆，当土堆的数量很多，连成一片，放眼望去到处都是的时候，就显得颇为壮观，而当一种景色比较壮观的时候就可以用来拍照了😂，图十一中隐约可见的白色汽车即是我们这几天的交通工具，劳苦功高，应当被记录。 图十一：雅丹地貌 从雅丹地貌景点回来后，我们在大柴旦附近的一处淡水湖旁观看了日食，因为是日偏食，所以并不明显，但是我们借助专业的设备（四层太阳镜，虽然后来发现其实只相当于两层）还是能够清楚地看到太阳被咬掉的那一小口，图十二就是拍摄的照片。最后不得不提我们看日食的地方蚊子挺多的，但是跟明天将要遇到的相比，就算是小蚊见大蚊了。 图十二：日食（最小感光+最快曝光+最小光圈+太阳镜） ","date":"2021-06-14","objectID":"/posts/21-06-14_journey-to-northwest/:6:0","tags":["游记"],"title":"西北游记","uri":"/posts/21-06-14_journey-to-northwest/"},{"categories":["乱七八糟"],"content":"青海湖远眺，星空 由于行程变成了逆向，我们最后一站才终于到达了著名的青海湖。前往青海湖的途中路过了一个淡水湖——”可鲁克湖“，与”可鲁克湖“相临的是”托素湖“，这是一条咸水湖，关于这两个湖还有一个传说，这里就不介绍了，可以自行脑部一个男女相爱，家庭反对，最后双双殉情化身湖水的故事。我们沿着“可鲁克湖”边上的公路行驶，湖的四周芦苇丛生，水鸟繁盛，景色宜人，嫣然一副江南水乡的景象，很难想象公路的另一侧就是一望无际的戈壁。我们在湖边的一个入口处停了下来，然后兴冲冲地准备跑到湖边好好欣赏一下美景，临下车前成哥提醒了一句，这里蚊子比较多。还没走到河边我们就已经见识了”蚊子比较多“是什么样的场景，这里的蚊子不管是从质还是量上都远超我的想象，个头大且多，给人的震慑力极大。xss和xxx还没走到河边就匆匆返回了车里，我跟xyy抱着一睹究竟的决心，冒着枪林弹雨跑到河边，期间全身不敢有丝毫停歇，一边手舞足蹈，一边摇头晃脑。现在回想起来，当时的状态竟像是突发癫痫的精神病患者。待我到了河边，发现蚊子的数量更多，就匆匆往回返，也许蚊群对突如其来的美味佳肴还未来的及做出反应，所以我才有机会拔腿跑回车里，侥幸留得一条小命。像这种一边拼命跑一边在身上拍打的场景，我上次经历应该还是上小学那会捅马蜂窝的时候。 关于这个场景，我想到了李诞在吐槽大会上关于其小时候所经历的田园牧歌的场景的描述。大概意思是他小时候生活在草原，草原上蚊子又大又多，且叮咬的破坏力很大，如果上厕所的时候屁股被叮咬一口，可能连裤子都提不上，因此他在草原上露天上厕所的时候一般都是边上厕所边摇晃，长久以来养成了习惯，以至于现在上厕所不晃几下感觉方便不干净。 从”蚊子湖“离开之后又是不停的赶路，差不多中午的时候，成哥带我们去吃了一家牦牛排骨汤，临下车还叮嘱我们点普通碗就行，不要点其他的。这家排骨汤还挺不错，肉质松软，汤味清香，而且价格公道。吃饭的时候服务员试图把肉酱推销给我们，但是我们谨记叮嘱，啥也没买😂，并且我觉得他们的”特色肉酱“味道跟我小时候自己家里腌的酱豆（豆豉）味道差不多。 下午我们继续赶路，在翻越橡皮山的时候，已经可以远远地望见青海湖，远处的青海湖犹如一条宽宽的蓝色丝带，横铺在天地之间，其颜色纯洁晶莹如同一块蓝宝石，震撼之余不免惊呼”哇~太美了！“。我们在青海湖边上的一块山坡的草地上停下来拍照，虽然一路上经过很多草地，但这是第一次双脚真正踏上草地，感觉果然与仅在远处观看不同。近处的草地虽不像远远观看那么洁净纯粹，但多了些真实厚重的质感。草地上随处可见的牛粪打消了xss草地打滚的想法，于是腰上还贴着膏药的xss带着无处发泄的活力，在草原上活蹦乱跳。我对草地上随处可见的洞穴充满好奇，很想知道里面住的是什么繁盛的生物。趁他们拍照的时候，我往草地深处走去，还真的看到了一个土黄色的小生物在鬼鬼祟祟、探头探脑地四处寻觅，观察片刻，我认出这应该是一只老鼠。因为距离不远，我决定飞奔过去看能不能逮到一只，但等我快跑到跟前的时候，这个小家伙迅速地选了一个洞穴，并且钻了进去，至此我可以大概断定这些四通八达的洞穴就是老鼠洞。 图十三：青海湖 从草地上回来之后，我们继续赶路，成哥说要带我们去一个可以俯视青海湖的半山腰上，果然，在这里我们可以把青海湖近处的轮廓尽收眼底，远处湖天一色，宛如一块巨大的浅蓝色幕布。有如此美丽的景色，自然也免不了一通拍照，成哥的流水线再次启动，随着一声声”下一个“，我们一个个站到高处与身后的青海湖合影。景色太美，甚至后来成哥也忍不住让我们给他拍几张照片，其中的一张照片后来还成为了成哥的微信头像，这是后话。 从半山腰下来后，我们找了一家临近青海湖的宾馆，把行李放下之后，就去了青海湖边。入住的时候，宾馆老板给我们讲了一个可怕的故事，不久前五一假期的时候，从北京来的几名游客入住宾馆，但晚上又决定去青海湖边露营，宾馆老板告诉他们晚上湖边非常冷，试图阻止他们，但劝说无效，只得给他们退房。结果，当天晚上半夜的时候，几乎被冻僵的游客敲开了宾馆的大门，待老板把他们带到大厅的时候，发现他们已面色青紫，情况危险，于是急忙打通报警电话，大概三个小时之后救护车才把他们拉走抢救。如果换作其他地方，我可能会认为这是宾馆老板骗人的鬼话，目的是为了唬住那些想出去露营的人。但是经过了这几天对青海天气的切身体验，我丝毫不敢怀疑老板说话的真实性。 来到青海湖边，我照例又尝了一下湖水，像海水一样咸，据说湖里只生长了一种被称为潢鱼的鱼类（后来百度了下，其实还有其他几种小型鱼类），看着湖面上时不时飞过的海鸥，不知为什么湖里的物种不像海里那么丰富。相对于远处，青海湖边又是另外一种景色，站在湖边，视野极为开阔，目光所及皆是一片淡蓝，甚至远处天和湖之间的分割线都几不可辨，天地之辽阔，风景之纯净，令人心旷神怡。湖边有很多被精心打扮的马和牦牛，用于给游客提供拍照服务，无人光顾时，这些牲畜就被拴在木桩上，当有游客付钱，便可以骑在他们后背上溜达一圈，拍几张照片，甚至有时为了拍照效果，牵马的小贩还会把它们赶到湖边的浅水区里。不管牵着走还是拴在那，这些牲畜始终低头沉默，任劳任怨，看不出兴奋，也没有反抗，甚至没有任何多余的动作，想必如此循环往复，日复一日，它们也早已习惯了吧，想到这里，心里不免有些伤感。在这美丽壮观的青海湖边，看似自由的马和牛被绳索拴在了这里，看似掌握牲畜命运的小贩被生活拴在了这里，而此刻看到此情此景的我呢？ 图十四：银河 同伴们制定了看银河和日出的计划，大概计划是先回去睡觉，待差不多一点多的时候，到宾馆的天台上看银河，拍星轨，到差不多三点的时候再回去睡觉，然后五点半起来去青海湖边看日出。夜晚就这样被均匀地切分开了😞，听完这个计划，我只想赶快回到房间珍惜现在这来之不易的睡觉时间。在差不多一点多的时候被xyy叫醒去看银河，本来对银河还抱有些许期待，但发现这不就跟我曾在家里的某个晚上上厕所的时候无意间瞥见的一样吗，也就觉得不过如此啊。依赖于xyy强大的修图技术，最终的图片如图所示。xyy还尝试拍出星轨，但是由于相关经验的缺乏，以及对相机功能的了解不够准确，所以最终只得到了一个虚线形式的星轨图。 图十五：虚线星轨 ","date":"2021-06-14","objectID":"/posts/21-06-14_journey-to-northwest/:7:0","tags":["游记"],"title":"西北游记","uri":"/posts/21-06-14_journey-to-northwest/"},{"categories":["乱七八糟"],"content":"青海湖日出，返程 早上看日出不出意外，又是在瑟瑟发抖中度过的。待我们到达青海湖边的时候，湖边已经有不少人了，我们一个个站在湖边像是虔诚的朝圣者，期待着旭日东升，一边瑟瑟发抖，一边目不转睛地看着东方，生怕错过了太阳升起的那个瞬间。而太阳却没有直接了当地升起来，而是犹抱琵琶半遮面，躲在了云层后面，仿佛韬光养晦一般，只待云雾散去，便一鸣惊人。事实也确实如此，当太阳从云层后面出来后，就几乎无法直视了。因此总的来看，这次看日出并不算特别成功。不过此时我早已坚持不住，疲倦加寒冷使我对日出漂不漂亮提不起更多的兴趣，目不转睛地看着太阳是因为实在没事干，并且不想辜负自己所付出早起的艰辛，才尽可能地多看几眼，仿佛这样盯得头晕眼花能够更加划算。 图十六：青海湖日出 路上经过了一些藏民居住区，成哥带我们去藏民家里品尝原汁原味的牦牛酸奶，味道酸爽可口（皱眉表情），但是为了能够珍惜这次品尝的机会，我坚持没有加糖。藏民小姐姐还主动提出可以把自己的藏族衣服借给xxx和xss来拍照，肉眼可见ta俩两眼放光，迫不及待地回答说“可（太）以（好）吗（了）”。藏民小姐姐转身拿衣服，并颇为客气的说“希望你们不要嫌弃”，从俩人跃跃欲试的反应来看，“不嫌弃，不嫌弃”必然是发自内心的回答。于是我们有了此次旅程最后一组照片，且是为数不多的成哥和我们的合照。 在回西宁的路上路过了宗喀拉泽，据说是经过某某机构认证的最大的拉泽（据说意为殿堂）。成哥说这个景点不要票，结果我们找了半天没看到入口，于是找到路边一个卖”特产“的人问路。也许那大哥”特产“卖的不顺利，所以颇为不爽地指着自己的嘴跟我们说”鼻子底下是张嘴，找不到路，你们不会找人问吗？“，我们被这位大哥义正言辞的回答给镇住了，竟一时语塞。只是事后我还是没想明白我们找它问路这件事为什么不符合它说的”找人问路“。 等到我们终于问到了路才知道，原来这个景区需要买票，票价30，听闻票价我们扭头便走，但卖票的大姐马上叫住我们，问我们是不是学生，得到肯定的回答后，她告诉我们学生票可以半价，不过从她的反应来看，我们是不是真的学生她也并不在意，只不过是想找一个合理而又体面的理由留住这几个来之不易的顾客罢了，所以我们连学生证都没拿，她就认可了我们的学生身份。后来我就在想，如果我们说不是学生，她会不会告诉我们身份证也可以半价😏。当然，这都是猜想，没有证据，不能凭空诬陷别人，但后面遇到的大师则是有真凭实据的。待我们买完”学生票“之后，就进入到景区，卖票大姐煞有其事地给我们每个人献上了一个黄布条，据说叫哈达。我心想花15块钱搞一条黄布条也行啊，虽说对我来说啥用没有，还没等我高兴完，她说这不是给我们的，是让我们贡献给山神的。当时心想，好家伙（学自xss）还有这一手，但后来的事实表明，我还是小瞧他们了，这只是下一个套路的开始。所以后来回想起来，感觉像是花15块钱买了个套路套餐。 图十七：宗喀拉泽 书归正传，可能是因为所谓的景区几乎没有什么人，所以我们进入景区刚走上阶梯就有一个“导游”在此等候。大概意思是她会带我们完成游览，整个过程颇像商店的导购（此处伏笔）。她带我们煞有介事地拜完四臂菩萨之后，就把我们领到了菩萨像后面的大师处贡献哈达。刚还在打盹的诵经大师看见有顾游客过来，立马打了个哈欠提了提神，然后开始念念有词（此处没有任何不敬）。导游告诉我们这位大师正在为我们诵经祈福，然后说会逐个带我们去另外的祈福大师那里贡献哈达。因为我是最后一个，看同伴一个个被带走，百无聊赖，就开始东张西望。导游看到之后走过来告诉我说你不用着急，你在这里虽然等待的时间长一点，但是接受大师祈福的时间也更长，得到的福祉也就更多一些。听闻此话，原本已经又开始打盹的诵经大师又开始“咪咪嘛哞”念了起来，我告诉导游我不着急，就是四周看看。然后很快就到我了，我被带到祈福大师那里，大师请我坐下，我颇为虔诚地端坐在凳子上，大师首先问我年龄、学历、职业等信息，我做了一一回答并且确信这只是祈福所需的必要信息，而不是用来确认我的经济状况。然后大师就开始了一段语重心长、循循善诱的教导，大概意思是我是高学历人群，具有更大的能力，能力越大责任也就越大，应该多承担一些社会责任，多利用自己所学的知识做利国利民的事情，并且要活到老学到老等等。虽然是说教式的老生常谈，但是面对长辈的发自内心、感人肺腑的教导我是不敢表现出一丝不敬的，因此频频点头并附带着“是”，“是的”，“好的”等简短而表明态度的回答。这样的过程大概持续了两分钟，也许大师感觉时机已经差不多成熟（或者是因为没啥可说的了），然后话锋一转“今日你与山神有缘，可以向山神敬献佛灯以祈求保佑，但是事先说好，佛灯需要一定的花费，有100、200……不等”。待他说到“有缘”这个词的时候，我便预感到可能有事情要发生，并开始组织语言，力求让他明白我是如何地真心不希望麻烦山神。他开始报价格的时候，我就打断了他，诚恳地跟他表示我作为一个在校生，还没参加工作，家里情况又不好，能力实在有限等等。当时甚至还想把我认为这种花钱卖灯的行为有可能亵渎神灵的观点告诉他，但是考虑到这样可能会被打，所以就没说。事实上大师也没给我机会说，待他大概确定我并不想祈福之后，直接左手一挥“好，那缘分尽了，请这边走”，我只得悻悻离开。事后我对这段并不愉快的交流深表遗憾，他们作为能将想法直达山神的大人物，得罪他们岂不等于得罪山神，想到这里不觉心中惊恐万分。后来问同伴，他们也都有类似的经过，因此心里也就稍稍释然了些。最后为了防止别有用心的人乱作揣摩，我觉得有必要进行说明，我没有任何亵渎或者不尊敬神明和宗喀拉泽大师们的意思。 最后再次到达西宁，临走之前想去尝一尝成哥安利的水煮羊肉，但是无奈逛了好几家都没有开门，成哥说是现在时间太早，因为这些店一般都是晚上开张。于是，我们就略带遗憾地提前去了机场，不过略有遗憾也不是坏事，有遗憾才有下次再来的理由嘛。机场跟成哥离别的时侯，我准备效仿武侠人物，抱拳说句“青山不改，绿水长流，咱们后会有期”，但是感觉颇为中二，所以就只保留了台词部分。想到回学校之后，也很快就要收拾东西走人了，伤感加倍，看来六月是离别的季节呀，也许正是知道分离时的悲伤，才更应珍惜相处时的不易。 ","date":"2021-06-14","objectID":"/posts/21-06-14_journey-to-northwest/:8:0","tags":["游记"],"title":"西北游记","uri":"/posts/21-06-14_journey-to-northwest/"},{"categories":["乱七八糟"],"content":"总结 最后总结，因为xxx和xss在拍照方面做了充足的准备（我后来才明白拍照是主要目的），因此我也就蹭了很多照片，这几天拍的照片甚至比我在这之前拍的总照片还要多。去机场的路上，我们从发朋友圈的话题说到了写攻略的事，我再一次大言不惭（最近的一次是扎辫子）地说我要写篇游记，因为感觉旅游攻略就是简单的罗列，水平太低。但是后来发现自己文学水平的确不行，写着写着还是变成了简单的罗列，不得不再次感慨，原来没有不行的题材，只有不行的人呀😄。 其实本来就有写几篇日记把旅行记录下来的打算，因为反正日记只有自己看，所以打算随便写写。但是后来吹了牛，就不得不好好写了，但没想到越写越多，而且很难写到自己觉得还算满意，除了需要仔细回想重要经历之外，还要反复修改，很是不容易。现在仍然能回想起当时说写游记的时候，成哥突然转过头并投来期许的目光，并很快把微信二维码发给我，让我附在游记后面，当时就意识到自己挖的这个坑不得不好好填了😂。后来同伴也对游记怀有很大的期望，并给予很多支持（有事实根据，微信秒回提供图片）。但是自己能力实在有限，如果效果不尽如人意，还请多多担待～ 回想这一路，绝大部分时间都待在车里，因为担心会晕车，所以我不敢长时间看手机（以至于剧本杀也不敢玩），因此只好找一个不需要看手机的方式来打发时间。车内有蓝牙音响，且成哥喜欢播放音乐，因此我就提出用我的手机连接蓝牙放歌，所以随后的几天，我基本掌握了车里的点歌权。有时大家一块唱，便用我的手机轮流点歌，但我点的居多，且大部分时间都是我自己在点，几天过后，我的歌单几乎播放了一遍，导致大家对我的音乐爱好有了确切的掌握。因为一路上戈壁居多，且考虑到前有“沙漠蹦迪”，那么且将这个过程称为“戈壁KTV”吧。因为开头写唱歌，最后就也以此结尾吧，首尾呼应一下。 最后是成哥的微信二维码（头像更换之前）： 2021年6月5日——6月12日 青甘大环线 一路花香一路唱 ","date":"2021-06-14","objectID":"/posts/21-06-14_journey-to-northwest/:9:0","tags":["游记"],"title":"西北游记","uri":"/posts/21-06-14_journey-to-northwest/"},{"categories":["algorithm"],"content":"概述 原本想把自己AES加密算法的整个实现过程给详细复述下来，分享给想学习的同学，也方便自己复习，但后来发现该工作量太大，加上作业太多没有过多的时间去写。所以就想把自己在学习的过程中多遇到的好的文章进行汇总，避免重复性的工作，因为我感觉有的文章的介绍和配图写的非常好，再次重复也没有意义。本文里我会将文章的链接附上，如有侵权，敬请告知！ 因为最近要完成课程作业，实现AES128加解密，本以为就是一个简单的算法实现，后来发现AES加密的每一步都挺难，而且都涉及到我没听过的概念，所以最近看了很多帖子、资料。最终终于能够解决这个问题。关于AES算法的介绍，网上有很多的帖子，所以我就不进行赘述了，我只是希望将我遇到的一些比较难以理解的点进行详细的叙述。 实现AES算法主要包括以下学习步骤： GF（2^8）域上的多项式运算 扩展的欧几里德算法 生成S盒 生成逆S盒 S盒置换 行移位 列混合 生成秘钥 循环加密 其中1、2、3、4步都跟S盒生成有关，根据我所看的一些博客，S盒的生成涉及到数论的基础知识。如果没有基础的话，1、2是要专门去学习的，我在这两步上花费了很多时间。但是在网上也可以找到很多AES算法，他们用的是现成的S盒，没有前4步，直接用现成的S盒置换，这样相对会容易一些。但是本着刨根问底和多学习知识的原则，我还是去学习了S盒的生成方式。第5步就是将每一个字符进行查表替换，没有什么难以理解的地方，所以相对而言比较容易。第6步应该是整个过程当中最简单的一步了，就是进行一个循环移位。第7步列混合涉及到矩阵和多项式的乘法，所以还是有一定难度，。。。 如果想从整体上了解AES加密的完整过程，那么下面几篇文章不管从叙述还是插图上来看都是很不错的，几篇文章介绍的方式不同，但是原理都是一样的，对比结合着看会更有帮助： https://www.cnblogs.com/block2016/p/5596676.html https://blog.csdn.net/u012721519/article/details/79612128 https://www.cnblogs.com/luop/p/4334160.html http://www.alonemonkey.com/2016/05/25/aes-and-des/ 但是仅从这几篇文章来看的话，对于像我这样的小白而言还是没有办法实现的，因为各个步骤介绍的并不具体，尤其是对于缺少基本数学知识学习的同学很难理解。所以这几篇文章可以作为整体进度的把控，接下来看怎么一步步学习实现。 ","date":"2021-06-05","objectID":"/posts/aes/:1:0","tags":["AES"],"title":"AES算法详解","uri":"/posts/aes/"},{"categories":["algorithm"],"content":"S盒 我在学习这个算法的时候，在S盒的生成及置换上花费的时间是最多的。可能是因为基础较差，所以需要学习的东西比较多，所以我将这一部分进行了逐项的划分。关于S盒的生成及置换，这篇博客进行了非常详细的介绍，但是有一些东西我还是没明白，所以又参考了很多其他文章，才把这一部分搞明白。建议初学者以这篇博客为基础进行学习： https://blog.csdn.net/u011516178/article/details/81221646 下面进行分步的介绍。 ","date":"2021-06-05","objectID":"/posts/aes/:2:0","tags":["AES"],"title":"AES算法详解","uri":"/posts/aes/"},{"categories":["algorithm"],"content":"GF(2^8)域上的多项式计算 因为整个过程很多，所以我决定分为多个文章分别进行叙述，首先是GF（2^8）域上的多项式计算，因为以前也没有学过相关知识，很多概念都是第一次见到，所以这部分花了很长时间去学习。在学习这个之前，我们需要知道为什么去学习这个东西，AES加密中的哪一步用到了该知识点呢？ S盒的置换就是将0~2^8中的任意一个字节置换为另外一个，置换的原则是将该元素置换为在GF（2^8）域上的乘法逆元，什么是GF（2^8）域？什么又是逆元呢？这些定义的准确数学描述我不太懂，根据本次应用，我可以给出粗略说明，GF（2^8）有限域大概就是指定义在该域中的数值经过定义在该域上的函数运算，其结果也都在该域内， 借用网上的一个例子进行说明： 图一：GF(7)运算 那什么又是乘法逆元呢，形如： $(a\\cdot a_{-1} ) \\% p=1$ 其中p为有限域的范围，这里按理说应该为2^8，但是却不能取这个数，因为2^8并不与其内的每一个数互质，所以只能选一个更大的质数（具体原因请参考扩展的欧几里德算法），AES算法中p的值选的是0x11B, 我也不知道为什么，可能是约定俗成的吧，因为如果想找一个稍微比255大的质数，不知道为什么要取283（0x11B）。a 为有限域内的整数，那么 a_{-1} 即为 a 在有限域上的逆元。至此，我们知道逆元是什么，但是具体怎么去求解还不太清楚，这一部分请参照扩展的欧几里德算法。（更新）后来为了加深学习，我又自己写了篇博客。 我接下来继续说GF（2^8）域上的多项式运算，因为把基本的运算搞清楚是计算GF（2^8）域上乘法逆元的前提，该域上的加减乘除运算是与传统的运算所不同的，具体的多项式运算请参考GF（2^8）域上的多项式运算。当然，也可以先学习扩展的欧几里德算法，然后再学习该部分，实现的时候将欧几里德算法中的四则运算换成GF（2^8）域上的多项式运算就行了。关于GF（2^8）域的计算介绍参考以下几篇博客介绍： https://blog.csdn.net/luotuo44/article/details/41645597 https://blog.csdn.net/shelldon/article/details/54729687 http://abcdxyzk.github.io/blog/2018/04/16/isal-erase-3/ 在四则运算中，加减运算就是简单的异或运算，很简单。而乘除运算则是以乘法运算为基础，所以四则运算中最主要的是理解乘法的运算，这篇https://blog.csdn.net/bupt073114/article/details/27382533文章详细介绍了乘法运算，以及其实现。 ","date":"2021-06-05","objectID":"/posts/aes/:2:1","tags":["AES"],"title":"AES算法详解","uri":"/posts/aes/"},{"categories":["algorithm"],"content":"扩展的欧几里得算法 待掌握了GF（2^8）域的运算知识后，应该去学一下拓展的欧几里得算法，对于该算法，上面所给出的关于S盒生成的综述博文里已经参考相关教材进行了非常详细的论述，所以关于这部分知识可以同样参考这篇博文（参考文献10）， 还可以参考这篇博客 如果还不明白，也可以自行查找其他关于拓展欧几里得算法的介绍。 ","date":"2021-06-05","objectID":"/posts/aes/:2:2","tags":["AES"],"title":"AES算法详解","uri":"/posts/aes/"},{"categories":["algorithm"],"content":"S盒生成及置换 关于S盒的生成及置换，同样参考文献10，该文章已经进行了非常详尽的描述与代码实现。待自己完成后也可以参考博客中的结果进行检验。 ","date":"2021-06-05","objectID":"/posts/aes/:2:3","tags":["AES"],"title":"AES算法详解","uri":"/posts/aes/"},{"categories":["algorithm"],"content":"行移位 行移位就是对每行数据进行相应的循环移位，没有难以理解的地方，应该是整个加密过程最简单的部分，关于移位的规则，可以参考文献1、2、3、4，均有详细的图示介绍。下图来源于文献4： 图二：行移位 ","date":"2021-06-05","objectID":"/posts/aes/:3:0","tags":["AES"],"title":"AES算法详解","uri":"/posts/aes/"},{"categories":["algorithm"],"content":"列混合 列混合就是将数据矩阵乘上一个矩阵，解密的时候乘上原矩阵的逆矩阵进行解密，秩序要按照步骤一步步来即可，同样没有难以理解的地方，按照参考文献1、2、3、4的介绍进行操作就没有问题。关于列混合还可以参照这篇专门介绍的文章[11]，其对于列混合又专门的介绍与实现，而且还有检验数据。下图参照文献4中图片： 图三：列混合 ","date":"2021-06-05","objectID":"/posts/aes/:4:0","tags":["AES"],"title":"AES算法详解","uri":"/posts/aes/"},{"categories":["algorithm"],"content":"密钥生成 密钥的生成过程稍微有些麻烦，需要仔细参考规则，避免搞错，但是只需要理解操作规则即可，不需要理论理解，还好参考文献3、4中都有非常生动的图示。下图来源于文献4： 图四：密钥生成 ","date":"2021-06-05","objectID":"/posts/aes/:5:0","tags":["AES"],"title":"AES算法详解","uri":"/posts/aes/"},{"categories":["algorithm"],"content":"循环加密 循环加密就是对上述过程重复进行若干次。具体实现参照文献1、2、3、4。 ","date":"2021-06-05","objectID":"/posts/aes/:6:0","tags":["AES"],"title":"AES算法详解","uri":"/posts/aes/"},{"categories":["algorithm"],"content":"解密 解密过程就是将上述的过程反过来执行一遍，原本置换的就置换过来；原本移位的就反向移过来；原本乘上矩阵的就乘上她的逆矩阵。。。上面关于每个加密过程的参考文献都有相应的解密过程。 ","date":"2021-06-05","objectID":"/posts/aes/:7:0","tags":["AES"],"title":"AES算法详解","uri":"/posts/aes/"},{"categories":["algorithm"],"content":"实现 关于AES128的加密完整实现，可以参照代码 https://github.com/xinyu-yang/AES128-CBC，此代码的实现几乎都是参照上文的介绍，唯一不同的是在加密的时候采用了CBC模式，具体什么是CBC加密模式，如果不清楚的可以自行百度。如果有时间我也会把这部分补全。 ","date":"2021-06-05","objectID":"/posts/aes/:8:0","tags":["AES"],"title":"AES算法详解","uri":"/posts/aes/"},{"categories":["algorithm"],"content":"参考文献： https://blog.csdn.net/zhjchengfeng5/article/details/7786595 https://www.cnblogs.com/block2016/p/5596676.html https://blog.csdn.net/u012721519/article/details/79612128 https://www.cnblogs.com/luop/p/4334160.html http://www.alonemonkey.com/2016/05/25/aes-and-des/ https://blog.csdn.net/luotuo44/article/details/41645597 https://blog.csdn.net/shelldon/article/details/54729687 http://abcdxyzk.github.io/blog/2018/04/16/isal-erase-3/ https://blog.csdn.net/bupt073114/article/details/27382533 https://blog.csdn.net/u011516178/article/details/81221646 https://blog.csdn.net/u012620515/article/details/49893905 https://www.cnblogs.com/frog112111/archive/2012/08/19/2646012.html https://www.cnblogs.com/xinyuyang/p/11439638.html ","date":"2021-06-05","objectID":"/posts/aes/:9:0","tags":["AES"],"title":"AES算法详解","uri":"/posts/aes/"},{"categories":["乱七八糟"],"content":" Hello, everyone. It is my great honor to have this opportunity to introduce myself, my name is 🐏💗🐟, I am a graduate student from xxx university, my major is cyberspace security. The aim of my major is to build a secure and reliable cyberspace. As internet play a more and more important role in people’s daily life, people upload more and more critical information in the internet, if the security can not be promised, people will suffer unaffordable loss. After three years learning, I think network security and privacy preserving is an interesting and meaningful thing, that is why i apply for this project. I hope I can do more useful research in the future.  I think the combination of work and rest is a long-term way. In my spare time, I like reading books, ranging from martial arts fiction to classic masterpieces. I also like doing sports, playing basketball, playing badminton, swimming and so on. I am a beginner in swimming and I am learning freestyle. I hope I can go further on the road of scientific research. ","date":"2021-05-27","objectID":"/posts/21-05-27_self-intro/:0:0","tags":[],"title":"记一篇英文自我介绍","uri":"/posts/21-05-27_self-intro/"},{"categories":["math"],"content":"问题概述 该问题由第一位也是唯一一位华人图灵奖得主姚期智先生于1982年提出，问题很简单： 在缺少第三方公信平台的情况下，有两个百万富翁希望比较财富的高低，但是又不想让对方知道自己的具体的财富有多少。 该问题是另外一个通用问题的特殊形式，即： $a_1, a_2 … a_n$分别拥有值$x_1, x_2 … x_n$，如何在互相不泄露这些值的情况下计算$F(x_1, x_2 … x_n)$ 姚期智的这篇论文就是讨论了以上问题，对于百万富翁问题，记得有人提出可以采用称重的方法，即将富翁所有的财富转换成金子，并放置在不透明的盒子里，然后用一个天平来测量哪一个盒子更重。这是一个不错的方案，但是还是隐含借助了第三方的可信机构，抛开天平的可信性不谈，给富翁兑换金子的人（即使是多个）总是知道富翁财产的。 ","date":"2021-05-12","objectID":"/posts/21-05-12_millionaire-problem/:1:0","tags":["ZK"],"title":"百万富翁问题","uri":"/posts/21-05-12_millionaire-problem/"},{"categories":["math"],"content":"解决方案 那能不能借助科学的力量解决该问题呢？姚期智在他的论文里给出了肯定答案，论文中提到其一共提出了三种解决方案，但是限于篇幅只介绍了其中一种，本文也主要介绍该方法，该方法非常巧妙，让人拍案称绝，也让我感受到了图灵奖实力的冰山一角。 该方法主要借助公钥加密和单向函数来实现双方对对方消息的不可知。 具体内容如下： 假设双方为A和B，财产分别为a和b，财产范围为[0, N]。首先由A生成一对公私钥对$(PK,P)$（不失一般性），然后将公$PK$发送给B。B选择一个随机数r，然后计算$n=Enc(PK,r)-b$，并将$n$发送给A。 A收到之后便使用$n+i,\\ i\\in [0,N]$构造一个数组，并使用私钥进行加密，最终的结果为：$(Enc(P,n),Enc(P,n+1)…Enc(P,n+N))$，其中有一个$i$的值为A的财产a，即有一个$n+i$的值为$Enc(PK,r)$，但是和明显A并不知道是哪一个。 接下来A进行进一步操作，其将数组中序号大于其财产的值加一，即最终值为$Enc(P,n+i)+1,\\text{if i \u003e a}$。然后选取一个位于财产范围内的素数$p$，将数组中的所有数值对$p$取余。最终得到： $$ (Enc(P,n)\\mod p, Enc(P,n+1)\\mod p, … $$ $$ (Enc(P,n+a)+1)\\mod p, … (Enc(P,n+N)+1)\\mod p) $$ A将该数组和$p$发送给B。 B收到该数组之后，使用PK对公式中的每一项进行解密，如果第b项的值为$r\\mod p$，那么说明A的财富值大于B的财富值，否则，A的财富值小于等于B的财富值。因为，如果A的财富值大于B的财富值，则数组中的第b项为$Enc(P,n+b)\\mod p = Enc(P, Enc(PK, r))\\mod p$，否则该值将为$Enc(P,n+b)+1\\mod p$。 通过以上方式可以实现在不互相泄露信息的情况下比较财富的数值，其中加一和取余是核心操作，尤其是取余，因为其相当于一个单向函数，所以可以向B隐藏A的信息，如果没有该步骤，那么A的信息将很容易被泄露。 ","date":"2021-05-12","objectID":"/posts/21-05-12_millionaire-problem/:2:0","tags":["ZK"],"title":"百万富翁问题","uri":"/posts/21-05-12_millionaire-problem/"},{"categories":["math"],"content":"参考文献 [1] A. C. Yao, “Protocols for Secure Computations,” [2] https://zhiqiang.org/cs/yao-millionaires-problem.html ","date":"2021-05-12","objectID":"/posts/21-05-12_millionaire-problem/:3:0","tags":["ZK"],"title":"百万富翁问题","uri":"/posts/21-05-12_millionaire-problem/"},{"categories":["algorithm"],"content":"算法介绍 按照出现时间，该算法比count-min sketch出现的时间更早，但似乎没有count-min sketch应用广泛。该算法的大体思想与count-min sketch相似，只是有少许不同。 首先介绍算法的过程，初始化$t$个独立的hash函数$h_1, h_2, …,h_t$，每一个hash函数都是从集合$[n] \\to [k]$的映射。同时还要初始化$t$个符号函数$s_i : [n] \\to [\\pm 1]$，然后初始化一个二维矩阵，如下图所示： 对于具有m个元素的集合A，对其进行如下操作: Set all $C_{i,j}=0$ for i=0 to m do for j=0 to t do $C_{j,h_{j}(a_i)}$ += $s_j (a_i)$ 该操作与count-min sketch唯一不同的点在于，最后加的值有可能是1或者-1。 当查找一个元素出现的次数时，只需要计算 $$\\check{f_{q}}=median\\ C_{j,h_{j}(q)},\\ j\\in [t]$$ 这里与count-min sketch不同的是，本方法所产生的值有可能是正也有可能是负，有可能假阳也有可能假阴，而count-min sketch中只有正，所以一定会产生假阳性。仅从直觉上来判断，似乎选中间值是合理的，因为正负相互抵消，比较理想的情况就是恰好抵消完，那就没有误差了。 ","date":"2021-04-12","objectID":"/posts/21-04-12_count-sketch/:1:0","tags":["hash","heavy hitter"],"title":"Count Sketch","uri":"/posts/21-04-12_count-sketch/"},{"categories":["algorithm"],"content":"分析 参考了几篇文章，甚至参考了作者的原文，其证明方法都不太一样，尴尬的是我一个都没看懂😂，哎~等能看懂再补上吧。。。 路漫漫其修远兮，吾将上下而求索啊 ","date":"2021-04-12","objectID":"/posts/21-04-12_count-sketch/:2:0","tags":["hash","heavy hitter"],"title":"Count Sketch","uri":"/posts/21-04-12_count-sketch/"},{"categories":["algorithm"],"content":"代码实现 参考文献 https://wangshusen.github.io/code/countsketch.html 中就有一个代码实现，而且有动态图展示。 ","date":"2021-04-12","objectID":"/posts/21-04-12_count-sketch/:3:0","tags":["hash","heavy hitter"],"title":"Count Sketch","uri":"/posts/21-04-12_count-sketch/"},{"categories":["algorithm"],"content":"参考文献 https://web.stanford.edu/class/cs369g/files/lectures/lec8.pdf https://www.cs.rutgers.edu/~farach/pubs/FrequentStream.pdf https://wangshusen.github.io/code/countsketch.html ","date":"2021-04-12","objectID":"/posts/21-04-12_count-sketch/:4:0","tags":["hash","heavy hitter"],"title":"Count Sketch","uri":"/posts/21-04-12_count-sketch/"},{"categories":["信口开河"],"content":" 最近看了一些科普方面的文章和视频，所以对气候变化这件事情有了一些思考，特此记录。因为只是作为个人天马行空思考的记录，所以并无科学严谨性可言，因此几乎不会引用任何的专业文献和专业数据。  我们现在在讨论气候变化的时候，总是在说由于人类活动的原因，使得全球气候变暖，或者森林遭到砍伐，土地荒漠化等。这些环境的变化在人类生存的历史上也许是重大的环境变迁，但是如果纵观地球的发展史，就会发现，相对于地球环境变化的惊涛骇浪，现在我们所经历的变化不过是平静湖面上的微波涟漪。 那么为什么我们会对现在的环境变化如此担忧呢？我感觉答案正如某院士（记不清楚名字）在采访时所说的那样，人类不是在保护环境，人类只不过是在保护自己。  地球的环境一直都处在变化当中，其中不乏有极端夸张的气候环境，极寒或者极热，但是地球也没出问题，所以现在地球出现的这点变化，还轮不到人类去拯救的地步。因此是不是可以理解为人类所拯救的那个“地球”只不过是人类所适宜生存的那个地球状态。 毕竟相对于地球气候变化的幅度，人类所能适宜生存的气候范围实在是太小了，人类的历史相对于地球生命的历史也不过是短短一瞬。  不得不感叹人类在大自然面前如此渺小，即使人类已经在科技方面取得了重大进步，已经具备了一定的抵御自然灾害的能力，甚至有时会产生人类已经战胜大自然的错觉。但是当我们面临大自然的时候，显得是那么的无能为力。人类毫无疑问是大自然的一部分，也就是从某种意义上讲人类能够对大自然所做的一切，也都是大自然的命运安排。这种宿命论似乎有些悲观，因为人类看似具备自我思考的能力，但很可能永远无法突破大自然的限制。但并不是说人类的探索都是没有意义的，毕竟不去探索，我们永远无法知道自己可以做到什么。  个人感觉人类应当具备适应环境变化的能力，而不是一直待在舒适圈里。因为也许人类的出现将不可避免地导致大自然朝向某个方向变化，即使人类真的能保护现有环境，抑制全球变暖，使这些较为明显的环境因素保持稳定，但是我们对地球地改变将潜移默化地从很多方面体现出来，也许是人类想象不到的方面。 如果人类不能适应现有生存环境之外的环境，那么终将有一天会被能够适应的其他生命所代替。 ","date":"2021-04-10","objectID":"/posts/21-04-10_climate-change/:0:0","tags":[],"title":"当我们在谈论环境保护的时候我们在谈论什么？","uri":"/posts/21-04-10_climate-change/"},{"categories":["algorithm"],"content":"摘要 该算法以hash函数为基础，主要用来解决membership问题，也就是判断某个元素在不在某个集合中，可以在常数时间进行判断，但是判断结果可能存在假阳性的问题，也就是一个元素不在集合中，但是却被误判为在。该算法的实现同样是采用了以减少精确度换取较小的空间开销的思想，具体损失多少精度，又能换回多少空间是本文要解决的问题。 ","date":"2021-04-07","objectID":"/posts/21-04-07_bloom-filter/:1:0","tags":["hash"],"title":"Bloom Filter","uri":"/posts/21-04-07_bloom-filter/"},{"categories":["algorithm"],"content":"算法 该算法很简单且优美，下面对其进行简单描述，首先初始化一个长度为$m$的比特串$B$，并选择$k$个$[N]\\to [m]$的hash函数，对于一个每一个元素都属于$[N]$的长度为$n$的集合$S$，对其进行如下操作： Set B[.]=0 for i=1 to n do for j=1 to k do $B[h_j(S_i)]=1$ 算法很简单，就是对每一个元素，用所有的hash函数进行计算，并将所计算出的所有位置置1。查找也很简单，就是进行类似的操作，如果元素$q$的所有的hash值对应的值均为1，那么就判断元素在该集合中。 显而易见，如果$q$真的在集合中，那么肯定能得到肯定的结果，但是得到肯定的结果不代表其一定位于集合中。因为会存在假阳性的问题，所以现在的问题就是如何评估假阳性出现的概率，以及如何选取$k$和$m$的值来使内存占用和准确度都能比较好呢？ ","date":"2021-04-07","objectID":"/posts/21-04-07_bloom-filter/:2:0","tags":["hash"],"title":"Bloom Filter","uri":"/posts/21-04-07_bloom-filter/"},{"categories":["algorithm"],"content":"分析 首先分析对于一个元素，其不在集合当中，但是将其判断为在集合当中的概率。假设该元素经过hash函数计算之后的值分别为$a_1, a_2, …, a_k$，对于任意一个$a_i$的值为0的概率为： $$ P(B[a_i]=0) = (1-1/m)^{nk} $$ 因为假设所有的元素的hash值服从均匀分布，所以落到每一点是等概率的$1/m$，而只有当所有元素的所有hash值（共$nk$个）都没落到$a_i$点，其值才为$0$。 然后计算一个元素假阳性的概率，其假阳性代表所有的hash值对应的点均为$1$，即： $$ P(\\forall.i\\ B[a_i]=1) = (1-(1-1/m)^{nk})^k $$ 然后又根据当$m$的值较大时的近似公式： $$ (1-1/m)^{nk}=e^{-nk/m} $$ 可以将上述公式化简为$(1-e^{-nk/m})^k$。我们希望该值尽可能的小，因此在$m,n$值确定的情况下，我们希望通过$k$值的选取使得其值尽可能的小，求$(1-e^{-nk/m})^k$的最小值就相当于求$k\\cdot ln(1-e^{-nk/m})$的最小值。求导应该可以算出来，但这里有一个技巧，我们假设$p=e^{-nk/m}$，则上式可以化为： $$-\\frac{m}{n} \\ln p\\ln(1-p)$$ 根据对称性，可知当$p$取$1/2$时，其值最小,此时k的值为$\\frac{m}{n} \\ln2$。该网站有一个相应的对应表格，我们截取一部分如下图所示： -- -- -- 从图中可以看出，当$m/n$比例一定时，假阳性的值随$k$先减小再增大，比如当$m/n=9$时，其最小值在$k=6$处取得。 我们已经算出了$k$的最优取值，将其代入到假阳性计算公式中可得： $$ P = (1/2)^{\\frac{m}{n} \\ln2} \\approx (0.6185)^{m/n} $$ （居然是黄金比例0.618😮） 如果我们想让其错误率小于$\\epsilon$，就需要计算 $$ (1/2)^{\\frac{m}{n} \\ln2} \u003c \\epsilon $$ 通过上式可得，$m$的取值范围为$m \u003e n\\log e \\log\\frac{1}{\\epsilon} \\approx 1.44 n \\log\\frac{1}{\\epsilon}$。所以该方法总的空间复杂度为$k$个hash函数和一个比特串的开销，即： $$ k \\log n + n \\log(1/\\epsilon) = (n + \\log n) \\log(1/\\epsilon) $$ 感觉占用的空间也不小啊~ 以上就完成了大概的分析，但其实专业的分析好像很复杂，我尝试了一下，没看懂😂 ","date":"2021-04-07","objectID":"/posts/21-04-07_bloom-filter/:3:0","tags":["hash"],"title":"Bloom Filter","uri":"/posts/21-04-07_bloom-filter/"},{"categories":["algorithm"],"content":"实现 TODO ","date":"2021-04-07","objectID":"/posts/21-04-07_bloom-filter/:4:0","tags":["hash"],"title":"Bloom Filter","uri":"/posts/21-04-07_bloom-filter/"},{"categories":["algorithm"],"content":"参考文献 http://pages.cs.wisc.edu/~cao/papers/summary-cache/node8.html https://blog.csdn.net/jiaomeng/article/details/1495500 http://www.eecs.harvard.edu/~michaelm/postscripts/im2005b.pdf https://www.cs.utah.edu/~jeffp/teaching/cs5140-S16/cs5140/L12-Count-Min+Apriori.pdf http://www.cs.jhu.edu/~fabian/courses/CS600.624/slides/bloomslides.pdf ","date":"2021-04-07","objectID":"/posts/21-04-07_bloom-filter/:5:0","tags":["hash"],"title":"Bloom Filter","uri":"/posts/21-04-07_bloom-filter/"},{"categories":["algorithm"],"content":"摘要 本文主要介绍Count-Min Sketch，这是一种用来统计元素出现频率的数据结构，其基于hash函数进行构建，常用来解决\"Heavy-Hitter\"问题，即统计一个集合中经常出现的元素。本文除对算法原理进行介绍，更重要的是要对其进行数学分析，从而更好的理解该算法。 ","date":"2021-04-06","objectID":"/posts/21-04-06_count-min-sketch/:1:0","tags":["hash"],"title":"Count-Min Sketch","uri":"/posts/21-04-06_count-min-sketch/"},{"categories":["algorithm"],"content":"算法介绍 首先介绍算法的过程，初始化$t$个独立的hash函数$h_1, h_2, …,h_t$，每一个hash函数都是从集合$[n] \\to [k]$的映射。然后初始化一个二维矩阵，如下图所示： 我们假设$t=log(1/\\delta), k=2/\\epsilon$，至于$\\delta,\\epsilon$是什么，为什么那么赋值后面会解释，先说一下结论：当$t,k$选择上述值时，假阳性的值大于$m\\cdot \\epsilon$的概率小于$\\delta$。 对于具有m个元素的集合A，对其进行如下操作: Set all $C_{i,j}=0$ for i=0 to m do for j=0 to t do $C_{j,h_{j}(a_i)}$ += 1 当查找一个元素出现的次数时，只需要计算 $$\\check{f_{q}}=min C_{j,h_{j}(q)},j\\in [t]$$ 也就是说找到元素$q$映射到的位置当中的最小值，很明显通过此方法得到的值$\\check{f_q}$值肯定是大于等于实际值$f_q$的，因为$q$对应的值有可能与其他的值碰撞，从而产生假阳性，但是肯定不会产生假阴性。 那么到底会产生多少假阳性呢？ ","date":"2021-04-06","objectID":"/posts/21-04-06_count-min-sketch/:2:0","tags":["hash"],"title":"Count-Min Sketch","uri":"/posts/21-04-06_count-min-sketch/"},{"categories":["algorithm"],"content":"分析 我们希望最后的结果是能够以一定的概率保证$\\check{f_q} \u003c f_q + w$，那么下面需要做的就是怎么确定这个概率和$w$之间的关系呢？其实我们在上面已经假设$w=m\\cdot \\epsilon$，那么我们就将去求其概率。 首先我们假设一个符号$r_{i,j}$，表示由于$i$在hash函数$h_j$上导致的$q$的数量的增加，那么显然： $$ r_{i,j}= \\begin{cases} 1, \u0026 \\text{when collusion happen.} \\cr 0, \u0026 \\text{otherwise.} \\end{cases} $$ 也就是当碰撞发生时，其值为1，其他为0。如果我们想求出$r_{i,j}$的期望，就应该先求其概率。回顾该值的定义，该值定义为另外一个值$i$与$q$的碰撞所导致的值的增加，那么碰撞的概率是多少呢？如果所使用的hash函数理想的话，任意一个值与$q$的hash值相同的概率都为$1/k$。也就是说： $$ E(r_{i,j})=1/k $$ 那么容易求得： $$ E(r_{.,j})=\\sum_{i\\neq q}^m E(r_{i,j})=\\sum_{i\\neq q}^m 1/k \\approx m/k $$ 也就是说由在$h_j$处所产生的碰撞所导致的$C_{j,h_j(q)}$的值的增加–$r_{.,j}$的数学期望为$m/k$。那么根据马尔可夫不等式可以得出： $$ P(r_{.,j} \u003e w) \u003c E(r_{.,j})/w = m/kw $$ 回顾我们在一开始时设的$k=2/\\epsilon$，并将$w=m\\cdot \\epsilon$代入，可得 $$ P(r_{.,j} \u003e w) \u003c 1/2 $$ 我们以上只是分析了由$h_j$碰撞所导致的假阳性，根据算法可知，最后取得$f_q$值为所计算的hash函数的最小值，也就是说$f_q$假阳性的值取决于由所有hash函数导致的假阳性值的最小值。如果$f_q$的假阳性大于$w$，那么： $$ P(\\bar{f_q} - f_q \u003e w) = P(\\underset{j\\in t}{min}\\ r_{.,j} \u003e w) \u003c (1/2)^t $$ 又由上文可知，我们已经假设$t=log(1/\\delta)$，所以最后的结果为： $$ P(\\bar{f_q} - f_q \u003e w) \u003c \\delta $$ 这也就解释了我们一开始对于$t,k$的选值原因。最后的空间复杂度为： $$ t\\cdot \\log n + tk\\cdot \\log n = (\\frac{2}{\\epsilon} \\log m + \\log n)\\log \\frac{1}{\\delta} $$ ","date":"2021-04-06","objectID":"/posts/21-04-06_count-min-sketch/:3:0","tags":["hash"],"title":"Count-Min Sketch","uri":"/posts/21-04-06_count-min-sketch/"},{"categories":["algorithm"],"content":"代码实现 TODO😄 ","date":"2021-04-06","objectID":"/posts/21-04-06_count-min-sketch/:4:0","tags":["hash"],"title":"Count-Min Sketch","uri":"/posts/21-04-06_count-min-sketch/"},{"categories":["algorithm"],"content":"参考文献 https://www.cs.utah.edu/~jeffp/teaching/cs5140-S16/cs5140/L12-Count-Min+Apriori.pdf ","date":"2021-04-06","objectID":"/posts/21-04-06_count-min-sketch/:5:0","tags":["hash"],"title":"Count-Min Sketch","uri":"/posts/21-04-06_count-min-sketch/"},{"categories":["math"],"content":"最近在学习的时候遇到了一些数学证明，本身并不难，其中用到了马尔可夫不等式，但是不知道没有还是忘了，所以准备借此机会复习一下马尔可夫不等式和切比雪夫不等式（这个肯定学过）。针对这两则定理的证明网上很多很好的博客，包括维基百科，本文虽然是重复造轮子😂，但主要是为了把思考过程记录下来。 ","date":"2021-03-21","objectID":"/posts/21-03-21_markov-and-chebyshev/:0:0","tags":["statistics"],"title":"马尔可夫与切比雪夫不等式","uri":"/posts/21-03-21_markov-and-chebyshev/"},{"categories":["math"],"content":"马尔可夫不等式 首先把该不等式写下来： $$ P(x\u003e\\alpha) \u003c\\frac{\\mu}{\\alpha}, (x\u003e0) $$ 其中x的取值范围为$x\u003e0$，$\\mu$为x的数学期望。 看到这个公式，我的第一感觉是这个公式不对吧，公式里连方差都没有，也就是连离散程度都没有涉及怎么能够直接判定其范围呢？我甚至可以直接举出一个“反例”。 试着想象一下：假设x的分布像一条小船，中间概率小，几乎为0，两边大，几乎各占一半。$\\alpha$的值比较大，这里假设为10，并且假设在靠近0的地方x的概率密度很大，所以最后的结果是其期望为一个比较小的值，这里假设为1。 之所以认为其是反例的原因是，那么根据马尔可夫不等式，x大于$\\alpha$的概率为 $$ P (x\u003e\\alpha) \u003c\\frac{1}{10} $$ 根据前面所做的设想，这明显“不对”啊，因为值主要分布在两端嘛，怎么可能大于$\\alpha$的概率仅为1/10呢？应该是1/2左右吧。 例子如如下图（这里图画的可能不太准确，其实也不可能准确）: “反例”“反例” \" “反例” -- 仔细思考后发现该想法是不对的，因为上述想象的图形是画不出来的。假如两边的两个峰值各占一半，那么其期望不可能特别小，其期望的值应该恰好在两个峰值之间，那么马尔可夫不等式的计算结果为1/2，好像符合实际情况😮 再假设其期望就是特别小，比如说1，然后两个峰值相差很大分别为0.1，10。那么根据杠杆原理（乱入😁），期望相当于支点，则两个峰值的数据量之比肯定为10:1。那么根据马尔可夫不等式计算出的值1/10好像又是对的😮。 虽然感觉定理不对，但是为啥举的例子又都是对的呢？后来仔细想想，应该是其条件限制了x的取值范围大于0，期望就相当于支点，距离支点越远，力矩越大，所以需要的力越小，即点的数量也就越少，因此可以得到一个概率范围，嗯~~~听起来挺合理😁 以上只是我一开始的主观想象过程，下面介绍实际的证明： $$ \\begin{align} P(x\u003e\\alpha) \u0026 = \\int_\\alpha ^\\infty f(x)dx \\cr \u0026 = \\frac{1}{\\alpha}\\int_\\alpha^\\infty \\alpha f(x)dx \\cr \u0026 \u003c \\frac{1}{\\alpha}\\int_\\alpha^\\infty xf(x)dx \\cr \u0026 \u003c \\frac{1}{\\alpha}\\int_0^\\infty xf(x)dx \\cr \u0026 = \\frac{\\mu}{\\alpha} \\end{align} $$ 其数学证明很简单，值得说明的是该上界经过几次放缩，所以估计的很粗略，相对而言切比雪夫不等式就要准确一些。 ","date":"2021-03-21","objectID":"/posts/21-03-21_markov-and-chebyshev/:1:0","tags":["statistics"],"title":"马尔可夫与切比雪夫不等式","uri":"/posts/21-03-21_markov-and-chebyshev/"},{"categories":["math"],"content":"切比雪夫不等式 因为切比雪夫中引入了方差，所以感觉看着就比马尔可夫要靠谱些😂 $$ P(|x-\\mu |\u003e\\alpha) \u003c \\frac{\\sigma ^2}{\\alpha ^2} $$ 其中$\\mu$为期望，$\\sigma ^2$为方差。 该式的证明也很简单，直接代入马尔可夫不等式就可证明： $$ \\begin{align} P(|x-\\mu |\u003e\\alpha) \u0026 = P(|x-\\mu |^2\u003e\\alpha ^2) \\cr \u0026 \u003c \\frac{E(|x-\\mu|^2)}{\\alpha ^2} \\cr \u0026 = \\frac{\\sigma ^2}{\\alpha ^2} \\end{align} $$ 上式中的第二步转化之所以成立，是因为$E(|x-\\mu|^2)$恰好就是方差的定义啊。可见切比雪夫不等式其实就是对方差的另一种解释。不是方差恰好满足了这个式子，而是方差的定义使其一定满足该不等式。不难想象，如果方差改一下定义，那么切比雪夫不等式肯定以另一种形式出现。 另外，我学的教材中还有对切比雪夫不等式的另一种证明： $$ \\begin{align} P(|x-\\mu |\u003e\\alpha) \u0026 = P(|x-\\mu |^2\u003e\\alpha ^2) \\cr \u0026 = \\int_{|x-\\mu |^2\u003e\\alpha ^2} f(x)dx \\cr \u0026 \u003c \\int_{|x-\\mu |^2\u003e\\alpha ^2}\\frac{(x-\\mu)^2}{\\alpha ^2} f(x)dx \\cr \u0026 \u003c \\int_{-\\infty}^{\\infty}\\frac{(x-\\mu)^2}{\\alpha ^2} f(x)dx \\cr \u0026 = \\frac{\\sigma ^2}{\\alpha ^2} \\end{align} $$ 以上为我学的教材上的证明方法，可见切比雪夫不等式中的$|x-\\mu|$恰好可以和$f(x)$组成方差的计算公式。通过本博客希望自己对于上述两个不等式有更深的理解吧~😄 ","date":"2021-03-21","objectID":"/posts/21-03-21_markov-and-chebyshev/:2:0","tags":["statistics"],"title":"马尔可夫与切比雪夫不等式","uri":"/posts/21-03-21_markov-and-chebyshev/"},{"categories":[],"content":"关于我 程序员，现研究生在读，即将毕业（如果顺利）😂 Linux 用户 Vim 用户 markdown 用户 $\\LaTeX$ 用户 ","date":"2021-03-13","objectID":"/about/:0:0","tags":[],"title":"关于我","uri":"/about/"},{"categories":["math"],"content":" 主成分分析原理与实现--  主成分分析是一种矩阵的压缩算法，在减少矩阵维数的同时尽可能的保留原矩阵的信息，简单来说就是将 $n×m$的矩阵转换成$n×k$的矩阵，仅保留矩阵中所存在的主要特性，从而可以大大节省空间和数据量。最近课上学到这个知识，感觉很有意思，就在网上找一些博客进行学习，发现网上关于这方面的介绍很多，但是感觉都不太全面，单靠某一个介绍还是无法理解，当然这可能也跟个人基础有关。所以我在这里根据自己的理解写一个总结性的帖子，与大家分享同时也方便自己复习。对于主成分分析，可以参照以下几篇博客： PCA的数学原理该博客介绍了主成分中的数学原理，给出了比较清晰的数学解释。简单易懂，但是有一些细节并没有涉及到，所以还是不能完全理解。 PCA 原理：为什么用协方差矩阵介绍了为什么在降维的时候采用协方差矩阵，但是对于协方差矩阵的解释不详细。 关于协方差矩阵的理解对协方差矩阵的进行了详细的推导，解释了为什么可以通过$A A^T$来计算协方差矩阵。 矩阵求导、几种重要的矩阵及常用的矩阵求导公式对矩阵求导进行了介绍。提到了可能会用到的一些求导公式。 UFLDL 教程学习笔记（四）主成分分析对主成分的原理和使用进行了介绍。 ","date":"2021-03-04","objectID":"/posts/pca/:0:0","tags":["ML","statistics"],"title":"主成分分析原理与实现","uri":"/posts/pca/"},{"categories":["math"],"content":"1. 数学原理  数学原理的介绍部分可以参考文献1，该博客对主成分分析的数学原理进行了很直观的介绍。这里我根据自己的理解进行简单介绍。 图一（图片来源于文献 1）  对于一个坐标点$(3,2)$，我们知道其代表的意思是在二维坐标里其横坐标为3，纵坐标为2。其实这隐含了一个假设，即其横纵坐标的基为$(1,0)和(0,1)$。对于一般的二维向量，这似乎是大家的默认情况，就像随便给出一个数字$10$，大家会认为这是$10$进制表示，除非特殊标明，不会把它当作其他进制来理解。对于任意一个坐标点$(x,y)$，我们可以将其表示为： $$ \\begin{pmatrix} 1 \u0026 0 \\cr 0 \u0026 1 \\end{pmatrix} \\cdot \\begin{pmatrix} x \\cr y \\end{pmatrix} = \\begin{pmatrix} x \\cr y \\end{pmatrix} $$ 其中$\\begin{pmatrix} 1 \u0026 0 \\cr 0 \u0026 1 \\end{pmatrix}$的每一个行向量代表一个基向量。 如果我想更换基向量怎么办呢，如上图所示，如果我想知道$(3,2)$在$(\\sqrt{2}/2,\\sqrt{2}/2)与(-\\sqrt{2}/2,\\sqrt{2}/2)$基下的坐标值，该如何计算呢？回顾基本的数学知识，我们发现对于一个向量在一个基上的值其实就是该向量在该基向量上的投影。所以，已知基向量，我们可以很容易求得，对于一个向量，如$(3,2)$，其在基$(\\sqrt{2}/2,\\sqrt{2}/2)与(-\\sqrt{2}/2,\\sqrt{2}/2)$上的投影为： $$ \\begin{pmatrix} \\sqrt{2}/2 \u0026 \\sqrt{2}/2 \\cr -\\sqrt{2}/2 \u0026 \\sqrt{2}/2 \\cr \\end{pmatrix} \\cdot \\begin{pmatrix} 3 \\cr 2 \\end{pmatrix} = \\begin{pmatrix} 5\\sqrt{2}/2 \\cr -\\sqrt{2}/2 \\end{pmatrix} $$ 直观的图表示如上图所示。  再回到主成分分析上来，如果我们想对一个矩阵$A$进行降维，其中$A$为： $$ \\begin{pmatrix} a_{11} \u0026 a_{12} \u0026 \\cdots \u0026 a_{1n} \\cr a_{21} \u0026 a_{22} \u0026 \\cdots \u0026 a_{2n} \\cr \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\vdots \\cr a_{m1} \u0026 a_{m2} \u0026 \\cdots \u0026 a_{mn} \\cr \\end{pmatrix} $$ 行向量代表样本，列向量代表特征，所以其矩阵含义为m个具有n个特征的样本值。对于每一个样本具有的n个特征值，其特征值之间可能会存在很大的耦合，就如文献1中所列举的那样，特征M代表是否为男性，特征F代表是否为女性，因为一个人的性别只能为其中的一个（不考虑特殊情况）。所以这两个特征只留一个就行了，所以就可以省下一半的空间。这个例子有些极端，但是并不影响理解。 图二（图片来源于网络）  同样对于一个具有n个特征的集合来说，很难说这n个特征都是完全有必要的，所以我们就想办法来精简一些特征。选取少于n个的基向量组，将数据投影在这个向量组上，减少空间的同时又能保证信息量。首先需要明确的一点是什么才算好的基向量？首先举一个将二维空间的数据投影到一维空间的情况。如上图所示，对于空间中的这些点，我们应该怎么投影才能够尽可能的保持数据的信息量呢？通过上图中可以看出，如果将数据投影到PC1上，那么所有的数据点较为分散，与之相反，如果投影到PC2上，则数据较为集中。考虑一个极端的情况，假如所有的点在投影之后全部集中在一个点上，这样好吗？当然不！如果所有的点都集中到一个点上，那就说明所有的点都没有差别，信息全部丢失了。所以我们希望当数据点投影到某个坐标轴之上以后，数据越分散越好，而衡量一组数据是否发散恰好有一个统计名词“方差”，也就是说投影过后的点值方差越大越好。 同时，如果数据被投影到多个基向量上，那么我们希望这些基向量之间的耦合程度越小越好，也就说基向量之间应该是正交的，如图三所示（建议点击链接去相应网站查看3D演示）。因为如果不考虑基向量之间的正交性，只考虑方差最大的话，那么所求得的所有的基向量其实都是一样的。关于在不同的基向量上的投影的线性相关度也有一个度量标准–协方差。那么我们的目标明确了，使得相同特征之间方差越大越好，不同特征之间协方差越小越好。 图三（参考文献【6】）  那么这些方差，协方差什么的怎么计算呢？这里可以先给出一个结论，将$A$向量的每一列减去该列的平均值得到一个新的$A$矩阵。然后计算$Cov=1/m \\cdot A^T\\cdot A$，得到一个$n\\times n$的矩阵$Cov$，那么$Cov$的对角线上的元素$c_{ii}$即为第i个特征的方差，对于其他元素$c_{ij}$表示第i个和第j个特征的协方差，很明显该矩阵是对称矩阵。关于该矩阵的计算方式可以参考文献3，其介绍的很详细，这里就不再重复。需要注意的一点是这里$Cov=1/m \\cdot A^T\\cdot A$是因为A矩阵的列向量为特征，所以才这样计算。如果A矩阵的行列向量所表达的含义相反则$Cov=1/m \\cdot A\\cdot A^T$。  已经知道了计算协方差矩阵的方法，下面看一下怎么跟我们要做的结合在一起。再次总结一下我们要做的是什么，对于一个已有的矩阵$A$，我们希望将它投影在一组新的基空间上，使之矩阵大小得到压缩。即： $$ D_{m,N} = A_{mn} \\cdot P_{nN}, \\ \\ \\ \\ given (N \u003c n) $$ 我们要做的就是将n个特征压缩为N个特征。对于压缩过的数据投影，根据上面的叙述可知，我们希望对于相同特征之间方差越大越好，不同特征之间协方差越小越好，并且我们已经知道该如何计算方差和协方差了。 $$ Cov(D)_ {N,N} = D^T \\cdot D = P^T A^T A P. $$ 所以现在的目标很明确，我们要做的就是求得$P$，使得$Cov(D)$的对角线元素尽可能大，非对角线元素尽可能小。学过线性代数的应该都知道，对于$A^T A$矩阵来说，其特征向量组就满足这一条件。因为已知$A^T A$矩阵为对称矩阵，所以可知： $$ P^T (A^T A) P = P^{-1} (A^T A) P = \\Lambda $$ 其中$\\Lambda$为$A^T A$的特征值组成的对角阵，$P$为相应的的特征向量组。  至此，我们就找到了进行主成分分析的方法： 首先对矩阵A进行处理，使得其每一列（或者行）减去其相应列的平均值，使得每一列的平均值都为0，然后计算$B = A^TA$。 求$B$矩阵的特征值和特征向量，将特征值进行排序，并选取前N大的特征值，选取其对应的特征向量组成特征向量组$P_{nN}$。 $D_{m,N} = A_{mn} \\cdot P_{nN}$即为最终想要得到的值。 ","date":"2021-03-04","objectID":"/posts/pca/:1:0","tags":["ML","statistics"],"title":"主成分分析原理与实现","uri":"/posts/pca/"},{"categories":["math"],"content":"2.实验验证  下面我们对该算法进行实际的实现，为了更好的了解PCA的工作原理，同时又保证程序的计算速度，我才用了C语言进行实现，并借助OpenBLAS库进行高效的矩阵运算。OpenBLAS是BLAS标准的一个开源实现，据说也是目前性能和维护的最好的一个。BLAS是Basic Linear Algebra Subprograms的简称，是一个矩阵运算的接口标准。既然是接口标准，那么所有根据该标准的实现都具有相同的使用方式和功能。相似的实现还有BLAS、MKL、ACML等，我使用OpenBLAS进行实现，因为其实现不依赖于任何平台，具有良好的性能，而且亲测易于安装。下面将附上我的实现代码： //矩阵运算部分 Matrix.cpp #include\u003ciostream\u003e#include\u003cstdio.h\u003e#include\u003cstdlib.h\u003e//#include \"mkl.h\" #include\"OpenBLAS/cblas.h\"class Matrix { public: //Print matrix; bool printMatrix() const; //get r. int getr() {return r;} //get l. int getc() {return c;} //get a. float *geta() {return a;} //normalization. void nmlt(); //Compute Coevariance of a, aTxa void coev(Matrix \u0026c); //Default constructor. Matrix():a(NULL), r(0), c(0) {} //Constructor with matrix pointer and dimension. Matrix(float *aa, int rr, int cc): a(aa), r(rr), c(cc) {} //Constructor with only dimension, should allocate space. Matrix(int rr, int cc): r(rr), c(cc) { a = new float[rr*cc]; } //Destructor. ~Matrix() {delete []a; a=NULL;} protected: //Matrix pointer. float *a; //Dimension n, order lda int r,c; }; extern bool printArray(float *p, int n); class SquareMatrix:public Matrix { public: //Default constructor. SquareMatrix(float *aa, int nn):Matrix(aa, nn, nn), n(nn) {} SquareMatrix(int nn): Matrix(nn, nn), n(nn){} //Destructor. ~SquareMatrix() {} //Get eigenvalue and eigenvector; int ssyevd(float *w); private: int n; }; bool Matrix::printMatrix() const { int i=0, j=0; float temp(0); for(i=0; i\u003cr; i++) { for(j=0; j\u003cc; j++) { temp = *(a+c*i+j); printf(\"%7.3f\\t\", temp); } std::cout\u003c\u003cstd::endl; } } int SquareMatrix::ssyevd(float *w) { lapack_int res = 0; res = LAPACKE_ssyevd(LAPACK_ROW_MAJOR, 'V', 'U', n, a, n, w); if(res == 0) { return res; } else { std::cout\u003c\u003c\"ERROR:\"\u003c\u003cres\u003c\u003cstd::endl; exit(-1); } } void Matrix::coev(Matrix \u0026cc) { nmlt(); cblas_sgemm(CblasRowMajor, CblasTrans, CblasNoTrans, c, c, r, 1.0/r, a, c, a, c, 0.0, cc.geta(), c); } void Matrix::nmlt() { int i=0,j=0; float av = 0.0; for(i=0;i\u003cc;i++) { av = 0.0; for(j=0;j\u003cr;j++) { av+=*(a+i+j*c); } av = av/r; for(j=0;j\u003cr;j++) { *(a+i+j*c) -= av; } } } bool printArray(float *p, int n) { for(int i=0; i\u003cn; i++) { printf(\"%7.3f\\t\", p[i]); } std::cout\u003c\u003cstd::endl; return true; } //PCA部分 PCA.cpp #include\u003ciostream\u003e#include\u003cstdio.h\u003e#include\u003cstdlib.h\u003e//#include \"mkl.h\" #include\"OpenBLAS/cblas.h\"#include\"Matrix.h\"#include\"PCA.h\" #define N 5 #define T 0.8f const char SEP = ','; static unsigned int R = 5; static unsigned int C = 5; int main(int argc, char *argv[]) { // float *A = new float [N*N] // { // 1.96f, -6.49f, -0.47f, -7.20f, -0.65f, // -6.49f, 3.80f, -6.39f, 1.50f, -6.34f, // -0.47f, -6.39f, 4.17f, -1.51f, 2.67f, // -7.20f, 1.50f, -1.51f, 5.70f, 1.80f, // -0.65f, -6.34f, 2.67f, 1.80f, -7.10f // }; if(argc \u003c= 1) { printf(\"Usage: PCA [INPUT FILE] [OUTPUT FILE] [ROW] [COLUM]\\n\"); printf(\"INPUT FILE: input file path.\\n\"); printf(\"OUTPUT FILE: output file path.\\n\"); printf(\"ROW: Row of matrix.\\n\"); printf(\"COLUM: Colum of matrix.\\n\"); exit(0); } FILE *input = fopen(argv[1], \"r\"); FILE *output = fopen(argv[2], \"w+\"); R = atof(argv[3]); C = atof(argv[4]); printf(\"Input:%s\\nOutput:%s\\nR:%d\\nC:%d\\n\",argv[1], argv[2], R, C); float *I = new float[R*C](); //float *O = new float[R*C](); char *label = new char[R]; //read matrix. readMtx(input, I, label); SquareMatrix cov = SquareMatrix(C); float *eValue = new float[C](); Matrix m = Matrix(I, R, C); Matrix n = Matrix(R, C); // m.printMatrix(); //compute coveriance matrix. m.coev(cov); //compute eigenvalue and eigenvector of coveriance matrix. cov.ssyevd(eValue); //Compute compressed matrix. eMtx(m, cov, n); //n.printMatrix(); saveMtx(output, n.geta(), label); fclose(input); fclose(output); delete []label; delete []eValue; return 0; } //eigen matrix void eMtx(Matrix\u0026a, Matrix\u0026b, Matrix\u0026r) { cblas_sgemm(CblasRowMajor, CblasNoTrans, CblasNoTrans, a.getr(), b.getc(), a.getc(), 1.0, a.geta(), a.getc(), b.geta(), b.getc(), 0.0, r.geta(), b.getc()); } bool readUtl(FILE *f, char sep) { char c; if((c=f","date":"2021-03-04","objectID":"/posts/pca/:2:0","tags":["ML","statistics"],"title":"主成分分析原理与实现","uri":"/posts/pca/"},{"categories":["math"],"content":"欧几里得算法 ","date":"2021-03-04","objectID":"/posts/euclid/:1:0","tags":["math"],"title":"Euclid Algorithm and Extended Euclid Algorithm.","uri":"/posts/euclid/"},{"categories":["math"],"content":"原理 欧几里得算法是一种快速计算最大公约数的算法，对于任意的两个数$(a,b)$，其最大公约数表示为$gcd(a,b)$，根据欧几里得算法，$gcd(a,b)=gcd(b,a\\mod b)$ 。证明如下： 如果$b\u003ea$，显然成立；因此只需考虑$b \u003c a$的情况。根据初等数学知识，可知$a,b$的关系可表示为$a=qb+r$，其中$q$为商，$r$为余数。 对于$(a,b)$的最大公约数$g1=gcd(a,b)$，当然$g1|a,g1|b$（$g1|a$表示$g1$整除$a$），所以易知对于$r=a-qb$，同样满足$g1|r$； 又因为$a\\mod b=r$，所以对于$a,b$的最大公约数$g1$，同样满足$g1|(a\\mod b),g1|b$，即$(b,a\\mod b)$的最大公约数至少为$g1$，即$gcd(b,a\\mod b)\u003eg1=gcd(a,b)$。 反过来，对于$(b,a\\mod b)$的最大公约数$g2=gcd(b,a\\mod b)$，同样满足$g2|a, g2|b$，即$gcd(a,b)\u003eg2=gcd(b,a\\mod b)$。 因此$gcd(a,b)=gcd(b,a\\mod b)$证明成立。下面对该算法进行实现。 ","date":"2021-03-04","objectID":"/posts/euclid/:1:1","tags":["math"],"title":"Euclid Algorithm and Extended Euclid Algorithm.","uri":"/posts/euclid/"},{"categories":["math"],"content":"实现 #include \u003ciostream\u003e using namespace std; int euclid(int a, int b) { if (b!=0) { return euclid(b, a%b); } else { return a; } } int main() { int a(0),b(0); cin \u003e\u003e a \u003e\u003e b; cout \u003c\u003c euclid(a,b); return 0; } ","date":"2021-03-04","objectID":"/posts/euclid/:1:2","tags":["math"],"title":"Euclid Algorithm and Extended Euclid Algorithm.","uri":"/posts/euclid/"},{"categories":["math"],"content":"拓展的欧几里得算法 ","date":"2021-03-04","objectID":"/posts/euclid/:2:0","tags":["math"],"title":"Euclid Algorithm and Extended Euclid Algorithm.","uri":"/posts/euclid/"},{"categories":["math"],"content":"原理 拓展的欧几里得算法在密码学中有着重要的应用，现给出定理： 对正整数a，b；总是存在一组整数X,Y，使得$Xa+Yb=gcd(a,b)$成立，且$gcd(a,b)$为满足这种条件的最小整数。 这里不对该定理进行证明，欧几里得算法给出了在已知$a，b$的情况下求$gcd(a,b)$的方法，但是如果想要求得X，Y的值，就要求助于拓展的欧几里得算法。怎么才能从欧几里得算法的计算过程当中得到我们想要求解的值呢？我们再次详细回顾欧几里得算法的求解过程。 对于已知整数$a,b$，我们的算法求解过程如下： $a$ $b$ 余数$r$ 商$q$ a b $r_1=a\\mod b$ $q_1=a/b$ b $r_1$ $r_2=b\\mod r_1$ $q_2=b/r_1$ $r_1$ $r_2$ $r_3=r_1\\mod r_2$ $q_3=r_1/r_2$ … … … … $r_{n-1}$ $r_n$ $r_{n+1}=r_{n-1}\\mod r_n$ $q_{n+1}=r_{n-1}/r_n$ 逐步计算，直到某一步出现$r_{n-1}\\mod r_{n}=0$的情况，这时候就找到了最大公约数，最大公约数即为$r_n$，以上就是欧几里得算法的全过程。通过这个过程当中多产生的一些中间结果我们能不能求得$X,Y$的值呢？下面进行两种求解方法的推导。 ","date":"2021-03-04","objectID":"/posts/euclid/:2:1","tags":["math"],"title":"Euclid Algorithm and Extended Euclid Algorithm.","uri":"/posts/euclid/"},{"categories":["math"],"content":"递归求解 根据上面的表格我知道，$Xa+Yb=gcd(a,b)$，并且对于中间所求解的每一步我们所得到的$r_i$都满足$X_i\\cdot r_i+Y_i\\cdot r_{i+1}=gcd(a,b)$，因为很明显每一对$r_i,r_{i+1}$都满足最大公约数为$gcd(a,b)$，这也是欧几里得算法的原理。 我们试着寻找$(X_i,Y_i),(X_{i+1},Y_{i+1})$之间的递推关系，由以上阐述可知: $$ \\begin{cases} X_i\\cdot r_i+Y_i\\cdot r_{i+1}=gcd(a,b), \u0026\\text{(1)} \\cr X_{i+1}\\cdot r_{i+1}+Y_{i+1}\\cdot r_{i+2}=gcd(a,b),\u0026\\text{(2)} \\end{cases} $$ 为了将上式转换成$r_i$的方程组，我们使用$r_{i+1},r_{i+2}来表示r_i$，通过以上可知$r_i=r_i/r_{i+1}\\cdot r_{i+1}+r_{i+2}$，将该式带入上式（1），并将两式合并可得： $$ X_i\\cdot (r_i/r_{i+1}\\cdot r_{i+1}+r_{i+2})+Y_i\\cdot r_{i+1}=X_{i+1}\\cdot r_{i+1}+Y_{i+1}\\cdot r_{i+2} $$ 进一步化简可得： $$ (X_i\\cdot r_i/r_{i+1}+Y_i)\\cdot r_{i+1}+X_i\\cdot r_{i+2}=X_{i+1}\\cdot r_{i+1}+Y_{i+1}\\cdot r_{i+2} $$ 根据系数相等的原则可得： $$ \\begin{cases} X_i\\cdot r_i/r_{i+1}+Y_i=X_{i+1}, \u0026\\text{(1)}\\cr X_i=Y_{i+1},\u0026\\text{(2)} \\end{cases} $$ 以上就得到了$(X_i,Y_i),(X_{i+1},Y_{i+1})$之间的递推关系，那么我们接下来的工作就是找到一对可以求出其值的$(X_i,Y_i)$，通过以上可知当出现某一次计算使得$r_{i}\\mod r_{i+1}=0$时，我们可知对于$X_i\\cdot r_i+Y_i\\cdot r_{i+1}=gcd(a,b)$，满足$gcd(a,b)=r_{i+1}$，那么很显然$X_i=0,Y_i=1$。于是我们就得到了一对$(X_i,Y_i)$的值，我们已经知道了最后一对$r_{i},r_{i+1}$所对应的$(X_i,Y_i)$才能够推知前面的值，所以我们的推导是从后往前推的，因此我们将上面的递推关系稍微变换一下形式： $$ \\begin{cases} X_i=Y_{i+1},\u0026\\text{(1)}\\cr Y_i=X_{i+1}-Y_{i+1}\\cdot r_i/r_{i+1}, \u0026\\text{(2)} \\end{cases} $$ 此时我们就得到了推导关系和初值，通过计算我们就可以求得满足$Xa+Yb=gcd(a,b)$的$X,Y$值。下面通过代码对其进行实现： #include \u003ciostream\u003e using namespace std; void extEuc(int a, int b, int\u0026x, int\u0026y) { int rx,ry; int r(0); if (a%b==0) { x=0;y=1; return; } else { r = a%b; extEuc(b, r, rx, ry); x = ry; y = rx - ry*a/b; return; } } int main() { int a,b; int x,y; cin \u003e\u003e a \u003e\u003e b; extEuc(a, b, x, y); cout \u003c\u003c x \u003c\u003c' '\u003c\u003c y \u003c\u003c endl; return 0; } 输入42 2017可求得输出为-48，1。 ","date":"2021-03-04","objectID":"/posts/euclid/:2:2","tags":["math"],"title":"Euclid Algorithm and Extended Euclid Algorithm.","uri":"/posts/euclid/"},{"categories":["math"],"content":"迭代求解 较多的递归调用可能会影响计算速度，所以我们接下来推一下迭代的计算方式，已知上面表格中所列欧几里得算法的计算步骤。已知$gcd(a,b)$是满足该集合的最小值$\\lbrace Xa+Yb | X,Y\\in Z \\rbrace$，已知对于每一步所产生的余数均能被$gcd(a,b)$整除，现在考虑每一步迭代所产生的余数满足的等式： $$ \\begin{cases} r_i=X_i\\cdot a+Y_i\\cdot b \\cr r_{i+1}=X_{i+1}\\cdot a + Y_{i+1}\\cdot b \\end{cases} $$ 且已知$r_i, r_{i+1}$满足$r_{i-1}=r_{i-1}/r_i\\cdot r_i+r_{i+1}$，将上面两式代入到该式，可得： $$ r_{i-1}=(r_{i-1}/r_i\\cdot X_i+X_{i+1})\\cdot a+(r_{i-1}/r_i\\cdot Y_i +Y_{i+1})\\cdot b. $$ 值得注意的是此处的$X_i,Y_i$与递归方法中的值含义不同。根据上式可推知以下递推关系： $$\\begin{cases} X_{i+1}=X_{i-1}-r_{i-1}/r_i\\cdot X_i \\cr Y_{i+1}=Y_{i-1}-r_{i-1}/r_i\\cdot Y_i \\end{cases}$$ 已知中间的递推关系，关键是考虑如何判断循环的起始值和结束条件，对于$a,b$也可看做是余数$r_i$，那么对于$a,b$来说，其满足的值为： $$\\begin{cases} a = a\\cdot 1 + b\\cdot 0\\cr b = a\\cdot 0 + b\\cdot 1 \\end{cases}$$ 所以就得到了两对$(X,Y)$的值，分别为$(1,0),(0,1)$，并且已知$r_i$之间的递推关系为$r_{i+1}=r_{i-1}\\mod r_i$。我们也知道循环结束的条件为$r_i=gcd(a,b)$，其最后的形式为$Xa+Yb=gcd(a,b)$，其直接判断方式为$r_{i-1}\\mod r_i=0$，然后我们就得到了最终的$X,Y$值，根据以上递推形式，我们有以下实现： #include \u003ciostream\u003e using namespace std; int main() { int a,b; int x1(1),y1(0),x2(0),y2(1); int temp; cin \u003e\u003e a \u003e\u003e b; while (a%b!=0) { temp = x2; x2 = x1 - a/b*x2; x1 = temp; temp = y2; y2 = y1 - a/b*y2; y1 = temp; temp = a%b; a = b; b = temp; } cout \u003c\u003c x2 \u003c\u003c' '\u003c\u003cy2\u003c\u003cendl; return 0; } 输入42 2017可求得输出为-48，1。 这里有一个用尽可能多的程序语言实现求逆元的网站，大家也可以参考这里的不同实现。 参考文献 [1] Katz J，Lindel Y．Introduction to Modern Cryptography—Principle and Protocol现代密码学——原理与协议【M】任伟．北京：国防工业出版社．2010：10-15． ","date":"2021-03-04","objectID":"/posts/euclid/:2:3","tags":["math"],"title":"Euclid Algorithm and Extended Euclid Algorithm.","uri":"/posts/euclid/"},{"categories":["record"],"content":" The first blog. ","date":"2021-03-04","objectID":"/posts/hello-world/:0:0","tags":["blog"],"title":"Hello World","uri":"/posts/hello-world/"},{"categories":["record"],"content":"博客搭建记录 在阅读了众多的博客搭建教程之后，最终选择了使用github + hugo进行搭建，主题为even. 希望借此博客在互联网上留下一点有价值的东西，同时作为自己的学习笔记，温故而知新。 ","date":"2021-03-04","objectID":"/posts/hello-world/:1:0","tags":["blog"],"title":"Hello World","uri":"/posts/hello-world/"},{"categories":["record"],"content":"软件安装 首先进行相应软件的安装，具体可以参考官方文档的安装步骤。本文以ubuntu举例说明。在ubuntu上可直接使用apt进行安装，但是使用该方法安装的hugo软件版本过低，会导致本文所使用的主题even无法使用（我所使用的even要求最低版本为0.60），而且这个问题可能在其他主题上也存在。总而言之，建议直接安装最新版本，可直接到release下载。 ","date":"2021-03-04","objectID":"/posts/hello-world/:1:1","tags":["blog"],"title":"Hello World","uri":"/posts/hello-world/"},{"categories":["record"],"content":"网站和主题配置 软件安装好了之后，可以创建一个文件夹作为根目录(如mkdir blog)并使用git init进行初始化，然后在该目录下进行hugo的初始化，初始化操作为 hugo new site [blogs name] 然后在该目录下就会创建一些文件夹，如： README.md archetypes config.toml content public resources themes 文件夹的具体作用我正在继续摸索，现在大概知道config.toml是全局配置文件；content文件夹中放置的是博客的内容，如本博客的路径就是content/post/hello-world；themes中所存放的就是主题文件，文件夹下可有多个主题，但是在使用的时候只能指定其中一个；public中所存放的是一些经过编译的网页内容，即使用markdown编写的博客经过编译以后会放到这个文件夹里，但具体的组织结构还没搞明白，待后续研究；archetypes中存放的好像是模板之类的东西，同样待后续研究。 接下来讨论怎么设置主题，经过一段时间纠结的筛选后，决定暂时使用even主题，主要原因有： 主题看来还算简洁 维护还算活跃 该主题是一个博客性质的主题，比较符合目前需求 该主题的开发者是国人同胞，可能比较符合国人的应用习惯 选定主题后，就将该主题clone到themes文件夹下并命名为even。然后将该仓库添加为本仓库的子模块。 git submodule add https://github.com/olOwOlo/hugo-theme-even ./themes/even 然后可以参考even主题的教程，将其配置文件进行拷贝和自行配置。其配置方面的文档较少，但好处是其配置文档中都使用了中文对其作用和用法进行了大概的注释，同样也可以根据需求进行增添内容，具体细节将后续进行学习。 ————21/04/07更新———– 感觉even有些功能不理想，比如说分类和标签没有任何区分度，并且作者似乎已经停止开发了，所以准备转到LoveIt的继任者CodeIT上，不过even也有优点，就是作者是国人，所以一些特性（如百度统计、不蒜子等）还是挺符合国人习惯和应用需求的。 但是写博客不就是为了折腾吗？😂，把仅有的几个博客来回迁移:laugh:。选定新的主题后，准备进行迁移，下面准备讲述更新过程。使用这两个主题的时候都会遇到一个问题，就是数学公式的显示问题，感觉两个主题都有一些不尽如人意的地方，接下来将讲述我遇到的问题，以及目前所采用的方式。希望以后能够有机会了解hugo的细节，从而更好的解决该问题。 首先是even主题，该主题使用的是mathjax进行公式的渲染，经过网上了解，mathjax是一个很成熟的解决方案，所以其对数学公式的支持还是很完善的，但是在使用较复杂的数学公式环境过程中还是遇到了一个问题，如: \\begin{align} x \u0026= y + 1 \\\\ y \u0026= z + 2 \\end{align} 在$\\LaTeX$中是没有问题的，但是在hugo就无法被正确渲染，只有将换行符\\\\更改为\\\\\\\\才能正常工作，好像看到网上有相关的讨论（没有记录），说导致该问题的原因是markdown编译器在进行解析的时候会将第一斜杠解释为转义，那么最后的结果是只剩一个斜杠，所以如果想让其最后仍然有两个斜杠，则不得不用四个斜杠。虽说敲四个斜杠是麻烦了点，但是好歹问题算是大概解决了。 后来试用CodeIT主题时则出现了更严重的问题，主要是因为该主题使用的是据说是性能更好的$KaTeX$渲染器。该渲染器作为托管在github的开源项目还是挺受欢迎的，但是katex对于公式的支持就不那么完善了，截止到目前的最新版本0.13.0，刚能够支持诸如align,align*等环境。而CodeIT使用的仍然是0.11.1的老版本，但这还不是主要问题，主要问题是原本在mathjax中可行的方案在katex中不可行了，比如根据文档katex v0.11.1中是支持aligned环境的，但是以下代码并不能够被正确渲染： \\begin{aligned} x \u0026= y + 1 \\\\\\\\ y \u0026= z + 2 \\end{aligned} 该代码可以在even主题下正常工作，但是无法在CodeIT在工作，经网上搜索，发现了该解决方案，经该方案介绍，使用如下代码可正常工作： \\begin{aligned} x \u0026= y + 1 \\cr y \u0026= z + 2 \\end{aligned} 其效果为： $$ \\begin{aligned} x \u0026= y + 1 \\cr y \u0026= z + 2 \\end{aligned} $$ 主要改动为将斜杠更换为\\cr，经测试可以正常工作，然后将该方式在even主题中测试也可以工作，所以就计划采用这种方式来代替双斜杠的功能，虽然感觉像是最后对问题的妥协，但是好歹是解决了该问题😂 后来有对问题做进一步的探索，做法是在浏览器中查看网页的源代码，我发现使用斜杠做为换行符的方式都会在公式行的最后引入一个\u003cbr\u003e标签，如下所示： \\begin{aligned} x \u0026amp;= y + 1 \\\\ \u003cbr\u003e y \u0026amp;= z + 2 \\end{aligned} 具有标签的代码在使用mathjax渲染器的时候是可以被正常渲染的，但是在katex中却不行。而使用\\cr进行换行则不会引入\u003cbr\u003e标签，因此在katex中可用。 最后附上将换行符更改为\\cr的命令: sed -i 's/\\\\\\\\\\\\\\\\/\\\\cr/' [blogname].md ————21/04/08更新———– 除上述所示问题外，今天又遇到了另外一个问题，那就是在公式中使用特殊字符（如%）时需要进行转义，一般写为\\%，但是这又会遇到一个问题，就是在$符号之间的字符不能够像在 ` 符号中那样被免于转义。也就是说\\%中的斜杠会在markdown解析的过程中解析为转义字符，因此到公式解析器的时候剩下的就只剩一个%符号了，所以需要使用两个符号才行。关于这个问题，感觉主要问题还是在markdown解析器那里没有执行正确的解析。当然，以上只是我的猜想，有时间我会去验证的。 知道问题之后的解决方式呢？如果实在不得不用特殊字符的转义，那就使用上述方法，可以解决。如果不是必要，比如我这里就是将%作为模运算符号，其实math里有专门的符号\\mod表示该含义，所以出于兼容性期间，决定使用\\mod符号，因为万一哪一天markdown解析器可以正常解析了，岂不是还要把两个斜线换成一个。 同时这里有一个总结：在markdown的公式环境中尽量减少使用转义符👉\\👈 ","date":"2021-03-04","objectID":"/posts/hello-world/:1:2","tags":["blog"],"title":"Hello World","uri":"/posts/hello-world/"},{"categories":["record"],"content":"写博客 上面已经进行了大概的配置，下面将介绍怎么写一篇博客。首先使用 hugo new post/hello-world 创建一个新的博客，该命令将创建一个文件：content/post/hello-world.md。该文件会包含一个文件头 title: *** date: 202*** draft: true draft一栏默认为true，如果想要发布该博客，需要将其修改为false。 hugo的一个好处就是可以边写博客边进行调试，其具体操作为：在主目录下（即blog/）运行 hugo server -D 该命令将启动一个本地服务，端口号为1313，在本地使用浏览器访问：http://localhost:1313即可在线预览自己的博客内容。每次保存文件时，hugo都会自动进行编译，速度很快，几乎实现了markdown的同步预览，非常方便！ 在发布之前应该使用 hugo -D 编译一下，至此已经可以实现基本的功能 ","date":"2021-03-04","objectID":"/posts/hello-world/:1:3","tags":["blog"],"title":"Hello World","uri":"/posts/hello-world/"},{"categories":["record"],"content":"使用github发布博客 首先要有一个github账号，然后创建一个新的仓库，其名字为：[your github id].github.io，关于这方面的教程非常多，也很简单，这里就不再赘述。然后其部署可参考https://gohugo.io/hosting-and-deployment/hosting-on-github/#build-hugo-with-github-action。其操作非常方便，只需要创建一个文件，然后将一些github action代码复制进去就行了。具体原理后续研究…(这里不得不感叹一句，github的功能比我想象的要强大多了!) 然后就是将本地文件(即blog/文件夹)push到所创建的仓库中。最后需要注意的是在上面所创建的仓库的设置页面要进行一定的设置，其位置为setting-\u003egithub pages-\u003esource，需要将branch更改为gh-pages，路径为root，在这里还可以设置定制化的域名等，这里先暂时不研究。通过以上设置应该就可以成功访问页面了。如本博客主页为：http://xinyu-yang.github.io 还有很多功能待后续学习更新… ","date":"2021-03-04","objectID":"/posts/hello-world/:1:4","tags":["blog"],"title":"Hello World","uri":"/posts/hello-world/"},{"categories":["record"],"content":"图床 以前用CSDN和博客园写的时候根本不用考虑这个问题，但是现在自己搭建博客的时候就需要好好考虑一下这个问题。一开始惊喜的发现有很多的免费图床网站（比如imgbb），开心的以为这个问题解决了，后来发现没那么简单。因为这些免费的图床往往有很多限制，比如上面举例说的这个imgbb，该网站一开始用着还行，可是过几天再在博客里加载图片时只能加载出缩略图了。 后来就寻求解决方案，最后的决定是仍然使用开源的代码托管网站托管图片，把白嫖进行到底😂。最终我决定使用PicGo+(Gitee/Gitlab/Github)实现。 因为Gitee是国内的网站，加载较快，另外就是还没有使用Gitee托管代码的打算，所以不如注册个账号专门用来托管图片，综合以上原因，最终使用了Gitee。但是Gitee也有很多缺点，缺点之一就是空间太小了（这里不得不吐槽一句，本来就是模仿者，又那么小气，没有任何优势，难怪没人用啊~）。 下图是Gitee示例： 测试图片测试 \" 测试图片 最后不得不说一下，感觉PicGo真的是开源代码的典范，自己提供一个框架和一套接口，其他人可以按照接口开发各种各样的代码。我感觉对于实用性的工具应用，这种开发方式非常合适。 功能强大，但不臃肿，用户有足够多的定制选择权。 ","date":"2021-03-04","objectID":"/posts/hello-world/:1:5","tags":["blog"],"title":"Hello World","uri":"/posts/hello-world/"}]