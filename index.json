[{"categories":["信口开河"],"content":"今天有幸再次乘坐了一次北京早高峰地铁，有感而记","date":"2021-11-24","objectID":"/blog/2021/21-11-24_beijing-subway/","tags":[],"title":"乘坐北京地铁有感","uri":"/blog/2021/21-11-24_beijing-subway/"},{"categories":["信口开河"],"content":"今天再次有幸乘坐北京早上八点左右的地铁，有一些想法，本文进行记录。 之所以强调北京早上八点的地铁，因为这个时候的地铁不同一般时间，具有鲜明的特色。如果用一个字来形容的话，那就是“快”。不光地铁快，人也快。 人是怎么个快法呢？就是地铁站里的乘客大多都是在小跑，而不是普通的走路甚至是快走。仍记得 17 年刚来北京那会，年少无知，坐扶梯的时候站在了扶梯左侧，受到过几次不耐烦的“借过一下”甚至是抱怨。 我刚开始还觉得有点奇怪，后来渐渐习惯了便察觉自己之前的少不更事，并养成了坐扶梯一定站在右边的习惯，或者干脆加入他们，在左边走。 这个习惯是在北京养成的，以至于后来即使在其他城市坐地铁时也是如此。即使这些城市没有人在扶梯上走，事实上北京也是我迄今为止唯一经历过此情此景的城市。当然，原因可能是我并没有经历过其他城市的早高峰。 其实三年前有过一段时间的工作经历，也是每天都在赶早高峰，但是这次经历似乎有不一样的体验。或许是自己三年来对这个场景变得陌生，也或许是自己当时没有时间静心观察这些。 不知为何，此时心里突然有了一个想法：希望以后自己能做一个走着坐地铁的人。 今天在做第一班车的时候还算空间还算比较富裕，但是当转到另外一条线时，情况就发生了变化。开着停靠的车厢里挤满了人，本以为会有好多人下车，从而能够给我们下面这帮排队的人腾出点位置。可没曾想居然一个下的都没有，看着队列前面还有好几个人，就想着等前面几个上去，然后自己等下一班吧。 结果等我前面的人都走强行挤上去之后，我后面的人也跃跃欲试，此时上不上车已由不得我了，因此只能拼命挤上车，为了不让门夹住书包，只得拼命抓紧扶手把自己的身体往里挤。 还好等到门顺利关上，我就可以稍微放松的把身体倚在门上。很快到了下一站，可怕的是这种情况还在重复，又挤上来两个大姐。我本来握在侧边扶手上的手被大姐建议“抬一下”以便她能上来，然后我就把手以一个奇怪的角度握住上方的扶杆。 因为姿势别扭且费力，我就想反正都几乎动不了了，也就没必要扶什么扶手了。想到这里我机智的把手松开，然后发现我的手似乎没地可放，垂直放下去是不可能的，因为此时很难通过那道人与人之间紧贴而形成的屏障。 所以我就又把手搭在了扶手上，这下扶手可真的被用来“扶”手了。 当我在车厢里无聊的左顾右看的时候，我注意到其实大多数人都很专注，有的在专心刷短视频，有的在看剧，甚至还有的在玩连连看。 总之，为了不浪费在车上的时间，社畜们各显神通。令人惊奇的是，在这种环境下，他们居然表现出了就像在自家沙发上玩手机一样的舒适感。 随后我又想到了一个问题，他们是怎么把手机拿出来的呢？我感觉比较可能的答案就是：他们在上车的时候手机就一直拿在手里，高举着手机走进车厢，然后高举着下车。就像虔诚的信徒将十字架举过头顶，从而彰显着手机的无上地位。 想到这里感觉还挺有意思，似乎干愣着也没那么无聊了。 北京给我最深的印象不是遍布的古迹、公园，也不是繁华的商圈，而是北京的“快”和“挤”。不同的人肯定感触不同，而匆忙拥挤的生活节奏可能就是我这个阶层的人在这个城市所能拥有的最多的感受吧。 ","date":"2021-11-24","objectID":"/blog/2021/21-11-24_beijing-subway/:0:0","tags":[],"title":"乘坐北京地铁有感","uri":"/blog/2021/21-11-24_beijing-subway/"},{"categories":["record"],"content":"本文是本人在使用 Vim 时的配置经验和总结","date":"2021-09-28","objectID":"/blog/2021/21-09-28_vim-learning/","tags":["vim","配置"],"title":"Vim学习记录","uri":"/blog/2021/21-09-28_vim-learning/"},{"categories":["record"],"content":"介绍 很久以来，一直想写一些关于 Vim 的使用博客。但是随着对 Vim 的了解加深，我意识到自己还达不到创作文章介绍Vim的能力。 一方面是因为自己对 Vim 的了解实在是有限，很多东西都只是鹦鹉学舌，了解简单的用法，而介绍这些基本用法的博客文章等浩如烟海，因此没有重复赘述的必要。 另一方面是因为随着学习的深入，我也接触到了很多优秀的博客文章，值得仔细研读。同时也意识到自己的水平跟这些文章的作者相去甚远，想要达到同等水平况且需要些时日，更不用说写出更有深度的东西了。 鉴于以上原因，我决定首先将我学习过程中所参考的优秀学习资料进行汇总和简介。如果初学者能看到本文，并因此在学习中少走些弯路，那便是本文的价值。 另外，我应该不会写偏向于大而全的 Vim 介绍博客，至少目前不会。但是我可能会写一些关于某些功能点的深入学习和记录的文章，我认为在当前网络中所能搜索到的文章中，这类更有价值。 目前本人主要使用的是 Vim ，但是目前 Neovim 似乎后来居上，大有取而代之之势，并且 github 上有很多优秀活跃的 Neovim 插件在开发。从长久趋势来看，新的东西总是基于已有设计，总结经验，克服弊端，并最终淘汰旧的。从传承上来看， Neovim 不过是对 Vim 的推倒重建式的重构，亦如当年 Vim 对于 Vi 编辑器的改良一般。 据称 Neovim 完全兼容 Vim 的功能和配置，并提供了额外的功能，从其风靡程度来看，我也相信这一点。但至少从目前来看，我还没有足够的理由和动机去使用它。也许还是缺少一个契机。这个契机就是遇到 Vim 无法或很难解决的痛点，并且 Neovim 可以很容易解决。而在这之前，则需要对 Vim 更加熟练的使用。 ","date":"2021-09-28","objectID":"/blog/2021/21-09-28_vim-learning/:1:0","tags":["vim","配置"],"title":"Vim学习记录","uri":"/blog/2021/21-09-28_vim-learning/"},{"categories":["record"],"content":"综合教程 ","date":"2021-09-28","objectID":"/blog/2021/21-09-28_vim-learning/:2:0","tags":["vim","配置"],"title":"Vim学习记录","uri":"/blog/2021/21-09-28_vim-learning/"},{"categories":["record"],"content":"入门教程: Vimtutor Vimtutor 作为自带的官方教程，其作为入门教程的权威性自然不言而喻。当然，除了其明面上的地位之外，其作为一个入门教程，给初学者提供了一个很好的实际操作体验，该教程会提供一些例子供阅读者进行实际的操作，比起仅仅列举式的功能介绍，该导论还是挺容易被初学者接受的。 下面是截取的一部分例子： ~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ Lesson 1.3: TEXT EDITING - DELETION ** Press x to delete the character under the cursor. ** 1. Move the cursor to the line below marked ---\u003e. 2. To fix the errors, move the cursor until it is on top of the character to be deleted. 3. Press the x key to delete the unwanted character. 4. Repeat steps 2 through 4 until the sentence is correct.---\u003e The ccow jumpedd ovverr thhe mooon. 5. Now that the line is correct, go on to lesson 1.4.NOTE: As you go through this tutor, do not try to memorize, learn by usage.~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~~ 整篇教程不长，一小时之内就能读完，然后就能够对平时经常用到的绝大部分功能有一个大概的认识。如果想要熟练掌握，还是要勤加练习，并且强迫自己用不同的方式实现某一功能。 该教程是随Vim一块安装的，打开方式很简单，只需在终端敲入vimtutor： $ vimtutor 如果想打开中文版（对，居然自带中文版😃），可以使用vimtutor zh_cn命令。 当然，该文档也可以从Vim中打开，在normal模式敲入： :e $VIMRUNTIME/vim/tutor/tutor.zh_cn.utf-8 不过还是推荐使用vimtutor进行打开，因为在使用该命令时，Vim会自动把原文档复制一份成临时文件然后打开。因此，对通过该方式打开的文档进行操作不会改变原文档。这样使用者就可以放心操作了。 ","date":"2021-09-28","objectID":"/blog/2021/21-09-28_vim-learning/:2:1","tags":["vim","配置"],"title":"Vim学习记录","uri":"/blog/2021/21-09-28_vim-learning/"},{"categories":["record"],"content":"其他入门教程 《简明Vim练级攻略》 这是一篇11年的教程，虽然时间稍早，但是排版易读，语言诙谐，并且加入了很多图片和动图，对读者比较友好。目前该文已有超多120万的阅读量👍。 这篇教程整体内容跟Vimtutor差不多，可以看成是Vimtutor的补充，读完Vimtutor之后可以读下这篇，跟着操作一遍，可以起到复习的效果。 《Vim实操教程》 文如其名，这同样是一份注重实际操作的教程，整体内容也跟上两个文档差不多，可以作为补充一块阅读。 该教程的优点是排版较好，有着类似于书籍的章节排版，逻辑清晰。而且相对上两篇而言，比较新一些，同时有一些关于插件的简单介绍。 《每日一vim》 这是一个教程系列，共计30篇，每篇介绍一个功能，篇幅较短，阅读的时候不会有心里负担，当然对于功能的介绍也是浅尝辄止，读者可以根据需要有选择性的阅读。 ","date":"2021-09-28","objectID":"/blog/2021/21-09-28_vim-learning/:2:2","tags":["vim","配置"],"title":"Vim学习记录","uri":"/blog/2021/21-09-28_vim-learning/"},{"categories":["record"],"content":"高级进阶：Vim从入门到精通（vim-galore-zh_cn） 当搜索Vim的学习教程时，很多人都推荐《Vim galore》，这篇文章就是其中文翻译。虽然中文翻译有点俗套的编程语言教程内味，但是并不影响这是一篇很好的Vim教程。 该仓库下就链接了其他语言的版本，英文好的可以读英文原版，不太好的可以读中文，并且该教程还有日语、西班牙语和俄语选项，都是开源社区贡献的，这也从侧面印证了该教程的牛x。 相对于上面所提到的入门教程，该文章提供了更加深入的介绍，但同时也不那么容易阅读，需要反复咀嚼才能将其学透。 我在第一次看该教程的时候，已经读了上面那些教程，并且有了一段时间的Vim使用经验，但是还是有很多地方读不懂和不理解。后来慢慢的对于里面的内容有了认识（比如那么多的寄存器），但是还是有些不太懂。 所以建议初学者可以先不要读此教程，待有了一定的基础之后再来阅读，当然该教程也需要反复复习。越是经典的教程越是值得我们反复咀嚼，并且每次阅读都会有新的收获。 ","date":"2021-09-28","objectID":"/blog/2021/21-09-28_vim-learning/:2:3","tags":["vim","配置"],"title":"Vim学习记录","uri":"/blog/2021/21-09-28_vim-learning/"},{"categories":["record"],"content":"高级进阶：《Vim学习笔记》 这是一个颇为低调的学习笔记，如果不是偶然看到，可能很难搜索到该教程，该教程所对应的github博客主页甚至都是空白的。据作者称，这是他从一本书整理而来。 经过简单浏览我发现这本书还是不错的，介绍深入浅出，不会只简单介绍基本操作，而是对Vim有较为高级的介绍。 博客内容很丰富，感觉有时间可以学习学习。 ","date":"2021-09-28","objectID":"/blog/2021/21-09-28_vim-learning/:2:4","tags":["vim","配置"],"title":"Vim学习记录","uri":"/blog/2021/21-09-28_vim-learning/"},{"categories":["record"],"content":"插件 ","date":"2021-09-28","objectID":"/blog/2021/21-09-28_vim-learning/:3:0","tags":["vim","配置"],"title":"Vim学习记录","uri":"/blog/2021/21-09-28_vim-learning/"},{"categories":["record"],"content":"配置教程 《所需即所获：像 IDE 一样使用 vim》 这是我阅读的第一篇关于Vim插件配置的文章，主要是我在搜索关于Vim配置的文章的时候，这篇文章高居搜索引擎榜首。虽然已经五年没有更新了，但仍然在github上有9k Star。 这是我读到并且跟着操作的第一篇关于插件配置的博客，该博客涉及的内容很多，以至于很难短时间内搞明白所有的内容，事实上我到现在还搞不明白有些插件的用处。因此需要在实际操作中逐渐摸索。 因为时间原因，文中有些插件早已经被开发者放弃或者被其他的插件所代替。因为不同的人需求也不尽相同，所以有很多文中列举的插件其他使用者可能会觉得根本没有必要。 考虑到以上原因，我采用的方法是首先将所有的配置文件直接拷贝下来，然后逐渐学习和摸索每个插件的用处，然后增删改查，最后打造属于自己的配置。 直接使用现成配置的好处是增加学习过程中的收获感，因为配置完成之后直接就可以看到最终的效果，虽然这个阶段对每一个功能都一脸茫然，但是仍然可以增加自己的成就感。而如果从头开始摸索的话，则可能因为工作量太大并且久久看不到自己想要的效果而丧失学习乐趣。 逐渐摸索下来之后便可对插件进行逐一学习和探索，并且你会逐渐发现这项工作深不见底。因为从对已有插件简单的使用到掌握复杂的配置已经是一个颇为困难的过程，更不用说你甚至可以直接写自己所需的插件。真是学海无涯啊~ 这里同样推荐一些成熟配置以供参考，当然关于Vim的配置在网上一搜一大堆，在github的topics中也能找到很多高star仓库，以下是摘录的几个： SpaceVim 该项目也许是最有名的Vim配置，在github的vimrc话题中高居榜首，其甚至有中文文档（后来才知道该项目原来就是由国人发起的👍）。官网称自己为Vim发布（Vim distribution），感觉就像BSD是作为Linux操作系统的一个发布一样。该发布非常成熟，当然也比较复杂。 我没用过，但是感觉入门成本应该比较低，按照成熟的官方文档进行配置应该没啥问题。因此该配置对于想直接使用Vim配置完全体的用户来说比较友好。 但是我本人没有用该配置的原因也是如此，该配置太成熟和复杂了，以至于很难入手去学习。对我自己而言，一个简易配置，并且容易上手鼓捣的版本才比较适合我。 因为这样可以很好的折中使用体验和入门成本，这也是我选择上述文章学习的原因。 另外要说的一点，当自己逐渐熟悉Vim的配置流程之后，会发现SpaceVim的源码是一个很好的学习材料。 k-vim 该配置在github上也有高star，并且作者是国人。该配置的说明文档不是特别详细，但是问题不大，因为该配置并不是特别复杂，并且在配置文件中有很好的注释。虽然感觉项目稍老，而且开发也不是特别活跃，但是是一个很好的入门和学习素材。 另外作者还开发了一个简化版的vim-for-server版本，用于不太方便安装插件的场景，对我很有启发，我决定也要搞这么一个东西。 myvim 最后允许我厚颜无耻的放上我自己的Vim配置，这是我自己摸索的一个配置，虽然简单，但是暂时够用，同时我也会不断的摸索和完善该配置。 在某博客上读到一句话，感觉比较赞同，大概意思是应该将Vim打造成适合自己的方式，而不是自己去适应已有的配置。这也可能也是大多数人一直乐此不疲折腾的原因吧。 所以以上参考都只是参考和学习资料，毕竟什么配置最合适只有自己知道。 ","date":"2021-09-28","objectID":"/blog/2021/21-09-28_vim-learning/:3:1","tags":["vim","配置"],"title":"Vim学习记录","uri":"/blog/2021/21-09-28_vim-learning/"},{"categories":["record"],"content":"插件推荐 关于插件的推荐，网上同样有很多相关的教程。同时，也可以经常看vimawesome 网站。这个网站有很多流行的插件推荐，可以根据自己的需要进行摸索， 这里我根据自己的使用情况介绍几个个人感觉比较重要的： 我认为首先需要做的是一些美化工作，这包括找一个合适的主题，还有漂亮的状态显示工具。 当然，在最开始之前，最好安装一个插件管理程序，以便于管理。 关于这方面的插件有几个不错的，其中包括Vundle, vim-plug, dein。这几个插件的评分都挺高的，而且功能也相近。 其中Vundle是一个比较老的插件，同时可能也是最流行的一个。 目前对我来说，该插件完全够用。因为我只是需要一个能自动安装插件的这么一个管理器，而且我平时用的插件也不算多，所以对性能等要求也不算特别高。 但遗憾的是Vundle插件似乎已经停止开发了，但是其他的两个插件仍处在活跃开发中。其中vim-plug是我看到的被推荐次数最多的替代品，安装该插件只需要下载一个名为plug.vim的文件。该插件支持一些新的功能，比如可以指定版本和标签，以及设置插件加载的时间。 也许等我安装的插件比较多，需要这么一个懒加载插件管理器来提升速度，或者想要尝试一下新的功能的时候，我会试着学习下该插件，但目前似乎还不是时候。 dein的功能不是特别了解，但感觉应该会跟vim-plug差不多。这三个插件选择一个即可。 另外，本人最近又读到了一些文章，提倡尽量简化配置，尽量多用vim自带的功能来代替那些可有可无的插件，即 “如非必要，勿增实体” 。而据说vim 8.0之后的版本自带插件的管理功能，关于这点，留待以后学习研究。目前还是用些易用的管理插件比较好，这同样也是基于折腾成本与获得感的考虑。 Vim 截图vim screenshot \" Vim 截图 下面开始推荐我认为有必要安装的插件： gruvbox主题 对于一个编辑器来说，好用自然是第一要素，但是颜值也是不可或缺的重要因素。漂亮的界面让人看起来心情愉悦，只有这样才能写出好的程序（或者任何东西）。 关于颜值，那么就不得不说主题了，一个主题相当于一个人的穿着，决定着整体形象。 我选择了比较流行，但更重要的是自己比较喜欢的gruvbox主题。我感觉该主题看起来比较舒服，而这个结论是我经过多个主题的实际安装对比得出来的，可能会有其他更漂亮和科学的主题，但是目前我选择了这个我已经比较满意的。 该主题的整体配色如上图所示。 同时我建议大家在选择自己的主题之前，一定要自己多多对比，然后选择自己看起来比较舒服的主题。这个就像买衣服一样，合不合适只有自己知道。（发现上面举得穿着的例子还挺合适😂） vim-airline状态栏 如果说主题是编辑器的穿着的话，那么vim-airline就像是装饰品，可以起到画龙点睛的作用。 即使不从美观角度来考虑，通过将自己经常需要敲命令查看的东西放在我们易于看到的地方，也会给效率带来巨大的提升。 而该插件可能就是目前这方面做的最好的一个。 该插件目前仍然在不断开发和维护当中，该插件不仅提供底部状态栏（上图 A2 部分），而且还有顶部标签栏（上图 A1 部分所示），并且提供了很多选项供使用者进行配置。当然，对于不需要深度定制的用户，简单使用默认配置即可。我就曾经在这个插件上花了很长的时间，几乎阅读了所有的文档。当最终结果还是很好的，正是有了这个插件，我才真正看到了现代编辑器应该有的样子。 另外，主题和状态栏的兼容还是挺重要的，幸运的是目前我用的主题和该插件是兼容的。 事实上，稍微成熟些的主题一般都会选择跟该插件进行兼容，毕竟这个插件几乎是这方面的标杆。 tagbar概要 该插件主要提供文件的概览，就是代码的目录，可以浏览和跳转。就像 VS Code 中的 outline 那样，当然基本上所有的 IDE 都提供类似的功能。而 Vim 中该功能就由 tagbar 来实现。但是仅靠 tagbar 还不够，还需要另外一个工具的支持，该工具就是 ctags，虽然我们在 Vim 中看不到它的体现，但是 ctags 非常重要，事实上很多插件和功能都要基于它来做。 关于 tagbar 我并没有过多的进行配置，直接把别人的配置拿过来，能显示就行了，研究过多花里胡哨的功能即浪费时间也没必要。 NERDTree 文件导航 该插件是 vimawesome 上最流行的插件之一，但是后来我感觉没啥用，更重要的是能够找到很好的替代品，所以就废除了。 YouCompleteme自动补全 UltiSnip代码段补全 Ctags标签生成 lf 导航 ","date":"2021-09-28","objectID":"/blog/2021/21-09-28_vim-learning/:3:2","tags":["vim","配置"],"title":"Vim学习记录","uri":"/blog/2021/21-09-28_vim-learning/"},{"categories":["record"],"content":"介绍 本文主要用来记录图床的搭建过程，在写博客的过程中不可避免的可能会用到一些图片，因此图片的保存位置就成了一个需要思考的问题，这个问题在使用博客网站CSDN、博客园等是不存在的，因为在使用这些网站时，只需要把图片传上去就行，图片会自行保存在这些平台所提供的图床上。曾经尝试着在本博客里直接引用博客园和CSDN中的图片，不出意外，果然加载不出来，可能是因为这些网站在处理请求的时候会检查Referer字段吧，如果仅是这种检查的话似乎可以避开，但是终究不是长久之计。 一开始惊喜的发现有很多的免费图床网站（比如imgbb），开心的以为这个问题解决了，后来发现没那么简单。因为这些免费的图床往往有很多限制，比如上面举例说的这个imgbb，该网站一开始用着还行，可是过几天再在博客里加载图片时只能加载出缩略图了。 因此就又在网上搜索解决之道，经琢磨了多篇解决方案之后，决定选择可能目前最合适的方案：使用PicGo作为图床管理软件，Gitee、SM.MS等作为存储平台，并且使用Onedrive来同步PicGo的配置文件和数据库（这是PicGo 2.3版本以来的新功能👏），以实现备份和同步。接下来将就该方案进行介绍： ","date":"2021-09-09","objectID":"/blog/2021/21-09-09_picture-bed/:1:0","tags":["blog"],"title":"可同步图床配置——PicGo+Gitee/Github/Gitlab+Onedrive","uri":"/blog/2021/21-09-09_picture-bed/"},{"categories":["record"],"content":"申请Gitee账号，创建仓库 因为Gitee是国内的网站，加载较快，另外就是还没有使用Gitee托管代码的打算，所以不如注册个账号专门用来托管图片，综合以上原因，最终使用了Gitee。但是Gitee也有很多缺点，缺点之一就是空间太小了（这里不得不吐槽一句，本来就是模仿者，又那么小气，没有任何优势，难怪没人用啊~）。 如果没有Gitee账号的话，就去申请一个。账号申请就按照步骤来就行，没什么可说的。我申请的时候发现我在github上使用的ID居然还没被别人占用，就果断申请了该ID，在Github、Gitlab和Gitee上做到了统一。 申请完账号后，登录，然后进入个人信息界面，随后点击左侧栏中的仓库空间管理，随后右上角会出现“新建仓库”的按钮。此时就可以新建仓库了，取名随意，但仓库必须得是公有的。 然后下一步是创建私人令牌，以保证PicGo可以控制该仓库。同样在个人设置界面的左侧“安全设置”栏下有一个“私人令牌”选项，找到并点击。然后点击右上角的生成新令牌，填写描述信息，然后选择权限，我只选择了前三个权限——user_info, projects, pull_requests。 我感觉这些应该就够了，最后点击提交，然后会生成一个token，暂时用记事本等保存该token，因为它不会再次出现。 ","date":"2021-09-09","objectID":"/blog/2021/21-09-09_picture-bed/:2:0","tags":["blog"],"title":"可同步图床配置——PicGo+Gitee/Github/Gitlab+Onedrive","uri":"/blog/2021/21-09-09_picture-bed/"},{"categories":["record"],"content":"PicGo端配置 生成并保存完token之后，就可以进行PicGo端配置了。因为该软件不默认支持Gitee图床，所以只能通过安装插件来支持，在插件设置的搜索栏里搜索gitee-uploader，然后点击安装。安装完之后点击插件图标右下角的设置按钮，找到“配置uploader-gitee”，点击之后会出现一个界面，主要会出现以下几条待填信息： repo (就是刚才所创建的仓库，不过这里的格式是your id/repo name，前面的gitee.com就不要填了) branch (一般为master) token (这就是刚才所保存的token) path (文件的保存路径，可以自行设置，我的设置是“img/$customPath”) customPath (这就是path设置里的那个参数，我选的“年”) customUrl (没填) 到这里，差不多就配置好了，可以随便上传一张图片试试能不能用，我这里上传了一张蜗壳的照片。 下图是Gitee示例： 测试图片测试 \" 测试图片 ","date":"2021-09-09","objectID":"/blog/2021/21-09-09_picture-bed/:3:0","tags":["blog"],"title":"可同步图床配置——PicGo+Gitee/Github/Gitlab+Onedrive","uri":"/blog/2021/21-09-09_picture-bed/"},{"categories":["record"],"content":"Onedrive同步配置 PicGo是一个很棒的工具，但是之前有一个很大的问题就是没有办法进行不同主机之间的同步。这就导致在一台主机上上传过的图片只在该电脑保存有记录，其他电脑是找不到的。当然，这可以通过直接去图床网站上找链接，或者是在电脑之间复制PicGo的配置文件来解决。 但是这些解决方案都太麻烦了，而我又是一个比较懒的人。 目前最新的PicGo 2.3.0 仍然不能解决该问题(事实上让一个开源软件作者来搭建服务器并提供同步功能确实有点苛刻)，但是该版本提供了自定义配置文件路径的功能，为解决同步问题提供了可能。 我所采用的方案是将PicGo的配置文件所在的文件夹使用第三方云同步平台进行同步，这样就实现了同步功能。 可行的同步平台有很多，如 Onedrive、Dropbox、Google Drive、seafile (如果有的话)等。甚至Baidu云盘好像最近也免费提供了类似的服务“同步空间”，虽然每月只有1G的免费流量，但总比没有强。 说到这里岔个题，我一直感觉用户对百度网盘的要求过于苛刻了，对于一样免费的产品，百度云盘是唯一一个能够为我提供2T免费存储空间的平台，这一点迄今还找不到替代者。至于很多用户一直以来报怨的下载速度慢的问题，我只想说反正都是白嫖的，还要啥自行车。从我自己的使用角度来讲，平时用百度网盘保存同步或者是备份一些不经常用的文件，如照片、打包的文档资料等，还是挺好的。 书归正传，首先找到一个适合自己的同步工具，我使用的是Onedrive，其同步文件夹为D:\\Onedrive\\，如果想改变PicGo的默认配置路径，则需要首先打开配置文件，然后加入这么一行配置信息： \"configPath\": \"D:\\\\Onedrive\\\\ApplicationData\\\\picgo\\\\data.json\", \"picBed\": { 这是我自己的配置，个人根据情况不同进行修改，另外根据官方建议，可以手动将data.json, pigco.db文件复制到自己的自定义文件夹内。 ","date":"2021-09-09","objectID":"/blog/2021/21-09-09_picture-bed/:4:0","tags":["blog"],"title":"可同步图床配置——PicGo+Gitee/Github/Gitlab+Onedrive","uri":"/blog/2021/21-09-09_picture-bed/"},{"categories":["record"],"content":"总结 到这里就完成了配置和自动同步配置，当然也可以添加一些其他的免费图床SM.MS, Superbed等图床作为备份，我也确实是这么做的。 最后不得不说一下，感觉PicGo真的是开源代码的典范，自己提供一个框架和一套接口，其他人可以按照接口开发各种各样的代码。我感觉对于实用性的工具应用，这种开发方式非常合适。 功能强大，但不臃肿，用户有足够多的定制选择权。 ","date":"2021-09-09","objectID":"/blog/2021/21-09-09_picture-bed/:5:0","tags":["blog"],"title":"可同步图床配置——PicGo+Gitee/Github/Gitlab+Onedrive","uri":"/blog/2021/21-09-09_picture-bed/"},{"categories":["乱七八糟"],"content":"一路花香一路唱 xxx和xss自然可以称得上是\"花\"，如果我们在放音乐的时候所发出的声音姑且可以称为\"唱\"，那么这首歌便可以说是我们行程的真实写照了。 ","date":"2021-06-14","objectID":"/blog/2021/21-06-14_journey-to-northwest/:0:0","tags":["travel notes"],"title":"西北游记","uri":"/blog/2021/21-06-14_journey-to-northwest/"},{"categories":["乱七八糟"],"content":"旅途开始 旅程将从西宁开始，也将在西宁结束，绕着青海和甘肃省的一些著名景点游览一圈，有始有终（如图一）。6月5号我们首先从北京大兴机场乘坐飞机出发前往西宁市，从学校到大兴机场打车用了一个半小时，距离颇远，但大家心情愉快，有说有笑，虽然遥远但并不觉漫长（更何况路上司机师傅还主动给我们展示了电动汽车的加速性能😏）。飞机起飞后两小时就到达了西宁曹家堡（pu）机场，计划打车先去宾馆放东西，然后去夜市逛逛，但不幸的是车堵在了一条进城的路上，耽误了不少时间，所以后面逛夜市的计划也就泡汤了。其实在飞机即将降落的时候，我们就透过窗户看到了一条堵得长长的公路，当时身处局外感叹这条路好堵的时候，怎么也没想到一小时后，自己也将会堵在这条路上，不得不感叹世事难料啊😂。走走停停中，我们一路好奇地打量着这个城市的每一个招牌，寻找属于这个城市的独特印记，最后在将近十一点的时候才到宾馆。 办理入住的时候，前台大姐看着我们的身份证突然说了句”我原来家在知春路”，因为出来旅行，大脑已经从工作学习状态（包括地点）转换出来，所以对于这句略显突兀的话，我们先是一愣，待反应过来”知春路“乃是北京的一处地名，便和她互认”老乡“聊了几句，她跟我们简短分享了她的一些经历和她对于北京和西宁生活节奏的体会。后来从“知春路”的插曲中得到了一些思考，也许旅行的意义就是换个新的环境，将思想暂时从紧张的学习工作中解脱出来，从而得到片刻的放松。由此得到的启示就是，旅行的时候要把学习工作的事完全抛到脑后（危）。 图一：旅行行程图（图片来源于网络） ","date":"2021-06-14","objectID":"/blog/2021/21-06-14_journey-to-northwest/:1:0","tags":["travel notes"],"title":"西北游记","uri":"/blog/2021/21-06-14_journey-to-northwest/"},{"categories":["乱七八糟"],"content":"祁连草原，张掖丹霞 本来应该满怀期待早起出发，不巧的是昨天我刚下飞机就看到了??邮件的回复，并且老师希望能够视频交流一下，时间定为第二天早上9:30，按照计划我们此时应该已经在路上了。这突然的变故使我措手不及，因此我把这件事跟同伴说了一下，他们纷纷肯定了这件事的重要性，并愿意更改计划，这件事使我颇为感动（希望他们能够看到😉）。经过商议，最终决定等我在宾馆开完会再出发。结果，后来的事实表明我们太低估这次会议的时长，原本以为一个小时结束的视频共持续了两个多小时，同伴们就在宾馆打了一上午牌（后来知道叫uno）。会议完之后，出于对同伴的愧疚，我提议请大家吃饭，好的那种。 同伴告诉我由于天气原因，成哥决定将游览路线从顺时针改成逆时针（如图一）。我们匆匆收拾行李下楼，至此第一次见到了成哥。由于原本上午计划的行程被耽误了，所以下午只能拼命赶路，只为能够在天黑之前到达张掖的七彩丹霞景区（因为不是油菜花开花的季节，所以门源花海还不存在）。前两个小时一直在走盘山公路，我小时候就比较容易晕车，虽说长大后好了很多，但是对于这种拐弯抹角的山路还是毫无招架之力。每拐一个弯就像是用棍子在胃里搅拌一下，没过多久我的胃里就翻江倒海，但好在这种路况并没有持续太久，在差不多到达祁连大草原的时候就结束了。在这期间差不多两点的时候，我们在路边的一个面馆匆匆吃了顿中午饭。当时地处高原，且天空下着小雨，又冷又饿又难受的我感到非常虚弱，就让同伴帮我随便点了碗炸酱面，幸运的是这个面吃着还不错。 图二：雪山 匆匆吃完饭后，我们再次出发，后面的行程中，道路稍微平缓了一些，雨也渐渐转停。透过车窗可以看到路边山坡上的牛羊和远处的雪山，虽然当时刚下过雨的天空灰暗，几乎与远处灰白的雪山融为一体，但是我们还是被眼前这高冷神秘且纯净的雪山所震撼，在崎岖的山路上快速穿行的汽车里，我们透过车窗按下快门，尽可能记录下这些迷人的风景。此时晕车所带来的痛苦早已消失，看着眼前壮观的景色，沉浸其中，颇有一种绝处逢生之感。 在此期间，我们经过了祁连大草原，汽车从公路上飞驰而过，近处是翠绿葱郁的草原，远处是连绵不断的祁连山脉。看到这些景色，不禁遐想，当年年仅19岁的霍去病也许就是在这个山谷与匈奴骑兵短兵相接，将河西走廊纳入汉王朝的版图，为后来的丝绸之路扫清障碍。这段历史给了我无穷的想象空间，让人心驰神往。 图三：张掖七彩丹霞 将近傍晚的时候我们到达了张掖市七彩镇，著名的七彩丹霞景区就在这里。刚进景区就出现了一个小插曲，xss的手机落在了厕所，还好等赶忙回去寻找的时候碰到了一个捡到手机的好心人，总算是有惊无险。同样是天气原因，七彩丹霞虽然仍是鲜艳瑰丽，但是少了阳光的加持，因此也就失去了震撼人心的力量。虽然没能看到阳光下的霞光万丈，心里不免有些遗憾，但大自然的鬼斧神工还是让人流连忘返。 晚饭的时候吃了一个比较有特色的菜，食材是鸡肉和类似于小花卷一样的面食，具体菜名忘了，可能叫鸡肉炖xx之类的吧，鸡肉本身普普通通，但是那个面食还是挺不错的，就连担心吃不惯面食的xss都颇为满意。还有一个菜叫沙葱炒鸡蛋，其品相和味道都和韭菜炒鸡蛋差不多，据说沙葱是当地的一个特色野菜，感觉就是粗细如粉条的迷你版大葱。一件有趣的事就发生在这道沙葱炒鸡蛋上，准确地说是发生在盛菜的盘子上。xyy吃这道菜的时候够不着，xss就试图挪动这个盘子，结果用手轻轻一拉，盘子就从中间分开了，我们被这个突如其来的重大事故惊的目瞪口呆，待稍稍回过神来，就开始讨论这个奇迹发生的原因，主要进行了如下猜测： xss在扯盘子的时候使用内力震碎了盘子。 盘子盛上热菜以后，由于热胀冷缩或者量子力学等物理原因断开了。 服务员放盘子的时候力气稍大，再加上盘子本身质量的问题，所以就碎了。 我本人比较赞同第三种可能，考虑到我们所处的真实世界与武侠世界有较大区别，首先排除第一条，其次我们猜想如果盘子自己裂开应该会发出声音，而且我也想不出合理的物理解释，所以暂且把第二条也排除，最后就只剩下第三条。 ","date":"2021-06-14","objectID":"/blog/2021/21-06-14_journey-to-northwest/:2:0","tags":["travel notes"],"title":"西北游记","uri":"/blog/2021/21-06-14_journey-to-northwest/"},{"categories":["乱七八糟"],"content":"嘉峪关城一瞥，敦煌沙丘四顾 早起赶路，匆匆赶了半天，终于到达了酒泉市，我们在途中某川菜馆吃了顿午饭，吃饭之余，我们还关注了一下上午刚结束的高考语文作文题目，并就此引出了一段对高考语文的讨论，主题无非还是对高考刻板套路的嘲讽，以此体现自己作为曾经亲历者的优越感，就像一个久经沙场的老兵谈论自己参加过的某个战役。最后的讨论在xxx带我们温习”我家门口有两棵树，一棵是枣树，另一棵还是枣树“的阅读理解中结束，按照这句话的格式，我们还临摹了一句我们的真实情况写照——”我们今天有两个计划，上午赶路，下午还是赶路“。 事情果然如计划进行，继续赶路，下午到了不远处的嘉峪关，但是成哥说里面没什么好看的，且门票价格不菲，不建议进去看。于是我们采纳了成哥的建议，在景区门口处与身后刻着”天下第一雄关——嘉峪关“的大石头合了几张影，然后跑到了景区侧面远远地眺望了一下关城就离开了，据说里面那三个城楼一样的建筑完全是后来修建的。我们在三四点左右到达瓜州，并在一个十字路口旁的一排卖瓜的店铺前稍作停留，这些店铺均为活动板房，稍显简陋，且四周看不到任何其他建筑和人家。但因为地处十字路口，所以频繁有大小车辆经过，且方便停留，不一会就有好几个旅行团的大巴车停在店铺前，并由导游带着游客下车，看来是一个典型的“屠宰场“。下车前成哥嘱咐我们进去吃瓜，但是不要买，吃完直接就走。记得刚从张掖出发的时候，成哥就告诉我们回头要带我们去一个免费吃瓜的地，吃完就走，当时我们还以为去地里偷瓜，并提醒成哥换成”跑“可能更合适。 瓜还不错，挺甜的，牛肉干也不错，只是不小心吃到一个辣的，害我喝了好多水。接下来继续赶路，并在四五点左右到达了敦煌。在宾馆休息了一会，大概六点多，成哥带我们去了一个沙漠露营基地，名字很有意思——”熊出漠“，这可能也是后来xss把工作小哥阿虎错叫成阿熊的原因，不过如果按照字面意思的话，熊好像指的是我们😒。 营地包括不限次数的滑沙和单次的沙漠摩托以及太阳落山之后的自助火锅和篝火晚会等，夏季西北部地区的落日比较晚，大概要到晚上九点多太阳才下山，因此我们还有比较充分的时间近距离地接触沙漠。因为以前从未踏足过沙漠，所以我刚到营地的时候还是感到很新鲜的，但逐渐发现在沙漠中行走是一件很困难的事情，好在xss提前买的鞋套起到了很大的作用，要不然满鞋沙子会更难受（是的，我后来体会到了😞）。我们首先玩了一下滑沙，遇到了颇为健谈且富激情的阿虎，这位老哥洗脑般的声音至今仍记忆犹新，尤其是在给xxx拍照的时候所发出的”天呐，好美啊“的感叹至今仍在我脑海里回荡（一部分原因是我非常同意他的看法😏）。然后我们排队去坐沙漠摩托，因为该项目体验颇为刺激，所以xxx直接就放弃了该项目。虽然我心里一直抱着不能怂的信念，但随着离队头越来越近，心里还是一直犯嘀咕。坐完之后感觉跟坐过山车一样（虽然我没坐过过山车😂），不同的是沙漠摩托没有安全带之类的保障，而且感觉该项目对司机要求较高，如果技术不行，很有可能翻车。我们刚到的时候太阳大，风也大，好在随着夕阳西下，太阳慢慢变得稍微温和了些，风也渐渐平息，依托沙漠广阔壮丽而又纯净的背景，成哥颇为熟练地帮我们每人拍了好多照片。 图四：沙丘 太阳落山之后，我们回到了营地的宴席上，除了想一心干饭的xyy外，我们其他几个抱着好奇的心态参加了“篝火晚会”，整个过程大概就是在主持人的号召下，所有人一块挥手、蹦蹦跳跳和转圈圈，也许是因为我没有融入该氛围，所以感觉整个过程颇为尴尬。随后的“沙漠蹦迪”也差不多，且音效和灯光效果劲爆，在感到心律不齐和头昏眼花之后，我们就退出了这场”狂欢“。待我想返回宴席饱餐一顿的时候，失望地发现自助火锅的味道实在是不敢恭维，挑来选去，竟然感觉最好吃且顶事的是黄瓜，因为吃饭时间较晚且考虑到晚上还有看星星的环节，为了填饱肚子，我坚持吃下了不少黄瓜。同样吃了不少黄瓜的还有xss，但是ta居然喜欢吃煮过的。 草草地吃完晚饭后，大概已经晚上十点多了，此时我们准备去沙漠上看星星，临走之前我又拿了几段黄瓜边走边啃。这次往沙丘里走最大的失误就是没穿鞋套，以至于后来回去之后鞋袜里抖出好多沙子。往沙丘里稍走一段，避开营地的灯光就可以看到满天繁星，但若想长曝光把星星尽可能拍得好看，还要找一个合适的小沙沟，以避开四周各种光源。但这并不是一件容易的事，因为直到午夜也还是有沙漠摩托和拿着手电筒的行人来往经过，毫无疑问，这片区域的沙丘已经被现代化的文明侵入，没有了原本的宁静，自然也不复本来的面貌。 图五：沙漠星空 ","date":"2021-06-14","objectID":"/blog/2021/21-06-14_journey-to-northwest/:3:0","tags":["travel notes"],"title":"西北游记","uri":"/blog/2021/21-06-14_journey-to-northwest/"},{"categories":["乱七八糟"],"content":"举世闻名莫高窟，沙漠奇绝月牙泉 终于到了莫高窟！在这次旅行的所有景点中，莫高窟是我最期待的一个，原因可能在于莫高窟的名气太大了，以至于总是能无意间从各种渠道获取莫高窟的信息，我甚至可以想象当听到有人说他不知道莫高窟的时候，我应该如何控制自己惊讶的语气来表现对他的嘲讽，即使我对莫高窟的认识也仅仅是听说过而已。 鲁迅曾经说过”期望越大，失望越大“，这次果然又应验了。我们大概上午十点到达莫高窟景区，首先是观看两场巨幕小电影，电影主要介绍了莫高窟的建造历史和几个重要洞窟，后来觉得这些介绍还是挺有必要的，要不然更是什么都看不懂。我以前看过一个纪录片《河西走廊》，其中有一集专门介绍莫高窟，内容形式跟那两个小电影差不多。看完小电影，我们乘坐景区的大巴车到达真正的莫高窟。莫高窟的洞窟数量很多，但是适合参观的并不多，而现在开放给游客的就更少了，只有六十四个，而景区导游只会随机的带我们参观八个洞窟，其中包括必看的由”九层楼“（98窟）、涅槃窟（158窟）和藏经洞（17窟），出于保护壁画等原因，洞窟里不允许开灯和拍照，再加上参观的人多且时间紧，所以我们只能跟随导游在昏暗拥挤的石窟里走马观花地看一看。 图六：莫高窟九层楼 整个过程并无太多惊喜，甚至于在开头小电影里看到的雕像栩栩如生的220窟也没有参观，自然也就难免失望。后来想了一下，失望应该是必然的，原因在于莫高窟的价值体现在历史、文化和艺术的记载和传承上，而像我这样的文盲游客只图看个热闹，没有相应的文化积累和研究，自然觉得失望。并且洞窟内的壁画大多是经变图，这是中国工匠所独创的以绘画的形式来表现佛教典故的方式。因为缺乏相应的佛教知识，所以参观的时候自然对于壁画的内容一脸懵逼，依靠导游的讲解才勉强知道大概内容。如果我对里面的佛教典故都能够如数家珍，那么参观的体验可能就大不相同了。我之所以这样认为，是有一定的事实依据的，因为我曾在某个壁画的一角看到了关于唐玄奘和猴行者取景的场景，那种感觉就像是在异乡遇到了老熟人，兴奋且惊喜。 下午观看了一场关于敦煌的演出——《又见敦煌》，据说该节目是来敦煌必看的几样东西之一，并且曾经创下11天门票收入一个亿的记录（可能一个原因是票价确实很贵😓）。于是我们下午也满怀期待去看了该演出，该演出的形式是我以前没有见过的，我暂且把它称之为交互式舞台剧，其采用多视角表演和叙述的方式，拉近了观众与表演者的距离，表现方式独具匠心、别具一格。比如透过玻璃地板俯视表演者的一举一动，给人一种上帝视角的感觉，还有透过玻璃天花板仰视着覆盖在玻璃上的沙子被一层层拨开，仿佛亲眼见到了敦煌文物重见天日的时刻，并且不时还穿插着身着现代衣着的表演者与身着古装的表演者之间的对话，而身着现代衣着的表演者就站在我们中间，仿佛我们也能与古人对话一般，彻底打破了观众与历史人物之间的壁垒。诸多身着古装的历史人物中，对我来说印象最深的要数大诗人王维了，因为表演者走路的姿态着实让人忍俊不禁，其步伐完全称得上是“六亲不认”了。不知道王维当年走路是否真的是这样，反正我认为可能性不太大。 舞台剧的相当一部分内容集中到了王圆箓（lù）偷卖经书的情节，由此引发了我对王道士行为的思考，在我看来，王道士把经书卖到国外不见得是件坏事，塞翁失马焉知非福，如果当初没有送到国外，也许早就焚毁殆尽在后来的战争和动荡中。而现在经书虽然散落世界各地，但庆幸地是大部分都得到了很好的保存，只要还保存完好，就还有回来的机会。况且即使别的国家得到了很多稀世珍品，但其终究还是中国文化的一部分，而文化这种东西只能被自己遗忘，是无法被别人夺走的。 差不多也是当天的六点钟左右我们去了敦煌另一个著名景点——”鸣沙山月牙泉“，月牙泉是沙漠中一汪形似月亮的泉水，地方不大，但因为处在沙漠之中，所以相当惊艳。在去月牙泉之前，成哥带我们去了一家面馆吃午饭，老板非常热情，我们刚坐下就给我们端上来一盘西瓜，非常甜，据说是新疆产的。然后我们每人点了一碗面，等面上来的时候，如脸盆一样的碗着实使我大吃一惊，每个人面前放着这么一只碗，看起来十分诙谐，让人忍俊不禁。也许面馆老板早已司空见惯，淡定地看着我们这群没见过世面的人在这里一惊一乍，说笑个不停，又是合影又是摆拍。不仅是碗，碗里的面也很惊人，面条如巴掌般宽，偌大的碗里，总共只有两三根这么宽的面条，开始还担心吃不饱，结果到最后吃撑了才勉强吃完。 图七：月牙泉 吃完饭之后，我们就去了景区，因为前一天去过沙漠露营地，该拍的照片也拍了不少，所以这次再来到鸣沙山的时候并没有太多激动和欣喜。对于这个景点我们唯一感兴趣的其实就是月牙泉了，于是我们目标明确地朝月牙泉走去。等我们到达月牙泉之后发现在近距离只能看到月牙的一角，无法看出月牙的轮廓，于是我们朝着对面的沙丘爬去，事实上这也是很多人都在做的。沙丘稍微有点高，但好在有一个木梯子铺在沙地上，踩着木梯走就跟爬山一样，虽然相对轻松很多，但是爬到山顶还是气喘吁吁。我们到达山顶的时候，太阳正在落山，于是就有了图七。太阳下山之后，我们也觉得没意思，就下山回去了。成哥最后带我们去逛了一下敦煌的夜市，据说很热闹，到了之后感觉稀松平常，无甚特别，匆匆转了一圈就结束了今天的行程。 ","date":"2021-06-14","objectID":"/blog/2021/21-06-14_journey-to-northwest/:4:0","tags":["travel notes"],"title":"西北游记","uri":"/blog/2021/21-06-14_journey-to-northwest/"},{"categories":["乱七八糟"],"content":"西出阳关，天降翡翠 离开敦煌后，我们前往下一个目的地，古代中国最西边的关隘——阳关。王维的诗句”劝君更进一杯酒，西出阳关无故人“使得阳关家喻户晓，即使故阳关早已经消失在茫茫戈壁之上，后来重建的阳关还是吸引无数游客慕名前来。不由得感慨文化是如此的强大，可以贯穿古今、超越物质的存在而经久不息。不觉想起李白的诗句”古来圣贤皆寂寞，惟有饮者留其名“，本来是一句扯淡的大话，没想到一语成谶，”岑夫子“和”丹丘生“真的因为一场酒局而千古留名。相同的例子还有那个著名的唐朝农民”汪伦“，按照戴建业老师的说法”汪伦这狗东西真是走了狗屎运，就因为送了下李白，结果一千多年后，全世界都知道唐朝有个农民叫汪伦。“ 图八：阳关古城遗址 书归正传，阳关的标志性建筑就是古阳关现存的唯一一处烽火台遗址，原来八点几米，现只存三米多了，除此之外，古阳关就再没有其他古迹留存了。烽火台四周是一望无际的戈壁，阳关烽燧孤零零的矗立在这片广袤辽阔的土地上，更显凄凉和悲壮，仿佛艰辛孤苦而又坚毅挺拔的戍边将士。图八中栈道所围就是古阳关所在地，如今已荡然无存。（来到这才知道原来”阳关道“里的阳关也是指这里） 阳关烽燧景点周围毫无遮蔽，酷热难耐，稍作停留我们就返程了。不禁心想，古代的阳关是否也像是今天那么炎热干燥，但即使是这样，作为古代中国的西大门，不知有多少往来商旅将阳关看作前方路途的希望。从阳关烽燧遗址出来后，我们途经一个小的射箭场，设备为传统的弓箭，我很感兴趣，而且问了下，价格实惠，就提议大家射几箭。xyy把仅有的十二块钱零钱拿了出来，一块钱一只，每人三只箭。因为我兴趣最高，所以我先来，箭靶很近，大概五米的样子，我颇为自信，感觉应该非常简单。管理大叔说用箭头瞄准黑圈的右下方，我拿起弓箭瞄了一会，手就抖得不行，松了休息一下，再次拉弓，稍微瞄了一下就放箭了，因为弓拉的还算足，所以箭“咻”的一声就出去了，我放下弓，发现靶子上空无一物，斜着往后一看，原来箭射在后面的墙上。如此三次，只有一箭勉强射在了靶子上，但是依旧没有环，我颇为沮丧，为自己的过分自信而惭愧，只好安慰自己说试的次数太少了。 翡翠湖是一片断断续续的盐湖，目前免费，据成哥说很快就要开始收费了。在阳光的照射下，湖水颜色清澈且碧绿如翡翠，岸边是厚厚一层白色的盐结晶，我随手拿起一小块放到嘴里尝了尝，味道齁咸，是盐无疑。见湖水颜色清澈见底，我就在湖边洗了洗刚才摸到泥巴的手，待手上的湖水干了之后，竟留下一层白色粉末，而且拍打不掉。湖边那么多结晶，湖水自然是饱和状态，自己刚才怎么就没想到呢。 图九：翡翠湖 湖水梦幻般纯净的颜色使其成为拍照的绝佳地点，湖边随处可见的是拍照和被拍的俊男靓女，还有少数是像我这种负责拿东西拎包的摄（打）影（杂）助（人）理（员）。当无事可干的时候，我就看xxx和xss拍照，但这件事有风险，因为有时候会由于笑得太大声而被驱逐。有时候我也会想一些乱七八糟问题，比如湖水为什么那么绿？青海为什么那么多盐湖？为什么有的有盐，有的没有？这些问题一般都想不出个所以然，往往最后归结为”大自然的鬼斧神工”便不了了之。 随着逐渐日落，再加上寒风阵阵，我很快就被冻得瑟瑟发抖，且因为衬衣外套与湖水颜色相近，有时拍照还需要脱了外套，其中辛酸不言而喻。从翡翠湖回来之后我吃到了旅途中第二好吃的东西——羊肉炕锅，据说就是把羊肉、油炸土豆片和洋葱等放一块焖一下，最后放上一些烤饼。炕锅非常美味解馋，以至于我在多天之后的某个晚上写下这些回忆的时候还能不自觉地流下口水😂。同时我感觉这顿饭比较符合我在前文说的”好的“的标准，所以我决定这顿我请，因此其他人在吃这顿”白嫖羊肉炕锅“的时候应该比我吃到的更加美味，好在后来我也体验到了这个味道，就是第二天成哥在另一家店请我们吃羊肉炕锅的时候，这就是我感觉第一好吃的东西，当然，这是后话。 ","date":"2021-06-14","objectID":"/blog/2021/21-06-14_journey-to-northwest/:5:0","tags":["travel notes"],"title":"西北游记","uri":"/blog/2021/21-06-14_journey-to-northwest/"},{"categories":["乱七八糟"],"content":"U形国道，雅丹地貌，日食 U形国道不过是315国道上的一段上下坡，但因为其拍照效果较好，竟成了一处”网红“景点，不知道当初设计这段路的工程师会不会预料到这一点。我们到达时，路旁停了许多大大小小的汽车，而国道上多的是趁着没车的间隙走到路的中间，顶着寒风搔首弄姿的人。当然，不久我们也将成为其中的一员。但我们还算属于比较遵守交通规则的一类，如果远远地望到有车开来，便急忙躲开。另外还有一类人淡定地站在路中间，自顾自地拍照，根本不管有无汽车到来，甚至置汽车喇叭于不顾，见到此景，我们往往嗤之以鼻（虽然有五十步笑百步之嫌😂）。经过昨天翡翠湖边寒风的毒打，我们纷纷把最厚的衣服穿上，xxx不仅穿上了棉袄，头上还围了一个围巾，不过外形依旧漂亮，而且还多了一些常年在田间劳作的中国女性气质。由于我昨天被风刮的头稍微有点疼，因此今天在头上缠了一个类似于发带的东西，用以保暖，后来的事实证明此方法极为有效。 图十：U形国道 成哥驱车带我们前往南八仙（希望没记错）参观雅丹地貌，雅丹地貌按照我的理解，就是由于风雨等因素的侵蚀，使得土壤中比较柔软的部分逐渐消失，从而只剩下更为坚硬的部分，最终的呈现效果就是空旷的地面上伫立着一坨坨（按照xss的惯用量词）土堆，当土堆的数量很多，连成一片，放眼望去到处都是的时候，就显得颇为壮观，而当一种景色比较壮观的时候就可以用来拍照了😂，图十一中隐约可见的白色汽车即是我们这几天的交通工具，劳苦功高，应当被记录。 图十一：雅丹地貌 从雅丹地貌景点回来后，我们在大柴旦附近的一处淡水湖旁观看了日食，因为是日偏食，所以并不明显，但是我们借助专业的设备（四层太阳镜，虽然后来发现其实只相当于两层）还是能够清楚地看到太阳被咬掉的那一小口，图十二就是拍摄的照片。最后不得不提我们看日食的地方蚊子挺多的，但是跟明天将要遇到的相比，就算是小蚊见大蚊了。 图十二：日食（最小感光+最快曝光+最小光圈+太阳镜） ","date":"2021-06-14","objectID":"/blog/2021/21-06-14_journey-to-northwest/:6:0","tags":["travel notes"],"title":"西北游记","uri":"/blog/2021/21-06-14_journey-to-northwest/"},{"categories":["乱七八糟"],"content":"青海湖远眺，星空 由于行程变成了逆向，我们最后一站才终于到达了著名的青海湖。前往青海湖的途中路过了一个淡水湖——”可鲁克湖“，与”可鲁克湖“相临的是”托素湖“，这是一条咸水湖，关于这两个湖还有一个传说，这里就不介绍了，可以自行脑部一个男女相爱，家庭反对，最后双双殉情化身湖水的故事。我们沿着“可鲁克湖”边上的公路行驶，湖的四周芦苇丛生，水鸟繁盛，景色宜人，嫣然一副江南水乡的景象，很难想象公路的另一侧就是一望无际的戈壁。我们在湖边的一个入口处停了下来，然后兴冲冲地准备跑到湖边好好欣赏一下美景，临下车前成哥提醒了一句，这里蚊子比较多。还没走到河边我们就已经见识了”蚊子比较多“是什么样的场景，这里的蚊子不管是从质还是量上都远超我的想象，个头大且多，给人的震慑力极大。xss和xxx还没走到河边就匆匆返回了车里，我跟xyy抱着一睹究竟的决心，冒着枪林弹雨跑到河边，期间全身不敢有丝毫停歇，一边手舞足蹈，一边摇头晃脑。现在回想起来，当时的状态竟像是突发癫痫的精神病患者。待我到了河边，发现蚊子的数量更多，就匆匆往回返，也许蚊群对突如其来的美味佳肴还未来的及做出反应，所以我才有机会拔腿跑回车里，侥幸留得一条小命。像这种一边拼命跑一边在身上拍打的场景，我上次经历应该还是上小学那会捅马蜂窝的时候。 关于这个场景，我想到了李诞在吐槽大会上关于其小时候所经历的田园牧歌的场景的描述。大概意思是他小时候生活在草原，草原上蚊子又大又多，且叮咬的破坏力很大，如果上厕所的时候屁股被叮咬一口，可能连裤子都提不上，因此他在草原上露天上厕所的时候一般都是边上厕所边摇晃，长久以来养成了习惯，以至于现在上厕所不晃几下感觉方便不干净。 从”蚊子湖“离开之后又是不停的赶路，差不多中午的时候，成哥带我们去吃了一家牦牛大骨汤，临下车还叮嘱我们点普通碗就行，不要点其他的。这家排骨汤还挺不错，肉质松软，汤味清香，而且价格公道。吃饭的时候服务员试图把肉酱推销给我们，但是我们谨记叮嘱，啥也没买😂，并且我觉得他们的”特色肉酱“味道跟我小时候自己家里腌的酱豆（豆豉）味道差不多。 下午我们继续赶路，在翻越橡皮山的时候，已经可以远远地望见青海湖，远处的青海湖犹如一条宽宽的蓝色丝带，横铺在天地之间，其颜色纯洁晶莹如同一块蓝宝石，震撼之余不免惊呼”哇~太美了！“。我们在青海湖边上的一块山坡的草地上停下来拍照，虽然一路上经过很多草地，但这是第一次双脚真正踏上草地，感觉果然与仅在远处观看不同。近处的草地虽不像远远观看那么洁净纯粹，但多了些真实厚重的质感。草地上随处可见的牛粪打消了xss草地打滚的想法，于是腰上还贴着膏药的xss带着无处发泄的活力，在草原上活蹦乱跳。我对草地上随处可见的洞穴充满好奇，很想知道里面住的是什么繁盛的生物。趁他们拍照的时候，我往草地深处走去，还真的看到了一个土黄色的小生物在鬼鬼祟祟、探头探脑地四处寻觅，观察片刻，我认出这应该是一只老鼠。因为距离不远，我决定飞奔过去看能不能逮到一只，但等我快跑到跟前的时候，这个小家伙迅速地选了一个洞穴，并且钻了进去，至此我可以大概断定这些四通八达的洞穴就是老鼠洞。 图十三：青海湖 从草地上回来之后，我们继续赶路，成哥说要带我们去一个可以俯视青海湖的半山腰上，果然，在这里我们可以把青海湖近处的轮廓尽收眼底，远处湖天一色，宛如一块巨大的浅蓝色幕布。有如此美丽的景色，自然也免不了一通拍照，成哥的流水线再次启动，随着一声声”下一个“，我们一个个站到高处与身后的青海湖合影。景色太美，甚至后来成哥也忍不住让我们给他拍几张照片，其中的一张照片后来还成为了成哥的微信头像，这是后话。 从半山腰下来后，我们找了一家临近青海湖的宾馆，把行李放下之后，就去了青海湖边。入住的时候，宾馆老板给我们讲了一个可怕的故事，不久前五一假期的时候，从北京来的几名游客入住宾馆，但晚上又决定去青海湖边露营，宾馆老板告诉他们晚上湖边非常冷，试图阻止他们，但劝说无效，只得给他们退房。结果，当天晚上半夜的时候，几乎被冻僵的游客敲开了宾馆的大门，待老板把他们带到大厅的时候，发现他们已面色青紫，情况危险，于是急忙打通报警电话，大概三个小时之后救护车才把他们拉走抢救。如果换作其他地方，我可能会认为这是宾馆老板骗人的鬼话，目的是为了唬住那些想出去露营的人。但是经过了这几天对青海天气的切身体验，我丝毫不敢怀疑老板说话的真实性，更不用说前几天的白银马拉松事故让人们对高原气候心有余悸。 来到青海湖边，我照例又尝了一下湖水，像海水一样咸，据说湖里只生长了一种被称为湟鱼的鱼类（后来百度了下，其实还有其他几种小型鱼类），看着湖面上时不时飞过的海鸥，不知为什么湖里的物种不像海里那么丰富。相对于远处，青海湖边又是另外一种景色，站在湖边，视野极为开阔，目光所及皆是一片淡蓝，甚至远处天和湖之间的分割线都几不可辨，天地之辽阔，风景之纯净，令人心旷神怡。湖边有很多被精心打扮的马和牦牛，用于给游客提供拍照服务，无人光顾时，这些牲畜就被拴在木桩上，当有游客付钱，便可以骑在他们后背上溜达一圈，拍几张照片，甚至有时为了拍照效果，牵马的小贩还会把它们赶到湖边的浅水区里。不管牵着走还是拴在那，这些牲畜始终低头沉默，任劳任怨，看不出兴奋，也没有反抗，甚至没有任何多余的动作，沉默地让人心疼。想必如此循环往复，日复一日，它们也早已习惯了吧，想到这里，心里不免有些伤感。在这美丽壮观的青海湖边，看似自由的马和牛被绳索拴在了这里，看似掌握牲畜命运的小贩被生活拴在了这里，而此刻看到此情此景的我呢？ 图十四：银河 同伴们制定了看银河和日出的计划，大概计划是先回去睡觉，待差不多一点多的时候，到宾馆的天台上看银河，拍星轨，到差不多三点的时候再回去睡觉，然后五点半起来去青海湖边看日出。夜晚就这样被均匀地切分开了😞，听完这个计划，我只想赶快回到房间珍惜现在这来之不易的睡觉时间。在差不多一点多的时候被xyy叫醒去看银河，本来对银河还抱有些许期待，但发现这不就跟我曾在家里的某个晚上上厕所的时候无意间瞥见的一样吗，也就觉得不过如此啊。依赖于xyy强大的修图技术，最终的图片如图所示。xyy还尝试拍出星轨，但是由于相关经验的缺乏，以及对相机功能的了解不够准确，所以最终只得到了一个虚线形式的星轨图。 图十五：虚线星轨 ","date":"2021-06-14","objectID":"/blog/2021/21-06-14_journey-to-northwest/:7:0","tags":["travel notes"],"title":"西北游记","uri":"/blog/2021/21-06-14_journey-to-northwest/"},{"categories":["乱七八糟"],"content":"青海湖日出，返程 早上看日出不出意外，又是在瑟瑟发抖中度过的。待我们到达青海湖边的时候，湖边已经有不少人了，我们一个个站在湖边像是虔诚的朝圣者，期待着旭日东升，一边瑟瑟发抖，一边目不转睛地看着东方，生怕错过了太阳升起的那个瞬间。而太阳却没有直接了当地升起来，而是犹抱琵琶半遮面，躲在了云层后面，仿佛韬光养晦一般，只待云雾散去，便一鸣惊人。事实也确实如此，当太阳从云层后面出来后，就几乎无法直视了。因此总的来看，这次看日出并不算特别成功。不过此时我早已坚持不住，疲倦加寒冷使我对日出漂不漂亮提不起更多的兴趣，目不转睛地看着太阳是因为实在没事干，并且不想辜负自己所付出早起的艰辛，才尽可能地多看几眼，仿佛这样盯得头晕眼花能够更加划算。 图十六：青海湖日出 路上经过了一些藏民居住区，成哥带我们去藏民家里品尝原汁原味的牦牛酸奶，味道酸爽可口（皱眉表情），但是为了能够珍惜这次品尝的机会，我坚持没有加糖。藏民小姐姐还主动提出可以把自己的藏族衣服借给xxx和xss来拍照，肉眼可见ta俩两眼放光，迫不及待地回答说“可（太）以（好）吗（了）”。藏民小姐姐转身拿衣服，并颇为客气的说“希望你们不要嫌弃”，从俩人跃跃欲试的反应来看，“不嫌弃，不嫌弃”必然是发自内心的回答。于是我们有了此次旅程最后一组照片，且是为数不多的成哥和我们的合照。 在回西宁的路上路过了宗喀拉泽，据说是经过某某机构认证的最大的拉泽（据说意为殿堂）。成哥说这个景点不要票，结果我们找了半天没看到入口，于是找到路边一个卖”特产“的人问路。也许那大哥”特产“卖的不顺利，所以颇为不爽地指着自己的嘴跟我们说”鼻子底下是张嘴，找不到路，你们不会找人问吗？“，我们被这位大哥义正言辞的回答给镇住了，竟一时语塞。只是事后我还是没想明白我们找它问路这件事为什么不符合它说的”找人问路“。 等到我们终于问到了路才知道，原来这个景区需要买票，票价30，听闻票价我们扭头便走，但卖票的大姐马上叫住我们，问我们是不是学生，得到肯定的回答后，她告诉我们学生票可以半价，不过从她的反应来看，我们是不是真的学生她也并不在意，只不过是想找一个合理而又体面的理由留住这几个来之不易的顾客罢了，所以我们连学生证都没拿，她就认可了我们的学生身份。后来我就在想，如果我们说不是学生，她会不会告诉我们身份证也可以半价😏。当然，这都是猜想，没有证据，不能凭空诬陷别人，但后面遇到的大师则是有真凭实据的。待我们买完”学生票“之后，就进入到景区，卖票大姐煞有其事地给我们每个人献上了一个黄布条，据说叫哈达。我心想花15块钱搞一条黄布条也行啊，虽说对我来说啥用没有，还没等我高兴完，她说这不是给我们的，是让我们贡献给山神的。当时心想，好家伙（学自xss）还有这一手，但后来的事实表明，我还是小瞧他们了，这只是下一个套路的开始。所以后来回想起来，感觉像是花15块钱买了个套路套餐。 图十七：宗喀拉泽 书归正传，可能是因为所谓的景区几乎没有什么人，所以我们进入景区刚走上阶梯就有一个“导游”在此等候。大概意思是她会带我们完成游览，整个过程颇像商店的导购（此处伏笔）。她带我们煞有介事地拜完四臂菩萨之后，就把我们领到了菩萨像后面的大师处贡献哈达。 刚还在打盹的诵经大师看见有顾游客过来，立马打了个哈欠提了提神，然后开始念念有词（此处没有任何不敬）。导游告诉我们这位大师正在为我们诵经祈福，然后说会逐个带我们去另外的祈福大师那里贡献哈达。因为我是最后一个，看同伴一个个被带走，百无聊赖，就开始东张西望。导游看到之后走过来告诉我说你不用着急，你在这里虽然等待的时间长一点，但是接受大师祈福的时间也更长，得到的福祉也就更多一些。听闻此话，原本已经又开始打盹的诵经大师又开始“咪咪嘛哞”念了起来，我告诉导游我不着急，就是四周看看。 然后很快就到我了，我被带到祈福大师那里，大师请我坐下，我颇为虔诚地端坐在凳子上，大师首先问我年龄、学历、职业等信息，我做了一一回答并且确信这只是祈福所需的必要信息，而不是用来确认我的经济状况。然后大师就开始了一段语重心长、循循善诱的教导，大概意思是我是高学历人群，具有更大的能力，能力越大责任也就越大，应该多承担一些社会责任，多利用自己所学的知识做利国利民的事情，并且要活到老学到老等等。虽然是说教式的老生常谈，但是面对长辈的发自内心、感人肺腑的教导我是不敢表现出一丝不敬的，因此频频点头并附带着“是”，“是的”，“好的”等简短而表明态度的回答。这样的过程大概持续了两分钟，也许大师感觉时机已经差不多成熟（或者是因为没啥可说的了），然后话锋一转“今日你与山神有缘，可以向山神敬献佛灯以祈求保佑，但是事先说好，佛灯需要一定的花费，有100、200……不等”。待他说到“有缘”这个词的时候，我便预感到可能有事情要发生，并开始组织语言，力求让他明白我是如何地真心不希望麻烦山神。他开始报价格的时候，我就打断了他，诚恳地跟他表示我作为一个在校生，还没参加工作，家里情况又不好，能力实在有限等等。当时甚至还想把我认为这种花钱卖灯的行为有可能亵渎神灵的观点告诉他，但是考虑到这样可能会被打，所以就没说。事实上大师也没给我机会说，待他大概确定我并不想祈福之后，直接左手一挥“好，那缘分尽了，请这边走”，我只得悻悻离开。 事后我对这段并不愉快的交流深表遗憾，他们作为能将想法直达山神的大人物，得罪他们岂不等于得罪山神，想到这里不觉心中惊恐万分。后来问同伴，他们也都有类似的经过，因此心里也就稍稍释然了些。最后为了防止别有用心的人乱作揣摩，我觉得有必要进行说明，我没有任何亵渎或者不尊敬神明和宗喀拉泽大师们的意思。 最后再次到达西宁，临走之前想去尝一尝成哥安利的水煮羊肉，但是无奈逛了好几家都没有开门，成哥说是现在时间太早，因为这些店一般都是晚上开张。于是，我们就略带遗憾地提前去了机场，不过略有遗憾也不是坏事，有遗憾才有下次再来的理由嘛。机场跟成哥离别的时侯，我准备效仿武侠人物，抱拳说句“青山不改，绿水长流，咱们后会有期”，但是感觉颇为中二，所以就只保留了台词部分。想到回学校之后，也很快就要收拾东西走人了，伤感加倍，看来六月是离别的季节呀，也许正是知道分离时的悲伤，才更应珍惜相处时的不易。 ","date":"2021-06-14","objectID":"/blog/2021/21-06-14_journey-to-northwest/:8:0","tags":["travel notes"],"title":"西北游记","uri":"/blog/2021/21-06-14_journey-to-northwest/"},{"categories":["乱七八糟"],"content":"总结 最后总结，因为xxx和xss在拍照方面做了充足的准备（我后来才明白拍照是主要目的），因此我也就蹭了很多照片，这几天拍的照片甚至比我在这之前拍的总照片还要多。去机场的路上，我们从发朋友圈的话题说到了写攻略的事，我再一次大言不惭（最近的一次是扎辫子）地说我要写篇游记，因为感觉旅游攻略就是简单的罗列，水平太低。但是后来发现自己文学水平的确不行，写着写着还是变成了简单的罗列，不得不再次感慨，原来没有不行的题材，只有不行的人呀😄。 其实本来就有写几篇日记把旅行记录下来的打算，因为反正日记只有自己看，所以打算随便写写。但是后来吹了牛，就不得不好好写了，但没想到越写越多，而且很难写到自己觉得还算满意，除了需要仔细回想重要经历之外，还要反复修改，很是不容易。现在仍然能回想起当时说写游记的时候，成哥突然转过头并投来期许的目光，并很快把微信二维码发给我，让我附在游记后面，当时就意识到自己挖的这个坑不得不好好填了😂。后来同伴也对游记怀有很大的期望，并给予很多支持（有事实根据，微信秒回提供图片）。但是自己能力实在有限，如果效果不尽如人意，还请多多担待～ 回想这一路，绝大部分时间都待在车里，因为担心会晕车，所以我不敢长时间看手机（以至于剧本杀也不敢玩），因此只好找一个不需要看手机的方式来打发时间。车内有蓝牙音响，且成哥喜欢播放音乐，因此我就提出用我的手机连接蓝牙放歌，所以随后的几天，我基本掌握了车里的点歌权。有时大家一块唱，便用我的手机轮流点歌，但我点的居多，且大部分时间都是我自己在点，几天过后，我的歌单几乎播放了一遍，导致大家对我的音乐爱好有了确切的掌握。因为一路上戈壁居多，且考虑到前有“沙漠蹦迪”，那么且将这个过程称为“戈壁KTV”吧。因为开头写唱歌，最后就也以此结尾吧，首尾呼应一下。差点忘了，最后得感谢洛雪音乐移动端提供海量无版权音乐，另外洛雪音乐还有桌面版可供使用，开源免费，简洁轻量，真的是居家旅行必备之音乐播放器。 最后是成哥的微信二维码（头像更换之前）： 2021年6月5日——6月12日 青甘大环线 一路花香一路唱 ","date":"2021-06-14","objectID":"/blog/2021/21-06-14_journey-to-northwest/:9:0","tags":["travel notes"],"title":"西北游记","uri":"/blog/2021/21-06-14_journey-to-northwest/"},{"categories":["algorithm"],"content":"概述 原本想把自己AES加密算法的整个实现过程给详细复述下来，分享给想学习的同学，也方便自己复习，但后来发现该工作量太大，加上作业太多没有过多的时间去写。所以就想把自己在学习的过程中多遇到的好的文章进行汇总，避免重复性的工作，因为我感觉有的文章的介绍和配图写的非常好，再次重复也没有意义。本文里我会将文章的链接附上，如有侵权，敬请告知！ 因为最近要完成课程作业，实现AES128加解密，本以为就是一个简单的算法实现，后来发现AES加密的每一步都挺难，而且都涉及到我没听过的概念，所以最近看了很多帖子、资料。最终终于能够解决这个问题。关于AES算法的介绍，网上有很多的帖子，所以我就不进行赘述了，我只是希望将我遇到的一些比较难以理解的点进行详细的叙述。 实现AES算法主要包括以下学习步骤： GF（2^8）域上的多项式运算 扩展的欧几里德算法 生成S盒 生成逆S盒 S盒置换 行移位 列混合 生成秘钥 循环加密 其中1、2、3、4步都跟S盒生成有关，根据我所看的一些博客，S盒的生成涉及到数论的基础知识。如果没有基础的话，1、2是要专门去学习的，我在这两步上花费了很多时间。但是在网上也可以找到很多AES算法，他们用的是现成的S盒，没有前4步，直接用现成的S盒置换，这样相对会容易一些。但是本着刨根问底和多学习知识的原则，我还是去学习了S盒的生成方式。第5步就是将每一个字符进行查表替换，没有什么难以理解的地方，所以相对而言比较容易。第6步应该是整个过程当中最简单的一步了，就是进行一个循环移位。第7步列混合涉及到矩阵和多项式的乘法，所以还是有一定难度。。。 如果想从整体上了解AES加密的完整过程，那么下面几篇文章不管从叙述还是插图上来看都是很不错的，几篇文章介绍的方式不同，但是原理都是一样的，对比结合着看会更有帮助： https://www.cnblogs.com/block2016/p/5596676.html https://blog.csdn.net/u012721519/article/details/79612128 https://www.cnblogs.com/luop/p/4334160.html http://www.alonemonkey.com/2016/05/25/aes-and-des/ 但是仅从这几篇文章来看的话，对于像我这样的小白而言还是没有办法实现的，因为各个步骤介绍的并不具体，尤其是对于缺少基本数学知识学习的同学很难理解。所以这几篇文章可以作为整体进度的把控，接下来看怎么一步步学习实现。 ","date":"2021-06-05","objectID":"/blog/2021/00-00-01_aes/:1:0","tags":["AES"],"title":"AES算法详解","uri":"/blog/2021/00-00-01_aes/"},{"categories":["algorithm"],"content":"S盒 我在学习这个算法的时候，在S盒的生成及置换上花费的时间是最多的。可能是因为基础较差，所以需要学习的东西比较多，所以我将这一部分进行了逐项的划分。关于S盒的生成及置换，这篇博客进行了非常详细的介绍，但是有一些东西我还是没明白，所以又参考了很多其他文章，才把这一部分搞明白。建议初学者以这篇博客为基础进行学习： https://blog.csdn.net/u011516178/article/details/81221646 下面进行分步的介绍。 ","date":"2021-06-05","objectID":"/blog/2021/00-00-01_aes/:2:0","tags":["AES"],"title":"AES算法详解","uri":"/blog/2021/00-00-01_aes/"},{"categories":["algorithm"],"content":"GF(2^8)域上的多项式计算 因为整个过程很多，所以我决定分为多个文章分别进行叙述，首先是GF（2^8）域上的多项式计算，因为以前也没有学过相关知识，很多概念都是第一次见到，所以这部分花了很长时间去学习。在学习这个之前，我们需要知道为什么去学习这个东西，AES加密中的哪一步用到了该知识点呢？ S盒的置换就是将0~2^8中的任意一个字节置换为另外一个，置换的原则是将该元素置换为在GF（2^8）域上的乘法逆元，什么是GF（2^8）域？什么又是逆元呢？这些定义的准确数学描述我不太懂，根据本次应用，我可以给出粗略说明，GF（2^8）有限域大概就是指定义在该域中的数值经过定义在该域上的函数运算，其结果也都在该域内， 借用网上的一个例子进行说明： 图一：GF(7)运算 那什么又是乘法逆元呢，形如： $$(a\\cdot a_{-1} ) \\% p=1$$ 其中p为有限域的范围，这里按理说应该为2^8，但是却不能取这个数，因为2^8并不与其内的每一个数互质，所以只能选一个更大的质数（具体原因请参考扩展的欧几里德算法），AES算法中p的值选的是0x11B, 我也不知道为什么，可能是约定俗成的吧，因为如果想找一个稍微比255大的质数，不知道为什么要取283（0x11B）[我后来才明白，这部分大概涉及到不可约多项式等概念，关于这一点我将会后续进行学习和补充。]。a 为有限域内的整数，那么 a_{-1} 即为 a 在有限域上的逆元。至此，我们知道逆元是什么，但是具体怎么去求解还不太清楚，这一部分请参照扩展的欧几里德算法。（更新）后来为了加深学习，我又自己写了篇博客。 我接下来继续说GF（2^8）域上的多项式运算，因为把基本的运算搞清楚是计算GF（2^8）域上乘法逆元的前提，该域上的加减乘除运算是与传统的运算所不同的，具体的多项式运算请参考GF（2^8）域上的多项式运算。当然，也可以先学习扩展的欧几里德算法，然后再学习该部分，实现的时候将欧几里德算法中的四则运算换成GF（2^8）域上的多项式运算就行了。关于GF（2^8）域的计算介绍参考以下几篇博客介绍： https://blog.csdn.net/luotuo44/article/details/41645597 https://blog.csdn.net/shelldon/article/details/54729687 http://abcdxyzk.github.io/blog/2018/04/16/isal-erase-3/ 在四则运算中，加减运算就是简单的异或运算，很简单。而乘除运算则是以乘法运算为基础，所以四则运算中最主要的是理解乘法的运算，这篇https://blog.csdn.net/bupt073114/article/details/27382533文章详细介绍了乘法运算，以及其实现。 ","date":"2021-06-05","objectID":"/blog/2021/00-00-01_aes/:2:1","tags":["AES"],"title":"AES算法详解","uri":"/blog/2021/00-00-01_aes/"},{"categories":["algorithm"],"content":"扩展的欧几里得算法 待掌握了GF（2^8）域的运算知识后，应该去学一下拓展的欧几里得算法，对于该算法，上面所给出的关于S盒生成的综述博文里已经参考相关教材进行了非常详细的论述，所以关于这部分知识可以同样参考这篇博文（参考文献10）， 还可以参考这篇博客 如果还不明白，也可以自行查找其他关于拓展欧几里得算法的介绍。 ","date":"2021-06-05","objectID":"/blog/2021/00-00-01_aes/:2:2","tags":["AES"],"title":"AES算法详解","uri":"/blog/2021/00-00-01_aes/"},{"categories":["algorithm"],"content":"S盒生成及置换 关于S盒的生成及置换，同样参考文献10，该文章已经进行了非常详尽的描述与代码实现。待自己完成后也可以参考博客中的结果进行检验。 ","date":"2021-06-05","objectID":"/blog/2021/00-00-01_aes/:2:3","tags":["AES"],"title":"AES算法详解","uri":"/blog/2021/00-00-01_aes/"},{"categories":["algorithm"],"content":"行移位 行移位就是对每行数据进行相应的循环移位，没有难以理解的地方，应该是整个加密过程最简单的部分，关于移位的规则，可以参考文献1、2、3、4，均有详细的图示介绍。下图来源于文献4： 图二：行移位 ","date":"2021-06-05","objectID":"/blog/2021/00-00-01_aes/:3:0","tags":["AES"],"title":"AES算法详解","uri":"/blog/2021/00-00-01_aes/"},{"categories":["algorithm"],"content":"列混合 列混合就是将数据矩阵乘上一个矩阵，解密的时候乘上原矩阵的逆矩阵进行解密，秩序要按照步骤一步步来即可，同样没有难以理解的地方，按照参考文献1、2、3、4的介绍进行操作就没有问题。关于列混合还可以参照这篇专门介绍的文章[11]，其对于列混合又专门的介绍与实现，而且还有检验数据。下图参照文献4中图片： 图三：列混合 ","date":"2021-06-05","objectID":"/blog/2021/00-00-01_aes/:4:0","tags":["AES"],"title":"AES算法详解","uri":"/blog/2021/00-00-01_aes/"},{"categories":["algorithm"],"content":"密钥生成 密钥的生成过程稍微有些麻烦，需要仔细参考规则，避免搞错，但是只需要理解操作规则即可，不需要理论理解，还好参考文献3、4中都有非常生动的图示。下图来源于文献4： 图四：密钥生成 ","date":"2021-06-05","objectID":"/blog/2021/00-00-01_aes/:5:0","tags":["AES"],"title":"AES算法详解","uri":"/blog/2021/00-00-01_aes/"},{"categories":["algorithm"],"content":"循环加密 循环加密就是对上述过程重复进行若干次。具体实现参照文献1、2、3、4。 ","date":"2021-06-05","objectID":"/blog/2021/00-00-01_aes/:6:0","tags":["AES"],"title":"AES算法详解","uri":"/blog/2021/00-00-01_aes/"},{"categories":["algorithm"],"content":"解密 解密过程就是将上述的过程反过来执行一遍，原本置换的就置换过来；原本移位的就反向移过来；原本乘上矩阵的就乘上她的逆矩阵。。。上面关于每个加密过程的参考文献都有相应的解密过程。 ","date":"2021-06-05","objectID":"/blog/2021/00-00-01_aes/:7:0","tags":["AES"],"title":"AES算法详解","uri":"/blog/2021/00-00-01_aes/"},{"categories":["algorithm"],"content":"实现 关于AES128的加密完整实现，可以参照代码 https://github.com/xinyu-yang/AES128-CBC，此代码的实现几乎都是参照上文的介绍，唯一不同的是在加密的时候采用了CBC模式，具体什么是CBC加密模式，如果不清楚的可以自行百度。如果有时间我也会把这部分补全。 ","date":"2021-06-05","objectID":"/blog/2021/00-00-01_aes/:8:0","tags":["AES"],"title":"AES算法详解","uri":"/blog/2021/00-00-01_aes/"},{"categories":["algorithm"],"content":"参考文献： https://blog.csdn.net/zhjchengfeng5/article/details/7786595 https://www.cnblogs.com/block2016/p/5596676.html https://blog.csdn.net/u012721519/article/details/79612128 https://www.cnblogs.com/luop/p/4334160.html http://www.alonemonkey.com/2016/05/25/aes-and-des/ https://blog.csdn.net/luotuo44/article/details/41645597 https://blog.csdn.net/shelldon/article/details/54729687 http://abcdxyzk.github.io/blog/2018/04/16/isal-erase-3/ https://blog.csdn.net/bupt073114/article/details/27382533 https://blog.csdn.net/u011516178/article/details/81221646 https://blog.csdn.net/u012620515/article/details/49893905 https://www.cnblogs.com/frog112111/archive/2012/08/19/2646012.html https://www.cnblogs.com/xinyuyang/p/11439638.html ","date":"2021-06-05","objectID":"/blog/2021/00-00-01_aes/:9:0","tags":["AES"],"title":"AES算法详解","uri":"/blog/2021/00-00-01_aes/"},{"categories":["math"],"content":"问题概述 该问题由第一位也是唯一一位华人图灵奖得主姚期智先生于1982年提出，问题很简单： 在缺少第三方公信平台的情况下，有两个百万富翁希望比较财富的高低，但是又不想让对方知道自己的具体的财富有多少。 该问题是另外一个通用问题的特殊形式，即： $a_1, a_2 … a_n$分别拥有值$x_1, x_2 … x_n$，如何在互相不泄露这些值的情况下计算$F(x_1, x_2 … x_n)$ 姚期智的这篇论文就是讨论了以上问题，对于百万富翁问题，记得有人提出可以采用称重的方法，即将富翁所有的财富转换成金子，并放置在不透明的盒子里，然后用一个天平来测量哪一个盒子更重。这是一个不错的方案，但是还是隐含借助了第三方的可信机构，抛开天平的可信性不谈，给富翁兑换金子的人（即使是多个）总是知道富翁财产的。 ","date":"2021-05-12","objectID":"/blog/2021/21-05-12_millionaire-problem/:1:0","tags":["ZK"],"title":"百万富翁问题","uri":"/blog/2021/21-05-12_millionaire-problem/"},{"categories":["math"],"content":"解决方案 那能不能借助科学的力量解决该问题呢？姚期智在他的论文里给出了肯定答案，论文中提到其一共提出了三种解决方案，但是限于篇幅只介绍了其中一种，本文也主要介绍该方法，该方法非常巧妙，让人拍案称绝，也让我感受到了图灵奖实力的冰山一角。 该方法主要借助公钥加密和单向函数来实现双方对对方消息的不可知。 具体内容如下： 假设双方为A和B，财产分别为a和b，财产范围为[0, N]。首先由A生成一对公私钥对$(PK,P)$（不失一般性），然后将公$PK$发送给B。B选择一个随机数r，然后计算$n=Enc(PK,r)-b$，并将$n$发送给A。 A收到之后便使用$n+i,\\ i\\in [0,N]$构造一个数组，并使用私钥进行加密，最终的结果为：$(Enc(P,n),Enc(P,n+1)…Enc(P,n+N))$，其中有一个$i$的值为A的财产a，即有一个$n+i$的值为$Enc(PK,r)$，但是和明显A并不知道是哪一个。 接下来A进行进一步操作，其将数组中序号大于其财产的值加一，即最终值为$Enc(P,n+i)+1,\\text{if i \u003e a}$。然后选取一个位于财产范围内的素数$p$，将数组中的所有数值对$p$取余。最终得到： $$ (Enc(P,n)\\mod p, Enc(P,n+1)\\mod p, … $$ $$ (Enc(P,n+a)+1)\\mod p, … (Enc(P,n+N)+1)\\mod p) $$ A将该数组和$p$发送给B。 B收到该数组之后，使用PK对公式中的每一项进行解密，如果第b项的值为$r\\mod p$，那么说明A的财富值大于B的财富值，否则，A的财富值小于等于B的财富值。因为，如果A的财富值大于B的财富值，则数组中的第b项为$Enc(P,n+b)\\mod p = Enc(P, Enc(PK, r))\\mod p$，否则该值将为$Enc(P,n+b)+1\\mod p$。 通过以上方式可以实现在不互相泄露信息的情况下比较财富的数值，其中加一和取余是核心操作，尤其是取余，因为其相当于一个单向函数，所以可以向B隐藏A的信息，如果没有该步骤，那么A的信息将很容易被泄露。 ","date":"2021-05-12","objectID":"/blog/2021/21-05-12_millionaire-problem/:2:0","tags":["ZK"],"title":"百万富翁问题","uri":"/blog/2021/21-05-12_millionaire-problem/"},{"categories":["math"],"content":"参考文献 [1] A. C. Yao, “Protocols for Secure Computations,” [2] https://zhiqiang.org/cs/yao-millionaires-problem.html ","date":"2021-05-12","objectID":"/blog/2021/21-05-12_millionaire-problem/:3:0","tags":["ZK"],"title":"百万富翁问题","uri":"/blog/2021/21-05-12_millionaire-problem/"},{"categories":["algorithm"],"content":"算法介绍 按照出现时间，该算法比count-min sketch出现的时间更早，但似乎没有count-min sketch应用广泛。该算法的大体思想与count-min sketch相似，只是有少许不同。 首先介绍算法的过程，初始化$t$个独立的hash函数$h_1, h_2, …,h_t$，每一个hash函数都是从集合$[n] \\to [k]$的映射。同时还要初始化$t$个符号函数$s_i : [n] \\to [\\pm 1]$，然后初始化一个二维矩阵，如下图所示： 对于具有m个元素的集合A，对其进行如下操作: Set all $C_{i,j}=0$ for i=0 to m do for j=0 to t do $C_{j,h_{j}(a_i)}$ += $s_j (a_i)$ 该操作与count-min sketch唯一不同的点在于，最后加的值有可能是1或者-1。 当查找一个元素出现的次数时，只需要计算 $$\\check{f_{q}}=median\\ C_{j,h_{j}(q)},\\ j\\in [t]$$ 这里与count-min sketch不同的是，本方法所产生的值有可能是正也有可能是负，有可能假阳也有可能假阴，而count-min sketch中只有正，所以一定会产生假阳性。仅从直觉上来判断，似乎选中间值是合理的，因为正负相互抵消，比较理想的情况就是恰好抵消完，那就没有误差了。 ","date":"2021-04-12","objectID":"/blog/2021/21-04-12_count-sketch/:1:0","tags":["hash","heavy hitter"],"title":"Count Sketch","uri":"/blog/2021/21-04-12_count-sketch/"},{"categories":["algorithm"],"content":"分析 参考了几篇文章，甚至参考了作者的原文，其证明方法都不太一样，尴尬的是我一个都没看懂😂，哎~等能看懂再补上吧。。。 路漫漫其修远兮，吾将上下而求索啊 ","date":"2021-04-12","objectID":"/blog/2021/21-04-12_count-sketch/:2:0","tags":["hash","heavy hitter"],"title":"Count Sketch","uri":"/blog/2021/21-04-12_count-sketch/"},{"categories":["algorithm"],"content":"代码实现 参考文献 https://wangshusen.github.io/code/countsketch.html 中就有一个代码实现，而且有动态图展示。 ","date":"2021-04-12","objectID":"/blog/2021/21-04-12_count-sketch/:3:0","tags":["hash","heavy hitter"],"title":"Count Sketch","uri":"/blog/2021/21-04-12_count-sketch/"},{"categories":["algorithm"],"content":"参考文献 https://web.stanford.edu/class/cs369g/files/lectures/lec8.pdf https://www.cs.rutgers.edu/~farach/pubs/FrequentStream.pdf https://wangshusen.github.io/code/countsketch.html ","date":"2021-04-12","objectID":"/blog/2021/21-04-12_count-sketch/:4:0","tags":["hash","heavy hitter"],"title":"Count Sketch","uri":"/blog/2021/21-04-12_count-sketch/"},{"categories":["信口开河"],"content":" 最近看了一些科普方面的文章和视频，所以对气候变化这件事情有了一些思考，特此记录。因为只是作为个人天马行空思考的记录，所以并无科学严谨性可言，因此几乎不会引用任何的专业文献和专业数据。  我们现在在讨论气候变化的时候，总是在说由于人类活动的原因，使得全球气候变暖，或者森林遭到砍伐，土地荒漠化等。这些环境的变化在人类生存的历史上也许是重大的环境变迁，但是如果纵观地球的发展史，就会发现，相对于地球环境变化的惊涛骇浪，现在我们所经历的变化不过是平静湖面上的微波涟漪。 那么为什么我们会对现在的环境变化如此担忧呢？我感觉答案正如某院士（记不清楚名字）在采访时所说的那样，人类不是在保护环境，人类只不过是在保护自己。  地球的环境一直都处在变化当中，其中不乏有极端夸张的气候环境，极寒或者极热，但是地球也没出问题，所以现在地球出现的这点变化，还轮不到人类去拯救的地步。因此是不是可以理解为人类所拯救的那个“地球”只不过是人类所适宜生存的那个地球状态。 毕竟相对于地球气候变化的幅度，人类所能适宜生存的气候范围实在是太小了，人类的历史相对于地球生命的历史也不过是短短一瞬。  不得不感叹人类在大自然面前如此渺小，即使人类已经在科技方面取得了重大进步，已经具备了一定的抵御自然灾害的能力，甚至有时会产生人类已经战胜大自然的错觉。但是当我们面临大自然的时候，显得是那么的无能为力。人类毫无疑问是大自然的一部分，也就是从某种意义上讲人类能够对大自然所做的一切，也都是大自然的命运安排。这种宿命论似乎有些悲观，因为人类看似具备自我思考的能力，但很可能永远无法突破大自然的限制。但并不是说人类的探索都是没有意义的，毕竟不去探索，我们永远无法知道自己可以做到什么。  个人感觉人类应当具备适应环境变化的能力，而不是一直待在舒适圈里。因为也许人类的出现将不可避免地导致大自然朝向某个方向变化，即使人类真的能保护现有环境，抑制全球变暖，使这些较为明显的环境因素保持稳定，但是我们对地球地改变将潜移默化地从很多方面体现出来，也许是人类想象不到的方面。 如果人类不能适应现有生存环境之外的环境，那么终将有一天会被能够适应的其他生命所代替。 ","date":"2021-04-10","objectID":"/blog/2021/21-04-10_climate-change/:0:0","tags":[],"title":"当我们在谈论环境保护的时候我们在谈论什么？","uri":"/blog/2021/21-04-10_climate-change/"},{"categories":["algorithm"],"content":"摘要 该算法以hash函数为基础，主要用来解决membership问题，也就是判断某个元素在不在某个集合中，可以在常数时间进行判断，但是判断结果可能存在假阳性的问题，也就是一个元素不在集合中，但是却被误判为在。该算法的实现同样是采用了以减少精确度换取较小的空间开销的思想，具体损失多少精度，又能换回多少空间是本文要解决的问题。 ","date":"2021-04-07","objectID":"/blog/2021/21-04-07_bloom-filter/:1:0","tags":["hash"],"title":"Bloom Filter","uri":"/blog/2021/21-04-07_bloom-filter/"},{"categories":["algorithm"],"content":"算法 该算法很简单且优美，下面对其进行简单描述，首先初始化一个长度为$m$的比特串$B$，并选择$k$个$[N]\\to [m]$的hash函数，对于一个每一个元素都属于$[N]$的长度为$n$的集合$S$，对其进行如下操作： Set B[.]=0 for i=1 to n do for j=1 to k do $B[h_j(S_i)]=1$ 算法很简单，就是对每一个元素，用所有的hash函数进行计算，并将所计算出的所有位置置1。查找也很简单，就是进行类似的操作，如果元素$q$的所有的hash值对应的值均为1，那么就判断元素在该集合中。 显而易见，如果$q$真的在集合中，那么肯定能得到肯定的结果，但是得到肯定的结果不代表其一定位于集合中。因为会存在假阳性的问题，所以现在的问题就是如何评估假阳性出现的概率，以及如何选取$k$和$m$的值来使内存占用和准确度都能比较好呢？ ","date":"2021-04-07","objectID":"/blog/2021/21-04-07_bloom-filter/:2:0","tags":["hash"],"title":"Bloom Filter","uri":"/blog/2021/21-04-07_bloom-filter/"},{"categories":["algorithm"],"content":"分析 首先分析对于一个元素，其不在集合当中，但是将其判断为在集合当中的概率。假设该元素经过hash函数计算之后的值分别为$a_1, a_2, …, a_k$，对于任意一个$a_i$的值为0的概率为： $$ P(B[a_i]=0) = (1-1/m)^{nk} $$ 因为假设所有的元素的hash值服从均匀分布，所以落到每一点是等概率的$1/m$，而只有当所有元素的所有hash值（共$nk$个）都没落到$a_i$点，其值才为$0$。 然后计算一个元素假阳性的概率，其假阳性代表所有的hash值对应的点均为$1$，即： $$ P(\\forall.i\\ B[a_i]=1) = (1-(1-1/m)^{nk})^k $$ 然后又根据当$m$的值较大时的近似公式： $$ (1-1/m)^{nk}=e^{-nk/m} $$ 可以将上述公式化简为$(1-e^{-nk/m})^k$。我们希望该值尽可能的小，因此在$m,n$值确定的情况下，我们希望通过$k$值的选取使得其值尽可能的小，求$(1-e^{-nk/m})^k$的最小值就相当于求$k\\cdot ln(1-e^{-nk/m})$的最小值。求导应该可以算出来，但这里有一个技巧，我们假设$p=e^{-nk/m}$，则上式可以化为： $$-\\frac{m}{n} \\ln p\\ln(1-p)$$ 根据对称性，可知当$p$取$1/2$时，其值最小,此时k的值为$\\frac{m}{n} \\ln2$。该网站有一个相应的对应表格，我们截取一部分如下图所示： -- -- -- 从图中可以看出，当$m/n$比例一定时，假阳性的值随$k$先减小再增大，比如当$m/n=9$时，其最小值在$k=6$处取得。 我们已经算出了$k$的最优取值，将其代入到假阳性计算公式中可得： $$ P = (1/2)^{\\frac{m}{n} \\ln2} \\approx (0.6185)^{m/n} $$ （居然是黄金比例0.618😮） 如果我们想让其错误率小于$\\epsilon$，就需要计算 $$ (1/2)^{\\frac{m}{n} \\ln2} \u003c \\epsilon $$ 通过上式可得，$m$的取值范围为$m \u003e n\\log e \\log\\frac{1}{\\epsilon} \\approx 1.44 n \\log\\frac{1}{\\epsilon}$。所以该方法总的空间复杂度为$k$个hash函数和一个比特串的开销，即： $$ k \\log n + n \\log(1/\\epsilon) = (n + \\log n) \\log(1/\\epsilon) $$ 感觉占用的空间也不小啊~ 以上就完成了大概的分析，但其实专业的分析好像很复杂，我尝试了一下，没看懂😂 ","date":"2021-04-07","objectID":"/blog/2021/21-04-07_bloom-filter/:3:0","tags":["hash"],"title":"Bloom Filter","uri":"/blog/2021/21-04-07_bloom-filter/"},{"categories":["algorithm"],"content":"实现 TODO ","date":"2021-04-07","objectID":"/blog/2021/21-04-07_bloom-filter/:4:0","tags":["hash"],"title":"Bloom Filter","uri":"/blog/2021/21-04-07_bloom-filter/"},{"categories":["algorithm"],"content":"参考文献 http://pages.cs.wisc.edu/~cao/papers/summary-cache/node8.html https://blog.csdn.net/jiaomeng/article/details/1495500 http://www.eecs.harvard.edu/~michaelm/postscripts/im2005b.pdf https://www.cs.utah.edu/~jeffp/teaching/cs5140-S16/cs5140/L12-Count-Min+Apriori.pdf http://www.cs.jhu.edu/~fabian/courses/CS600.624/slides/bloomslides.pdf ","date":"2021-04-07","objectID":"/blog/2021/21-04-07_bloom-filter/:5:0","tags":["hash"],"title":"Bloom Filter","uri":"/blog/2021/21-04-07_bloom-filter/"},{"categories":["algorithm"],"content":"摘要 本文主要介绍Count-Min Sketch，这是一种用来统计元素出现频率的数据结构，其基于hash函数进行构建，常用来解决\"Heavy-Hitter\"问题，即统计一个集合中经常出现的元素。本文除对算法原理进行介绍，更重要的是要对其进行数学分析，从而更好的理解该算法。 ","date":"2021-04-06","objectID":"/blog/2021/21-04-06_count-min-sketch/:1:0","tags":["hash"],"title":"Count-Min Sketch","uri":"/blog/2021/21-04-06_count-min-sketch/"},{"categories":["algorithm"],"content":"算法介绍 首先介绍算法的过程，初始化$t$个独立的hash函数$h_1, h_2, …,h_t$，每一个hash函数都是从集合$[n] \\to [k]$的映射。然后初始化一个二维矩阵，如下图所示： 我们假设$t=log(1/\\delta), k=2/\\epsilon$，至于$\\delta,\\epsilon$是什么，为什么那么赋值后面会解释，先说一下结论：当$t,k$选择上述值时，假阳性的值大于$m\\cdot \\epsilon$的概率小于$\\delta$。 对于具有m个元素的集合A，对其进行如下操作: Set all $C_{i,j}=0$ for i=0 to m do for j=0 to t do $C_{j,h_{j}(a_i)}$ += 1 当查找一个元素出现的次数时，只需要计算 $$\\check{f_{q}}=min C_{j,h_{j}(q)},j\\in [t]$$ 也就是说找到元素$q$映射到的位置当中的最小值，很明显通过此方法得到的值$\\check{f_q}$值肯定是大于等于实际值$f_q$的，因为$q$对应的值有可能与其他的值碰撞，从而产生假阳性，但是肯定不会产生假阴性。 那么到底会产生多少假阳性呢？ ","date":"2021-04-06","objectID":"/blog/2021/21-04-06_count-min-sketch/:2:0","tags":["hash"],"title":"Count-Min Sketch","uri":"/blog/2021/21-04-06_count-min-sketch/"},{"categories":["algorithm"],"content":"分析 我们希望最后的结果是能够以一定的概率保证$\\check{f_q} \u003c f_q + w$，那么下面需要做的就是怎么确定这个概率和$w$之间的关系呢？其实我们在上面已经假设$w=m\\cdot \\epsilon$，那么我们就将去求其概率。 首先我们假设一个符号$r_{i,j}$，表示由于$i$在hash函数$h_j$上导致的$q$的数量的增加，那么显然： $$ r_{i,j}= \\begin{cases} 1, \u0026 \\text{when collusion happen.} \\cr 0, \u0026 \\text{otherwise.} \\end{cases} $$ 也就是当碰撞发生时，其值为1，其他为0。如果我们想求出$r_{i,j}$的期望，就应该先求其概率。回顾该值的定义，该值定义为另外一个值$i$与$q$的碰撞所导致的值的增加，那么碰撞的概率是多少呢？如果所使用的hash函数理想的话，任意一个值与$q$的hash值相同的概率都为$1/k$。也就是说： $$ E(r_{i,j})=1/k $$ 那么容易求得： $$ E(r_{.,j})=\\sum_{i\\neq q}^m E(r_{i,j})=\\sum_{i\\neq q}^m 1/k \\approx m/k $$ 也就是说由在$h_j$处所产生的碰撞所导致的$C_{j,h_j(q)}$的值的增加–$r_{.,j}$的数学期望为$m/k$。那么根据马尔可夫不等式可以得出： $$ P(r_{.,j} \u003e w) \u003c E(r_{.,j})/w = m/kw $$ 回顾我们在一开始时设的$k=2/\\epsilon$，并将$w=m\\cdot \\epsilon$代入，可得 $$ P(r_{.,j} \u003e w) \u003c 1/2 $$ 我们以上只是分析了由$h_j$碰撞所导致的假阳性，根据算法可知，最后取得$f_q$值为所计算的hash函数的最小值，也就是说$f_q$假阳性的值取决于由所有hash函数导致的假阳性值的最小值。如果$f_q$的假阳性大于$w$，那么： $$ P(\\bar{f_q} - f_q \u003e w) = P(\\underset{j\\in t}{min}\\ r_{.,j} \u003e w) \u003c (1/2)^t $$ 又由上文可知，我们已经假设$t=log(1/\\delta)$，所以最后的结果为： $$ P(\\bar{f_q} - f_q \u003e w) \u003c \\delta $$ 这也就解释了我们一开始对于$t,k$的选值原因。最后的空间复杂度为： $$ t\\cdot \\log n + tk\\cdot \\log n = (\\frac{2}{\\epsilon} \\log m + \\log n)\\log \\frac{1}{\\delta} $$ ","date":"2021-04-06","objectID":"/blog/2021/21-04-06_count-min-sketch/:3:0","tags":["hash"],"title":"Count-Min Sketch","uri":"/blog/2021/21-04-06_count-min-sketch/"},{"categories":["algorithm"],"content":"代码实现 TODO😄 ","date":"2021-04-06","objectID":"/blog/2021/21-04-06_count-min-sketch/:4:0","tags":["hash"],"title":"Count-Min Sketch","uri":"/blog/2021/21-04-06_count-min-sketch/"},{"categories":["algorithm"],"content":"参考文献 https://www.cs.utah.edu/~jeffp/teaching/cs5140-S16/cs5140/L12-Count-Min+Apriori.pdf ","date":"2021-04-06","objectID":"/blog/2021/21-04-06_count-min-sketch/:5:0","tags":["hash"],"title":"Count-Min Sketch","uri":"/blog/2021/21-04-06_count-min-sketch/"},{"categories":["math"],"content":"最近在学习的时候遇到了一些数学证明，本身并不难，其中用到了马尔可夫不等式，但是不知道没有还是忘了，所以准备借此机会复习一下马尔可夫不等式和切比雪夫不等式（这个肯定学过）。针对这两则定理的证明网上很多很好的博客，包括维基百科，本文虽然是重复造轮子😂，但主要是为了把思考过程记录下来。 ","date":"2021-03-21","objectID":"/blog/2021/21-03-21_markov-and-chebyshev/:0:0","tags":["statistics"],"title":"马尔可夫与切比雪夫不等式","uri":"/blog/2021/21-03-21_markov-and-chebyshev/"},{"categories":["math"],"content":"马尔可夫不等式 首先把该不等式写下来： $$ P(x\u003e\\alpha) \u003c\\frac{\\mu}{\\alpha}, (x\u003e0) $$ 其中x的取值范围为$x\u003e0$，$\\mu$为x的数学期望。 看到这个公式，我的第一感觉是这个公式不对吧，公式里连方差都没有，也就是连离散程度都没有涉及怎么能够直接判定其范围呢？我甚至可以直接举出一个“反例”。 试着想象一下：假设x的分布像一条小船，中间概率小，几乎为0，两边大，几乎各占一半。$\\alpha$的值比较大，这里假设为10，并且假设在靠近0的地方x的概率密度很大，所以最后的结果是其期望为一个比较小的值，这里假设为1。 之所以认为其是反例的原因是，那么根据马尔可夫不等式，x大于$\\alpha$的概率为 $$ P (x\u003e\\alpha) \u003c\\frac{1}{10} $$ 根据前面所做的设想，这明显“不对”啊，因为值主要分布在两端嘛，怎么可能大于$\\alpha$的概率仅为1/10呢？应该是1/2左右吧。 例子如如下图（这里图画的可能不太准确，其实也不可能准确）: “反例”“反例” \" “反例” -- 仔细思考后发现该想法是不对的，因为上述想象的图形是画不出来的。假如两边的两个峰值各占一半，那么其期望不可能特别小，其期望的值应该恰好在两个峰值之间，那么马尔可夫不等式的计算结果为1/2，好像符合实际情况😮 再假设其期望就是特别小，比如说1，然后两个峰值相差很大分别为0.1，10。那么根据杠杆原理（乱入😁），期望相当于支点，则两个峰值的数据量之比肯定为10:1。那么根据马尔可夫不等式计算出的值1/10好像又是对的😮。 虽然感觉定理不对，但是为啥举的例子又都是对的呢？后来仔细想想，应该是其条件限制了x的取值范围大于0，期望就相当于支点，距离支点越远，力矩越大，所以需要的力越小，即点的数量也就越少，因此可以得到一个概率范围，嗯~~~听起来挺合理😁 以上只是我一开始的主观想象过程，下面介绍实际的证明： $$ \\begin{align} P(x\u003e\\alpha) \u0026 = \\int_\\alpha ^\\infty f(x)dx \\cr \u0026 = \\frac{1}{\\alpha}\\int_\\alpha^\\infty \\alpha f(x)dx \\cr \u0026 \u003c \\frac{1}{\\alpha}\\int_\\alpha^\\infty xf(x)dx \\cr \u0026 \u003c \\frac{1}{\\alpha}\\int_0^\\infty xf(x)dx \\cr \u0026 = \\frac{\\mu}{\\alpha} \\end{align} $$ 其数学证明很简单，值得说明的是该上界经过几次放缩，所以估计的很粗略，相对而言切比雪夫不等式就要准确一些。 ","date":"2021-03-21","objectID":"/blog/2021/21-03-21_markov-and-chebyshev/:1:0","tags":["statistics"],"title":"马尔可夫与切比雪夫不等式","uri":"/blog/2021/21-03-21_markov-and-chebyshev/"},{"categories":["math"],"content":"切比雪夫不等式 因为切比雪夫中引入了方差，所以感觉看着就比马尔可夫要靠谱些😂 $$ P(|x-\\mu |\u003e\\alpha) \u003c \\frac{\\sigma ^2}{\\alpha ^2} $$ 其中$\\mu$为期望，$\\sigma ^2$为方差。 该式的证明也很简单，直接代入马尔可夫不等式就可证明： $$ \\begin{align} P(|x-\\mu |\u003e\\alpha) \u0026 = P(|x-\\mu |^2\u003e\\alpha ^2) \\cr \u0026 \u003c \\frac{E(|x-\\mu|^2)}{\\alpha ^2} \\cr \u0026 = \\frac{\\sigma ^2}{\\alpha ^2} \\end{align} $$ 上式中的第二步转化之所以成立，是因为$E(|x-\\mu|^2)$恰好就是方差的定义啊。可见切比雪夫不等式其实就是对方差的另一种解释。不是方差恰好满足了这个式子，而是方差的定义使其一定满足该不等式。不难想象，如果方差改一下定义，那么切比雪夫不等式肯定以另一种形式出现。 另外，我学的教材中还有对切比雪夫不等式的另一种证明： $$ \\begin{align} P(|x-\\mu |\u003e\\alpha) \u0026 = P(|x-\\mu |^2\u003e\\alpha ^2) \\cr \u0026 = \\int_{|x-\\mu |^2\u003e\\alpha ^2} f(x)dx \\cr \u0026 \u003c \\int_{|x-\\mu |^2\u003e\\alpha ^2}\\frac{(x-\\mu)^2}{\\alpha ^2} f(x)dx \\cr \u0026 \u003c \\int_{-\\infty}^{\\infty}\\frac{(x-\\mu)^2}{\\alpha ^2} f(x)dx \\cr \u0026 = \\frac{\\sigma ^2}{\\alpha ^2} \\end{align} $$ 以上为我学的教材上的证明方法，可见切比雪夫不等式中的$|x-\\mu|$恰好可以和$f(x)$组成方差的计算公式。通过本博客希望自己对于上述两个不等式有更深的理解吧~😄 ","date":"2021-03-21","objectID":"/blog/2021/21-03-21_markov-and-chebyshev/:2:0","tags":["statistics"],"title":"马尔可夫与切比雪夫不等式","uri":"/blog/2021/21-03-21_markov-and-chebyshev/"},{"categories":[],"content":"关于我 程序员，现研究生在读，即将毕业（如果顺利）😂， 现无业游民一名。 Linux 用户 Vim 用户 markdown 用户 $\\LaTeX$ 用户 即使本博客有英文选项，但从目前来看，本博客大部分内容将会使用中文。 根据时间安排，本博客不定期更新👉TODO List 欢迎友好交流 👇 ","date":"2021-03-13","objectID":"/blog/about/:0:0","tags":[],"title":"关于我","uri":"/blog/about/"},{"categories":["math"],"content":" 主成分分析原理与实现--  主成分分析是一种矩阵的压缩算法，在减少矩阵维数的同时尽可能的保留原矩阵的信息，简单来说就是将 $n×m$的矩阵转换成$n×k$的矩阵，仅保留矩阵中所存在的主要特性，从而可以大大节省空间和数据量。最近课上学到这个知识，感觉很有意思，就在网上找一些博客进行学习，发现网上关于这方面的介绍很多，但是感觉都不太全面，单靠某一个介绍还是无法理解，当然这可能也跟个人基础有关。所以我在这里根据自己的理解写一个总结性的帖子，与大家分享同时也方便自己复习。对于主成分分析，可以参照以下几篇博客： PCA的数学原理该博客介绍了主成分中的数学原理，给出了比较清晰的数学解释。简单易懂，但是有一些细节并没有涉及到，所以还是不能完全理解。 PCA 原理：为什么用协方差矩阵介绍了为什么在降维的时候采用协方差矩阵，但是对于协方差矩阵的解释不详细。 关于协方差矩阵的理解对协方差矩阵的进行了详细的推导，解释了为什么可以通过$A A^T$来计算协方差矩阵。 矩阵求导、几种重要的矩阵及常用的矩阵求导公式对矩阵求导进行了介绍。提到了可能会用到的一些求导公式。 UFLDL 教程学习笔记（四）主成分分析对主成分的原理和使用进行了介绍。 ","date":"2021-03-04","objectID":"/blog/2021/00-00-03_pca/:0:0","tags":["ML","statistics"],"title":"主成分分析原理与实现","uri":"/blog/2021/00-00-03_pca/"},{"categories":["math"],"content":"1. 数学原理  数学原理的介绍部分可以参考文献1，该博客对主成分分析的数学原理进行了很直观的介绍。这里我根据自己的理解进行简单介绍。 图一（图片来源于文献 1）  对于一个坐标点$(3,2)$，我们知道其代表的意思是在二维坐标里其横坐标为3，纵坐标为2。其实这隐含了一个假设，即其横纵坐标的基为$(1,0)和(0,1)$。对于一般的二维向量，这似乎是大家的默认情况，就像随便给出一个数字$10$，大家会认为这是$10$进制表示，除非特殊标明，不会把它当作其他进制来理解。对于任意一个坐标点$(x,y)$，我们可以将其表示为： $$ \\begin{pmatrix} 1 \u0026 0 \\cr 0 \u0026 1 \\end{pmatrix} \\cdot \\begin{pmatrix} x \\cr y \\end{pmatrix} = \\begin{pmatrix} x \\cr y \\end{pmatrix} $$ 其中$\\begin{pmatrix} 1 \u0026 0 \\cr 0 \u0026 1 \\end{pmatrix}$的每一个行向量代表一个基向量。 如果我想更换基向量怎么办呢，如上图所示，如果我想知道$(3,2)$在$(\\sqrt{2}/2,\\sqrt{2}/2)与(-\\sqrt{2}/2,\\sqrt{2}/2)$基下的坐标值，该如何计算呢？回顾基本的数学知识，我们发现对于一个向量在一个基上的值其实就是该向量在该基向量上的投影。所以，已知基向量，我们可以很容易求得，对于一个向量，如$(3,2)$，其在基$(\\sqrt{2}/2,\\sqrt{2}/2)与(-\\sqrt{2}/2,\\sqrt{2}/2)$上的投影为： $$ \\begin{pmatrix} \\sqrt{2}/2 \u0026 \\sqrt{2}/2 \\cr -\\sqrt{2}/2 \u0026 \\sqrt{2}/2 \\cr \\end{pmatrix} \\cdot \\begin{pmatrix} 3 \\cr 2 \\end{pmatrix} = \\begin{pmatrix} 5\\sqrt{2}/2 \\cr -\\sqrt{2}/2 \\end{pmatrix} $$ 直观的图表示如上图所示。  再回到主成分分析上来，如果我们想对一个矩阵$A$进行降维，其中$A$为： $$ \\begin{pmatrix} a_{11} \u0026 a_{12} \u0026 \\cdots \u0026 a_{1n} \\cr a_{21} \u0026 a_{22} \u0026 \\cdots \u0026 a_{2n} \\cr \\vdots \u0026 \\vdots \u0026 \\ddots \u0026 \\vdots \\cr a_{m1} \u0026 a_{m2} \u0026 \\cdots \u0026 a_{mn} \\cr \\end{pmatrix} $$ 行向量代表样本，列向量代表特征，所以其矩阵含义为m个具有n个特征的样本值。对于每一个样本具有的n个特征值，其特征值之间可能会存在很大的耦合，就如文献1中所列举的那样，特征M代表是否为男性，特征F代表是否为女性，因为一个人的性别只能为其中的一个（不考虑特殊情况）。所以这两个特征只留一个就行了，所以就可以省下一半的空间。这个例子有些极端，但是并不影响理解。 图二（图片来源于网络）  同样对于一个具有n个特征的集合来说，很难说这n个特征都是完全有必要的，所以我们就想办法来精简一些特征。选取少于n个的基向量组，将数据投影在这个向量组上，减少空间的同时又能保证信息量。首先需要明确的一点是什么才算好的基向量？首先举一个将二维空间的数据投影到一维空间的情况。如上图所示，对于空间中的这些点，我们应该怎么投影才能够尽可能的保持数据的信息量呢？通过上图中可以看出，如果将数据投影到PC1上，那么所有的数据点较为分散，与之相反，如果投影到PC2上，则数据较为集中。考虑一个极端的情况，假如所有的点在投影之后全部集中在一个点上，这样好吗？当然不！如果所有的点都集中到一个点上，那就说明所有的点都没有差别，信息全部丢失了。所以我们希望当数据点投影到某个坐标轴之上以后，数据越分散越好，而衡量一组数据是否发散恰好有一个统计名词“方差”，也就是说投影过后的点值方差越大越好。 同时，如果数据被投影到多个基向量上，那么我们希望这些基向量之间的耦合程度越小越好，也就说基向量之间应该是正交的，如图三所示（建议点击链接去相应网站查看3D演示）。因为如果不考虑基向量之间的正交性，只考虑方差最大的话，那么所求得的所有的基向量其实都是一样的。关于在不同的基向量上的投影的线性相关度也有一个度量标准–协方差。那么我们的目标明确了，使得相同特征之间方差越大越好，不同特征之间协方差越小越好。 图三（参考文献【6】）  那么这些方差，协方差什么的怎么计算呢？这里可以先给出一个结论，将$A$向量的每一列减去该列的平均值得到一个新的$A$矩阵。然后计算$Cov=1/m \\cdot A^T\\cdot A$，得到一个$n\\times n$的矩阵$Cov$，那么$Cov$的对角线上的元素$c_{ii}$即为第i个特征的方差，对于其他元素$c_{ij}$表示第i个和第j个特征的协方差，很明显该矩阵是对称矩阵。关于该矩阵的计算方式可以参考文献3，其介绍的很详细，这里就不再重复。需要注意的一点是这里$Cov=1/m \\cdot A^T\\cdot A$是因为A矩阵的列向量为特征，所以才这样计算。如果A矩阵的行列向量所表达的含义相反则$Cov=1/m \\cdot A\\cdot A^T$。  已经知道了计算协方差矩阵的方法，下面看一下怎么跟我们要做的结合在一起。再次总结一下我们要做的是什么，对于一个已有的矩阵$A$，我们希望将它投影在一组新的基空间上，使之矩阵大小得到压缩。即： $$ D_{m,N} = A_{mn} \\cdot P_{nN}, \\ \\ \\ \\ given (N \u003c n) $$ 我们要做的就是将n个特征压缩为N个特征。对于压缩过的数据投影，根据上面的叙述可知，我们希望对于相同特征之间方差越大越好，不同特征之间协方差越小越好，并且我们已经知道该如何计算方差和协方差了。 $$ Cov(D)_ {N,N} = D^T \\cdot D = P^T A^T A P. $$ 所以现在的目标很明确，我们要做的就是求得$P$，使得$Cov(D)$的对角线元素尽可能大，非对角线元素尽可能小。学过线性代数的应该都知道，对于$A^T A$矩阵来说，其特征向量组就满足这一条件。因为已知$A^T A$矩阵为对称矩阵，所以可知： $$ P^T (A^T A) P = P^{-1} (A^T A) P = \\Lambda $$ 其中$\\Lambda$为$A^T A$的特征值组成的对角阵，$P$为相应的的特征向量组。  至此，我们就找到了进行主成分分析的方法： 首先对矩阵A进行处理，使得其每一列（或者行）减去其相应列的平均值，使得每一列的平均值都为0，然后计算$B = A^TA$。 求$B$矩阵的特征值和特征向量，将特征值进行排序，并选取前N大的特征值，选取其对应的特征向量组成特征向量组$P_{nN}$。 $D_{m,N} = A_{mn} \\cdot P_{nN}$即为最终想要得到的值。 ","date":"2021-03-04","objectID":"/blog/2021/00-00-03_pca/:1:0","tags":["ML","statistics"],"title":"主成分分析原理与实现","uri":"/blog/2021/00-00-03_pca/"},{"categories":["math"],"content":"2.实验验证  下面我们对该算法进行实际的实现，为了更好的了解PCA的工作原理，同时又保证程序的计算速度，我才用了C语言进行实现，并借助OpenBLAS库进行高效的矩阵运算。OpenBLAS是BLAS标准的一个开源实现，据说也是目前性能和维护的最好的一个。BLAS是Basic Linear Algebra Subprograms的简称，是一个矩阵运算的接口标准。既然是接口标准，那么所有根据该标准的实现都具有相同的使用方式和功能。相似的实现还有BLAS、MKL、ACML等，我使用OpenBLAS进行实现，因为其实现不依赖于任何平台，具有良好的性能，而且亲测易于安装。下面将附上我的实现代码： //矩阵运算部分 Matrix.cpp #include\u003ciostream\u003e#include\u003cstdio.h\u003e#include\u003cstdlib.h\u003e//#include \"mkl.h\" #include\"OpenBLAS/cblas.h\"class Matrix { public: //Print matrix; bool printMatrix() const; //get r. int getr() {return r;} //get l. int getc() {return c;} //get a. float *geta() {return a;} //normalization. void nmlt(); //Compute Coevariance of a, aTxa void coev(Matrix \u0026c); //Default constructor. Matrix():a(NULL), r(0), c(0) {} //Constructor with matrix pointer and dimension. Matrix(float *aa, int rr, int cc): a(aa), r(rr), c(cc) {} //Constructor with only dimension, should allocate space. Matrix(int rr, int cc): r(rr), c(cc) { a = new float[rr*cc]; } //Destructor. ~Matrix() {delete []a; a=NULL;} protected: //Matrix pointer. float *a; //Dimension n, order lda int r,c; }; extern bool printArray(float *p, int n); class SquareMatrix:public Matrix { public: //Default constructor. SquareMatrix(float *aa, int nn):Matrix(aa, nn, nn), n(nn) {} SquareMatrix(int nn): Matrix(nn, nn), n(nn){} //Destructor. ~SquareMatrix() {} //Get eigenvalue and eigenvector; int ssyevd(float *w); private: int n; }; bool Matrix::printMatrix() const { int i=0, j=0; float temp(0); for(i=0; i\u003cr; i++) { for(j=0; j\u003cc; j++) { temp = *(a+c*i+j); printf(\"%7.3f\\t\", temp); } std::cout\u003c\u003cstd::endl; } } int SquareMatrix::ssyevd(float *w) { lapack_int res = 0; res = LAPACKE_ssyevd(LAPACK_ROW_MAJOR, 'V', 'U', n, a, n, w); if(res == 0) { return res; } else { std::cout\u003c\u003c\"ERROR:\"\u003c\u003cres\u003c\u003cstd::endl; exit(-1); } } void Matrix::coev(Matrix \u0026cc) { nmlt(); cblas_sgemm(CblasRowMajor, CblasTrans, CblasNoTrans, c, c, r, 1.0/r, a, c, a, c, 0.0, cc.geta(), c); } void Matrix::nmlt() { int i=0,j=0; float av = 0.0; for(i=0;i\u003cc;i++) { av = 0.0; for(j=0;j\u003cr;j++) { av+=*(a+i+j*c); } av = av/r; for(j=0;j\u003cr;j++) { *(a+i+j*c) -= av; } } } bool printArray(float *p, int n) { for(int i=0; i\u003cn; i++) { printf(\"%7.3f\\t\", p[i]); } std::cout\u003c\u003cstd::endl; return true; } //PCA部分 PCA.cpp #include\u003ciostream\u003e#include\u003cstdio.h\u003e#include\u003cstdlib.h\u003e//#include \"mkl.h\" #include\"OpenBLAS/cblas.h\"#include\"Matrix.h\"#include\"PCA.h\" #define N 5 #define T 0.8f const char SEP = ','; static unsigned int R = 5; static unsigned int C = 5; int main(int argc, char *argv[]) { // float *A = new float [N*N] // { // 1.96f, -6.49f, -0.47f, -7.20f, -0.65f, // -6.49f, 3.80f, -6.39f, 1.50f, -6.34f, // -0.47f, -6.39f, 4.17f, -1.51f, 2.67f, // -7.20f, 1.50f, -1.51f, 5.70f, 1.80f, // -0.65f, -6.34f, 2.67f, 1.80f, -7.10f // }; if(argc \u003c= 1) { printf(\"Usage: PCA [INPUT FILE] [OUTPUT FILE] [ROW] [COLUM]\\n\"); printf(\"INPUT FILE: input file path.\\n\"); printf(\"OUTPUT FILE: output file path.\\n\"); printf(\"ROW: Row of matrix.\\n\"); printf(\"COLUM: Colum of matrix.\\n\"); exit(0); } FILE *input = fopen(argv[1], \"r\"); FILE *output = fopen(argv[2], \"w+\"); R = atof(argv[3]); C = atof(argv[4]); printf(\"Input:%s\\nOutput:%s\\nR:%d\\nC:%d\\n\",argv[1], argv[2], R, C); float *I = new float[R*C](); //float *O = new float[R*C](); char *label = new char[R]; //read matrix. readMtx(input, I, label); SquareMatrix cov = SquareMatrix(C); float *eValue = new float[C](); Matrix m = Matrix(I, R, C); Matrix n = Matrix(R, C); // m.printMatrix(); //compute coveriance matrix. m.coev(cov); //compute eigenvalue and eigenvector of coveriance matrix. cov.ssyevd(eValue); //Compute compressed matrix. eMtx(m, cov, n); //n.printMatrix(); saveMtx(output, n.geta(), label); fclose(input); fclose(output); delete []label; delete []eValue; return 0; } //eigen matrix void eMtx(Matrix\u0026a, Matrix\u0026b, Matrix\u0026r) { cblas_sgemm(CblasRowMajor, CblasNoTrans, CblasNoTrans, a.getr(), b.getc(), a.getc(), 1.0, a.geta(), a.getc(), b.geta(), b.getc(), 0.0, r.geta(), b.getc()); } bool readUtl(FILE *f, char sep) { char c; if((c=f","date":"2021-03-04","objectID":"/blog/2021/00-00-03_pca/:2:0","tags":["ML","statistics"],"title":"主成分分析原理与实现","uri":"/blog/2021/00-00-03_pca/"},{"categories":["math"],"content":"欧几里得算法 ","date":"2021-03-04","objectID":"/blog/2021/00-00-02_euclid/:1:0","tags":["math"],"title":"Euclid Algorithm and Extended Euclid Algorithm.","uri":"/blog/2021/00-00-02_euclid/"},{"categories":["math"],"content":"原理 欧几里得算法是一种快速计算最大公约数的算法，对于任意的两个数$(a,b)$，其最大公约数表示为$gcd(a,b)$，根据欧几里得算法，$gcd(a,b)=gcd(b,a\\mod b)$ 。证明如下： 如果$b\u003ea$，显然成立；因此只需考虑$b \u003c a$的情况。根据初等数学知识，可知$a,b$的关系可表示为$a=qb+r$，其中$q$为商，$r$为余数。 对于$(a,b)$的最大公约数$g1=gcd(a,b)$，当然$g1|a,g1|b$（$g1|a$表示$g1$整除$a$），所以易知对于$r=a-qb$，同样满足$g1|r$； 又因为$a\\mod b=r$，所以对于$a,b$的最大公约数$g1$，同样满足$g1|(a\\mod b),g1|b$，即$(b,a\\mod b)$的最大公约数至少为$g1$，即$gcd(b,a\\mod b)\u003eg1=gcd(a,b)$。 反过来，对于$(b,a\\mod b)$的最大公约数$g2=gcd(b,a\\mod b)$，同样满足$g2|a, g2|b$，即$gcd(a,b)\u003eg2=gcd(b,a\\mod b)$。 因此$gcd(a,b)=gcd(b,a\\mod b)$证明成立。下面对该算法进行实现。 ","date":"2021-03-04","objectID":"/blog/2021/00-00-02_euclid/:1:1","tags":["math"],"title":"Euclid Algorithm and Extended Euclid Algorithm.","uri":"/blog/2021/00-00-02_euclid/"},{"categories":["math"],"content":"实现 #include \u003ciostream\u003e using namespace std; int euclid(int a, int b) { if (b!=0) { return euclid(b, a%b); } else { return a; } } int main() { int a(0),b(0); cin \u003e\u003e a \u003e\u003e b; cout \u003c\u003c euclid(a,b); return 0; } ","date":"2021-03-04","objectID":"/blog/2021/00-00-02_euclid/:1:2","tags":["math"],"title":"Euclid Algorithm and Extended Euclid Algorithm.","uri":"/blog/2021/00-00-02_euclid/"},{"categories":["math"],"content":"拓展的欧几里得算法 ","date":"2021-03-04","objectID":"/blog/2021/00-00-02_euclid/:2:0","tags":["math"],"title":"Euclid Algorithm and Extended Euclid Algorithm.","uri":"/blog/2021/00-00-02_euclid/"},{"categories":["math"],"content":"原理 拓展的欧几里得算法在密码学中有着重要的应用，现给出定理： 对正整数a，b；总是存在一组整数X,Y，使得$Xa+Yb=gcd(a,b)$成立，且$gcd(a,b)$为满足这种条件的最小整数。 这里不对该定理进行证明，欧几里得算法给出了在已知$a，b$的情况下求$gcd(a,b)$的方法，但是如果想要求得X，Y的值，就要求助于拓展的欧几里得算法。怎么才能从欧几里得算法的计算过程当中得到我们想要求解的值呢？我们再次详细回顾欧几里得算法的求解过程。 对于已知整数$a,b$，我们的算法求解过程如下： $a$ $b$ 余数$r$ 商$q$ a b $r_1=a\\mod b$ $q_1=a/b$ b $r_1$ $r_2=b\\mod r_1$ $q_2=b/r_1$ $r_1$ $r_2$ $r_3=r_1\\mod r_2$ $q_3=r_1/r_2$ … … … … $r_{n-1}$ $r_n$ $r_{n+1}=r_{n-1}\\mod r_n$ $q_{n+1}=r_{n-1}/r_n$ 逐步计算，直到某一步出现$r_{n-1}\\mod r_{n}=0$的情况，这时候就找到了最大公约数，最大公约数即为$r_n$，以上就是欧几里得算法的全过程。通过这个过程当中多产生的一些中间结果我们能不能求得$X,Y$的值呢？下面进行两种求解方法的推导。 ","date":"2021-03-04","objectID":"/blog/2021/00-00-02_euclid/:2:1","tags":["math"],"title":"Euclid Algorithm and Extended Euclid Algorithm.","uri":"/blog/2021/00-00-02_euclid/"},{"categories":["math"],"content":"递归求解 根据上面的表格我知道，$Xa+Yb=gcd(a,b)$，并且对于中间所求解的每一步我们所得到的$r_i$都满足$X_i\\cdot r_i+Y_i\\cdot r_{i+1}=gcd(a,b)$，因为很明显每一对$r_i,r_{i+1}$都满足最大公约数为$gcd(a,b)$，这也是欧几里得算法的原理。 我们试着寻找$(X_i,Y_i),(X_{i+1},Y_{i+1})$之间的递推关系，由以上阐述可知: $$ \\begin{cases} X_i\\cdot r_i+Y_i\\cdot r_{i+1}=gcd(a,b), \u0026\\text{(1)} \\cr X_{i+1}\\cdot r_{i+1}+Y_{i+1}\\cdot r_{i+2}=gcd(a,b),\u0026\\text{(2)} \\end{cases} $$ 为了将上式转换成$r_i$的方程组，我们使用$r_{i+1},r_{i+2}来表示r_i$，通过以上可知$r_i=r_i/r_{i+1}\\cdot r_{i+1}+r_{i+2}$，将该式带入上式（1），并将两式合并可得： $$ X_i\\cdot (r_i/r_{i+1}\\cdot r_{i+1}+r_{i+2})+Y_i\\cdot r_{i+1}=X_{i+1}\\cdot r_{i+1}+Y_{i+1}\\cdot r_{i+2} $$ 进一步化简可得： $$ (X_i\\cdot r_i/r_{i+1}+Y_i)\\cdot r_{i+1}+X_i\\cdot r_{i+2}=X_{i+1}\\cdot r_{i+1}+Y_{i+1}\\cdot r_{i+2} $$ 根据系数相等的原则可得： $$ \\begin{cases} X_i\\cdot r_i/r_{i+1}+Y_i=X_{i+1}, \u0026\\text{(1)}\\cr X_i=Y_{i+1},\u0026\\text{(2)} \\end{cases} $$ 以上就得到了$(X_i,Y_i),(X_{i+1},Y_{i+1})$之间的递推关系，那么我们接下来的工作就是找到一对可以求出其值的$(X_i,Y_i)$，通过以上可知当出现某一次计算使得$r_{i}\\mod r_{i+1}=0$时，我们可知对于$X_i\\cdot r_i+Y_i\\cdot r_{i+1}=gcd(a,b)$，满足$gcd(a,b)=r_{i+1}$，那么很显然$X_i=0,Y_i=1$。于是我们就得到了一对$(X_i,Y_i)$的值，我们已经知道了最后一对$r_{i},r_{i+1}$所对应的$(X_i,Y_i)$才能够推知前面的值，所以我们的推导是从后往前推的，因此我们将上面的递推关系稍微变换一下形式： $$ \\begin{cases} X_i=Y_{i+1},\u0026\\text{(1)}\\cr Y_i=X_{i+1}-Y_{i+1}\\cdot r_i/r_{i+1}, \u0026\\text{(2)} \\end{cases} $$ 此时我们就得到了推导关系和初值，通过计算我们就可以求得满足$Xa+Yb=gcd(a,b)$的$X,Y$值。下面通过代码对其进行实现： #include \u003ciostream\u003e using namespace std; void extEuc(int a, int b, int\u0026x, int\u0026y) { int rx,ry; int r(0); if (a%b==0) { x=0;y=1; return; } else { r = a%b; extEuc(b, r, rx, ry); x = ry; y = rx - ry*a/b; return; } } int main() { int a,b; int x,y; cin \u003e\u003e a \u003e\u003e b; extEuc(a, b, x, y); cout \u003c\u003c x \u003c\u003c' '\u003c\u003c y \u003c\u003c endl; return 0; } 输入42 2017可求得输出为-48，1。 ","date":"2021-03-04","objectID":"/blog/2021/00-00-02_euclid/:2:2","tags":["math"],"title":"Euclid Algorithm and Extended Euclid Algorithm.","uri":"/blog/2021/00-00-02_euclid/"},{"categories":["math"],"content":"迭代求解 较多的递归调用可能会影响计算速度，所以我们接下来推一下迭代的计算方式，已知上面表格中所列欧几里得算法的计算步骤。已知$gcd(a,b)$是满足该集合的最小值$\\lbrace Xa+Yb | X,Y\\in Z \\rbrace$，已知对于每一步所产生的余数均能被$gcd(a,b)$整除，现在考虑每一步迭代所产生的余数满足的等式： $$ \\begin{cases} r_i=X_i\\cdot a+Y_i\\cdot b \\cr r_{i+1}=X_{i+1}\\cdot a + Y_{i+1}\\cdot b \\end{cases} $$ 且已知$r_i, r_{i+1}$满足$r_{i-1}=r_{i-1}/r_i\\cdot r_i+r_{i+1}$，将上面两式代入到该式，可得： $$ r_{i-1}=(r_{i-1}/r_i\\cdot X_i+X_{i+1})\\cdot a+(r_{i-1}/r_i\\cdot Y_i +Y_{i+1})\\cdot b. $$ 值得注意的是此处的$X_i,Y_i$与递归方法中的值含义不同。根据上式可推知以下递推关系： $$\\begin{cases} X_{i+1}=X_{i-1}-r_{i-1}/r_i\\cdot X_i \\cr Y_{i+1}=Y_{i-1}-r_{i-1}/r_i\\cdot Y_i \\end{cases}$$ 已知中间的递推关系，关键是考虑如何判断循环的起始值和结束条件，对于$a,b$也可看做是余数$r_i$，那么对于$a,b$来说，其满足的值为： $$\\begin{cases} a = a\\cdot 1 + b\\cdot 0\\cr b = a\\cdot 0 + b\\cdot 1 \\end{cases}$$ 所以就得到了两对$(X,Y)$的值，分别为$(1,0),(0,1)$，并且已知$r_i$之间的递推关系为$r_{i+1}=r_{i-1}\\mod r_i$。我们也知道循环结束的条件为$r_i=gcd(a,b)$，其最后的形式为$Xa+Yb=gcd(a,b)$，其直接判断方式为$r_{i-1}\\mod r_i=0$，然后我们就得到了最终的$X,Y$值，根据以上递推形式，我们有以下实现： #include \u003ciostream\u003e using namespace std; int main() { int a,b; int x1(1),y1(0),x2(0),y2(1); int temp; cin \u003e\u003e a \u003e\u003e b; while (a%b!=0) { temp = x2; x2 = x1 - a/b*x2; x1 = temp; temp = y2; y2 = y1 - a/b*y2; y1 = temp; temp = a%b; a = b; b = temp; } cout \u003c\u003c x2 \u003c\u003c' '\u003c\u003cy2\u003c\u003cendl; return 0; } 输入42 2017可求得输出为-48，1。 这里有一个用尽可能多的程序语言实现求逆元的网站，大家也可以参考这里的不同实现。 参考文献 [1] Katz J，Lindel Y．Introduction to Modern Cryptography—Principle and Protocol现代密码学——原理与协议【M】任伟．北京：国防工业出版社．2010：10-15． ","date":"2021-03-04","objectID":"/blog/2021/00-00-02_euclid/:2:3","tags":["math"],"title":"Euclid Algorithm and Extended Euclid Algorithm.","uri":"/blog/2021/00-00-02_euclid/"},{"categories":["record"],"content":"本博客第一篇文章，主要记录本博客搭建和配置的过程","date":"2021-03-04","objectID":"/blog/2021/hello-world/","tags":["blog"],"title":"Hello World","uri":"/blog/2021/hello-world/"},{"categories":["record"],"content":"博客搭建记录 在阅读了众多的博客搭建教程之后，最终选择了使用github + hugo 进行搭建，主题为 even. 希望借此博客在互联网上留下一点有价值的东西，同时作为自己的学习笔记，温故而知新。 Image testtestImg \" Image test ","date":"2021-03-04","objectID":"/blog/2021/hello-world/:1:0","tags":["blog"],"title":"Hello World","uri":"/blog/2021/hello-world/"},{"categories":["record"],"content":"软件安装 首先进行相应软件的安装，具体可以参考官方文档的安装步骤。本文以 ubuntu 举例说明。在 ubuntu 上可直接使用apt进行安装，但是使用该方法安装的 hugo 软件版本过低，会导致本文所使用的主题 even 无法使用（我所使用的 even 要求最低版本为 0.60），而且这个问题可能在其他主题上也存在。总而言之，建议直接安装最新版本，可直接到 release 下载。 ","date":"2021-03-04","objectID":"/blog/2021/hello-world/:1:1","tags":["blog"],"title":"Hello World","uri":"/blog/2021/hello-world/"},{"categories":["record"],"content":"网站和主题配置 软件安装好了之后，可以创建一个文件夹作为根目录(如mkdir blog)并使用git init进行初始化，然后在该目录下进行 hugo 的初始化，初始化操作为 hugo new site [blogs name] 然后在该目录下就会创建一些文件夹，如： -- README.md -- archetypes -- config.toml -- content -- public -- resources -- themes 文件夹的具体作用我正在继续摸索，现在大概知道config.toml是全局配置文件，关于网站的一些常用配置基本都放在这里。当下载和使用某个主题的时候，该主题一般会提供一个配置模板，用户只需要把该文件复制到博客根目录下，并且根据主题或者模板中的注释按需修改即可。具体使用要参考不同主题。 content文件夹中放置的是博客的内容，如本博客的路径就是content/post/hello-world。经过摸索本人发现，content 文件夹下的子文件夹的名字可以随便起，只要最后在配置文件中使用相同的配置即可。另外，在子文件夹下也可以再建文件夹，这时的文件夹也可以随便取名字，而且无需在配置文件中进行配置。 推测 hugo 的机制是会扫描 content 的子文件夹下 (e.g., post) 所有的 markdown 文件。 themes中所存放的就是主题文件，文件夹下可有多个主题，但是在使用的时候只能指定其中一个，具体使用哪个可以在全局配置文件中配置。 public中所存放的是一些经过编译的网页内容，即使用 markdown 编写的博客经过编译以后会放到这个文件夹里，该文件夹下的所有东西会被原封不动地发布。对于创作者来说，这部分编译生成的东西不需要过分关心。因为具体编译出什么样的效果都可以在编译之前进行设置。 archetypes中存放的好像是模板之类的东西，hugo 官网对此有一些介绍，但我没有深入研究，目前只是用了些简单的配置。简单来说，这部分中有一个名为 default.md的模板文件，里面存放着一些默认配置，当使用命令 hugo new xxx/xxx.md创建新的博客的时候，会自动按照该模板文件进行创建。该模板包含一些默认配置，用户可以对不同博客的配置进行修改。 接下来讨论怎么设置主题，经过一段时间纠结的筛选后，决定暂时使用even主题，主要原因有： 主题看来还算简洁 维护还算活跃 该主题是一个博客性质的主题，比较符合目前需求 该主题的开发者是国人同胞，可能比较符合国人的应用习惯 选定主题后，就将该主题 clone 到 themes 文件夹下并命名为 even 。然后将该仓库添加为本仓库的子模块。 git submodule add https://github.com/olOwOlo/hugo-theme-even ./themes/even 然后可以参考 even 主题的教程，将其配置文件进行拷贝和自行配置。其配置方面的文档较少，但好处是其配置文档中都使用了中文对其作用和用法进行了大概的注释，同样也可以根据需求进行增添内容，具体细节将后续进行学习。 ————21/04/07更新———– 感觉 even 有些功能不理想，比如说分类和标签没有任何区分度，并且作者似乎已经停止开发了，所以准备转到 LoveIt 的继任者 CodeIT 上，不过 even 也有优点，就是作者是国人，所以一些特性（如百度统计、不蒜子等）还是挺符合国人习惯和应用需求的。 但是写博客不就是为了折腾吗？😂，把仅有的几个博客来回迁移😂。选定新的主题后，准备进行迁移，下面准备讲述更新过程。使用这两个主题的时候都会遇到一个问题，就是数学公式的显示问题，感觉两个主题都有一些不尽如人意的地方，接下来将讲述我遇到的问题，以及目前所采用的方式。希望以后能够有机会了解 hugo 的细节，从而更好的解决该问题。 首先是 even 主题，该主题使用的是 mathjax 进行公式的渲染，经过网上了解， mathjax 是一个很成熟的解决方案，所以其对数学公式的支持还是很完善的，但是在使用较复杂的数学公式环境过程中还是遇到了一个问题，如: \\begin{align} x \u0026= y + 1 \\\\ y \u0026= z + 2 \\end{align} 在 $\\LaTeX$ 中是没有问题的，但是在 hugo 就无法被正确渲染，只有将换行符\\\\更改为\\\\\\\\才能正常工作，好像看到网上有相关的讨论（没有记录），说导致该问题的原因是 markdown 编译器在进行解析的时候会将第一斜杠解释为转义，那么最后的结果是只剩一个斜杠，所以如果想让其最后仍然有两个斜杠，则不得不用四个斜杠。虽说敲四个斜杠是麻烦了点，但是好歹问题算是大概解决了。 后来试用 CodeIT 主题时则出现了更严重的问题，主要是因为该主题使用的是据说是性能更好的 $KaTeX$ 渲染器。该渲染器作为托管在 github 的开源项目还是挺受欢迎的，但是 katex 对于公式的支持就不那么完善了，截止到目前的最新版本 0.13.0，刚能够支持诸如align,align*等环境。而 CodeIT 使用的仍然是 0.11.1 的老版本，但这还不是主要问题，主要问题是原本在 mathjax 中可行的方案在 katex 中不可行了，比如根据文档 katex v0.11.1 中是支持aligned环境的，但是以下代码并不能够被正确渲染： \\begin{aligned} x \u0026= y + 1 \\\\\\\\ y \u0026= z + 2 \\end{aligned} 该代码可以在 even 主题下正常工作，但是无法在 CodeIT 在工作，经网上搜索，发现了该解决方案，经该方案介绍，使用如下代码可正常工作： \\begin{aligned} x \u0026= y + 1 \\cr y \u0026= z + 2 \\end{aligned} 其效果为： $$ \\begin{aligned} x \u0026= y + 1 \\cr y \u0026= z + 2 \\end{aligned} $$ 主要改动为将斜杠更换为\\cr，经测试可以正常工作，然后将该方式在 even 主题中测试也可以工作，所以就计划采用这种方式来代替双斜杠的功能，虽然感觉像是最后对问题的妥协，但是好歹是解决了该问题😂 后来有对问题做进一步的探索，做法是在浏览器中查看网页的源代码，我发现使用斜杠做为换行符的方式都会在公式行的最后引入一个\u003cbr\u003e标签，如下所示： \\begin{aligned} x \u0026amp;= y + 1 \\\\ \u003cbr\u003e y \u0026amp;= z + 2 \\end{aligned} 具有标签的代码在使用 mathjax 渲染器的时候是可以被正常渲染的，但是在 katex 中却不行。而使用\\cr进行换行则不会引入\u003cbr\u003e标签，因此在 katex 中可用。 最后附上将换行符更改为\\cr的命令: sed -i 's/\\\\\\\\\\\\\\\\/\\\\cr/' [blogname].md ————21/04/08更新———– 除上述所示问题外，今天又遇到了另外一个问题，那就是在公式中使用特殊字符（如%）时需要进行转义，一般写为\\%，但是这又会遇到一个问题，就是在$符号之间的字符不能够像在 ` 符号中那样被免于转义。也就是说\\%中的斜杠会在markdown解析的过程中解析为转义字符，因此到公式解析器的时候剩下的就只剩一个%符号了，所以需要使用两个符号才行。关于这个问题，感觉主要问题还是在markdown解析器那里没有执行正确的解析。当然，以上只是我的猜想，有时间我会去验证的。 知道问题之后的解决方式呢？如果实在不得不用特殊字符的转义，那就使用上述方法，可以解决。如果不是必要，比如我这里就是将%作为模运算符号，其实math里有专门的符号\\mod表示该含义，所以出于兼容性期间，决定使用\\mod符号，因为万一哪一天markdown解析器可以正常解析了，岂不是还要把两个斜线换成一个。 同时这里有一个总结：在markdown的公式环境中尽量减少使用转义符👉\\👈 ","date":"2021-03-04","objectID":"/blog/2021/hello-world/:1:2","tags":["blog"],"title":"Hello World","uri":"/blog/2021/hello-world/"},{"categories":["record"],"content":"主题开发 ————21/10/26更新———– 鉴于已有主题的不尽如人意，所以本着折腾的精神，本人决定基于 CodeIT 主题进行折腾，主要目标有两个：1.增加自己想要的特性（如不蒜子统计阅读量等）2.删除过于冗余的功能 新的主题名为 EnjoyIt，意为享受折腾写博客的过程。本人所有的对本博客的设置都将体现在该主题上。 ————21/11/4更新———— 感觉原主题的白色背景太过刺眼，所以就换了个米黄色的背景颜色。 另外，感觉原本主题的默认字体不是特别好看，尤其是在同时有中文和英文的情况下，所以本人打算更改下默认字体。但经摸索后发现现有设置是加载最高效的方式（优先使用默认字体），决定暂时还是不改了，以性能为重。 ———–21/11/19更新———— 结合自己对于模板的学习，新增加了该章节。这部分主要记录自己在摸索过程中所学到的一些东西。 首先，对于一个主题，主要有以下目录结构： |-- [theme name] \\ |-- archetypes |-- assets |-- exampleSite |-- i18n |-- images |-- layouts |-- resources |-- src |-- static |-- theme.toml 其中，theme.toml即为配置文件模板。archetypes 文件夹中存放的东西与上文介绍相同，即一些模板文件。 assets 文件夹中存放了 css 文件和所有使用到的 javascript 库。 exampleSite 中存放了一个示例站点，感觉是用来调试主题的，切换到该目录下可以直接运行 hugo server 进行查看。该目录下的目录结构与上文所述网站目录相似，当然肯定没有 themes ，要不然不就循环依赖了嘛。 i18n 目录下存放的是用来进行多语言支持的一些文件。images 文件夹顾名思义，就是用来存放一些用户的图片。 static 也可以用来存一些图片，但是这部分图片一般是主题的一部分，而不像 images 中存放用户图片。同时该目录下还会存一些如字体、emoji 表情等静态文件。 resources 目录没搞明白，不过看起来像是存了一些自动生成的文件。 至于 src 目录则是存放了该主题的源代码，这个文件夹似乎是自定义的，而不是主题须有的常规文件夹。 之所以把 layouts 文件夹放到最后，就是因为该文件夹下存了关于主题配置的大部分内容。实际上我对于主题的定制化工作，也大部分都是在此目录下完成的。首先看下该文件夹下的重点目录： |-- _default |-- partials \\ |-- assets.html |-- comment.html |-- footer.html |-- function |-- head |-- header.html |-- home |-- init.html |-- paginator.html |-- plugin |-- rss |-- scratch |-- single |-- posts |-- robots.txt |-- shortcodes |-- taxonomy 其中，重点的配置主要都集中在 partials 目录，该部分定义了博客的 header, footer, comment 等，同时针对不同的界面 home, single 等也可以有不同的配置。所有的这些配置采用了 hugo 的语法进行编写，所以如果想要自己定制的话，需要先学习下相应的语法知识。 ","date":"2021-03-04","objectID":"/blog/2021/hello-world/:1:3","tags":["blog"],"title":"Hello World","uri":"/blog/2021/hello-world/"},{"categories":["record"],"content":"评论系统 不得不说的一个话题是评论系统，一个完善的博客平台，需要有与读者直接交流的方式。目前有很多解决方案，成熟的解决方案有 disqus，当时好像需要后端的支持，但像我这种想把博客免费部署到 github 上的人来说，后端支持太奢侈了。 幸运的是开源社区有很多很好的“无后端（白嫖后端）”评论系统，像是 utterances, gitalk, valine 等，前两者都使用了 github 的 issue 机制来实现评论的记录和用户的管理。界面漂亮，功能稳定，如果搭载 github page 使用，真的是原汤化原食， github 全家桶。 而且我最近又在 github 上看到了一个类似的项目 giscus, 该项目几乎完全借鉴了 utterances，但改进在于该评论系统使用了 github 最新推出的 discussions 功能进行评论的管理，相对于 issue 机制来说，这种方式明显看起来更专业。因为 discussion 模块本来就是用来讨论的，所以可以对别人的评论进行直接回复，而不是只有一个@xxx。对于想使用 github 托管评论的博主，giscus 是更加先进的选择。 以上基于 github 的评论系统做的都非常优秀，但是他们有一个共同的问题，就是用户需要使用 github 账号登录才能进行评论。这对于像我这种程序员来说不是问题，毕竟我本人使用 github 的频率和某信差不多，但是这并不适用所有人。 而且当我看到 valine 简洁漂亮的界面，以及无需登录就可以评论的功能时，我决定尝试下该评论系统。配置好之后感觉还是很满意的，具体效果见文章末尾。 关于不同评论系统的对比，有位同学写了篇文章，我感觉还不错，不了解的同学可以参考下。 另外，从他的文章中我又了解了另外一个评论系统 waline，该博客系统似乎借鉴了 valine。 ","date":"2021-03-04","objectID":"/blog/2021/hello-world/:1:4","tags":["blog"],"title":"Hello World","uri":"/blog/2021/hello-world/"},{"categories":["record"],"content":"写博客 上面已经进行了大概的配置，下面将介绍怎么写一篇博客。首先使用 hugo new post/hello-world 创建一个新的博客，该命令将创建一个文件：content/post/hello-world.md。该文件会包含一个文件头 title: *** date: 202*** draft: true draft一栏默认为true，如果想要发布该博客，需要将其修改为false。 hugo的一个好处就是可以边写博客边进行调试，其具体操作为：在主目录下（即blog/）运行 hugo server -D 该命令将启动一个本地服务，端口号为1313，在本地使用浏览器访问：http://localhost:1313即可在线预览自己的博客内容。每次保存文件时，hugo都会自动进行编译，速度很快，几乎实现了markdown的同步预览，非常方便！ 在发布之前应该使用 hugo -D 编译一下，整个网站的源代码会输出到 public 文件夹，至此已经可以实现基本的功能。 ","date":"2021-03-04","objectID":"/blog/2021/hello-world/:1:5","tags":["blog"],"title":"Hello World","uri":"/blog/2021/hello-world/"},{"categories":["record"],"content":"使用github发布博客 首先要有一个github账号，然后创建一个新的仓库，其名字为：[your github id].github.io，关于这方面的教程非常多，也很简单，这里就不再赘述。然后其部署可参考https://gohugo.io/hosting-and-deployment/hosting-on-github/#build-hugo-with-github-action。其操作非常方便，只需要创建一个文件，然后将一些github action代码复制进去就行了。具体原理后续研究…(这里不得不感叹一句，github的功能比我想象的要强大多了!) 然后就是将本地文件(即blog/文件夹)push到所创建的仓库中。最后需要注意的是在上面所创建的仓库的设置页面要进行一定的设置，其位置为setting-\u003egithub pages-\u003esource，需要将branch更改为gh-pages，路径为root，在这里还可以设置定制化的域名等，这里先暂时不研究。通过以上设置应该就可以成功访问页面了。如本博客主页为：http://xinyu-yang.github.io ———–21/11/19更新———— 后来发现，因为把原文档 push 到 github 仓库之后，github action 会自动进行编译。所以在 push 之前，甚至不用自己编译，直接将原文档 push 上去即可。 ","date":"2021-03-04","objectID":"/blog/2021/hello-world/:1:6","tags":["blog"],"title":"Hello World","uri":"/blog/2021/hello-world/"},{"categories":["record"],"content":"图床 以前用CSDN和博客园写的时候根本不用考虑这个问题，但是现在自己搭建博客的时候就需要好好考虑一下这个问题。一开始惊喜的发现有很多的免费图床网站（比如imgbb），开心的以为这个问题解决了，后来发现没那么简单。因为这些免费的图床往往有很多限制，比如上面举例说的这个imgbb，该网站一开始用着还行，可是过几天再在博客里加载图片时只能加载出缩略图了。 后来就寻求解决方案，最后的决定是仍然使用开源的代码托管网站托管图片，把白嫖进行到底😂。最终我决定使用PicGo+(Gitee/Gitlab/Github)实现。 图床部分本来只有简单介绍，后来觉得各种东西都放在同一篇博客就显得太混杂了，因此另起了一篇新的博客进行介绍——文章地址 ","date":"2021-03-04","objectID":"/blog/2021/hello-world/:1:7","tags":["blog"],"title":"Hello World","uri":"/blog/2021/hello-world/"}]